id,created_at,published_at,name,body,author_url,author_id,author_login,assets_url,url,target_commitish,tarball_url,html_url,zipball_url,tag_name,draft,prerelease
8265240,2017-10-26T03:40:52Z,2017-10-26T03:41:43Z,v8.5.4,"# FAQ

### Looking for free and real-time support?

    https://github.com/kataras/iris/issues
    https://chat.iris-go.com

### Looking for previous versions?

    https://github.com/kataras/iris/releases

### Should I upgrade my Iris?

Developers are not forced to upgrade if they don't really need it. Upgrade whenever you feel ready.

> Iris uses the [vendor directory](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo) feature, so you get truly reproducible builds, as this method guards against upstream renames and deletes.

# Th, 26 October 2017 | v8.5.4

This version is part of the [releases](https://github.com/kataras/iris/releases).

## Version Updater

Not any new features or fixes (all reported bugs are fixed) in this version, just a tiny improvement.

**More friendly version checker!**

> Remember: If you don't want to keep the version checker and you're pretty sure that you will be able to keep your server up-to-date manually, then you can disable the auto updater via; `app.Run(..., iris.WithoutVersionChecker)`.

## We need your help with translations into your native language

Iris needs your help, please think about contributing to the translation of the [README](README.md) and https://iris-go.com, you will be rewarded.

Instructions can be found at: https://github.com/kataras/iris/issues/796

# Su, 22 October 2017 | v8.5.3

- FIX: [Websocket: memory leak on startPinger](https://github.com/kataras/iris/issues/787) by @jerson with PR: https://github.com/kataras/iris/pull/788
- FIX: [Websocket: time.Ticker cause memory leak](https://github.com/kataras/iris/issues/791) by @jerson with PR: https://github.com/kataras/iris/pull/792
- NEW: [Websocket: total connections](https://github.com/kataras/iris/issues/793) by @jerson with PR: https://github.com/kataras/iris/pull/795
- NEW: Add a `raven` middleware inside [iris-contrib/middleware/raven](https://github.com/iris-contrib/middleware/tree/master/raven) as requested at ""[Can I use iris with sentry?](https://github.com/kataras/iris/issues/785)""

### üéóÔ∏è People that you should follow

Help this project to continue deliver awesome and unique features with the higher code quality as possible by donating any amount via [PayPal](https://www.paypal.me/kataras) or [BTC](https://iris-go.com/v8/donate)!

| Name | Amount | Membership |
| -----------|--------|--------|
| [Juan Sebasti√°n Su√°rez Valencia](https://github.com/Juanses) | 20 EUR |  Bronze |
| [Bob Lee](https://github.com/li3p) | 20 EUR |  Bronze |
| [Celso Luiz](https://github.com/celsosz) | 50 EUR |  **Silver** |
| [Ankur Srivastava](https://github.com/ansrivas) | 20 EUR |  Bronze |
| [Damon Zhao](https://github.com/se77en) | 20 EUR |  Bronze |
| [Exponity - Tech Company](https://github.com/exponity) | 30 EUR |  Bronze |
| [Thomas Fritz](https://github.com/thomasfr) | 25 EUR |  Bronze |
| [Thanos V.](http://mykonosbiennale.com/) | 20 EUR |  Bronze |
| [George Opritescu](https://github.com/International) | 20 EUR |  Bronze |
| [Lex Tang](https://github.com/lexrus) | 20 EUR |  Bronze |
| [Bill Q.](https://github.com/hiveminded) | 600 EUR |  **Gold** |
| [Conrad Steenberg](https://github.com/hengestone) | 25 EUR |  Bronze |

# Th, 12 October 2017 | v8.5.2

This version is part of the [releases](https://github.com/kataras/iris/releases).

## MVC

Add `bool` as a supported return value, if false then skips everything else and fires 404 not found.

New example which covers the Service and Repository layers side-by-side with the MVC Architectural pattern, clean and simple: [_examples/mvc/overview](_examples/mvc/overview).

## Websocket

Fix(?) https://github.com/kataras/iris/issues/782 by @jerson with PR:  https://github.com/kataras/iris/pull/783.

## Minor

Add some minor comments for the view/django's origin type getters-- as pushed at PR: [#765](https://github.com/kataras/iris/pull/765).

[sessions/sessiondb/badger](sessions/sessiondb/badger) vendored with: https://github.com/kataras/iris/commit/e7517ec79b45673e7cad353e52023ebd7237cf38.

# Tu, 10 October 2017 | v8.5.1

## MVC

- fix any manual or before middleware's `ctx.ViewData(key, value)` gets overridden by setting `mvc.Controller.Data` or `return mvc.View {Data: ...}`. See the [test case](mvc/method_result_test.go#L226).

# Mo, 09 October 2017 | v8.5.0

## MVC

Great news for our **MVC** Fans or if you're not you may want to use that powerful feature today, because of the smart coding and decisions the performance is quite the same to the pure handlers, see [_benchmarks](_benchmarks).

A Controller's field that is an interface can now be binded to any type that implements that interface.

Ability to send HTTP responses based on the Controller's method function's output values, see below;

Iris now gives you the ability to render a response based on the **output values** returned from the controller's method functions!

You can return any value of any type from a method function
and it will be sent to the client as expected.

* if `string` then it's the body.
* if `string` is the second output argument then it's the content type.
* if `int` then it's the status code.
* if `error` and not nil then (any type) response will be omitted and error's text with a 400 bad request will be rendered instead.
* if `(int, error)` and error is not nil then the response result will be the error's text with the status code as `int`.
* if  `custom struct` or `interface{}` or `slice` or `map` then it will be rendered as json, unless a `string` content type is following.
* if `mvc.Result` then it executes its `Dispatch` function, so good design patters can be used to split the model's logic where needed.

The example below is not intended to be used in production but it's a good showcase of some of the return types we saw before;

```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/middleware/basicauth""
    ""github.com/kataras/iris/mvc""
)

// Movie is our sample data structure.
type Movie struct {
    Name   string `json:""name""`
    Year   int    `json:""year""`
    Genre  string `json:""genre""`
    Poster string `json:""poster""`
}

// movies contains our imaginary data source.
var movies = []Movie{
    {
        Name:   ""Casablanca"",
        Year:   1942,
        Genre:  ""Romance"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/1.jpg"",
    },
    {
        Name:   ""Gone with the Wind"",
        Year:   1939,
        Genre:  ""Romance"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/2.jpg"",
    },
    {
        Name:   ""Citizen Kane"",
        Year:   1941,
        Genre:  ""Mystery"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/3.jpg"",
    },
    {
        Name:   ""The Wizard of Oz"",
        Year:   1939,
        Genre:  ""Fantasy"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/4.jpg"",
    },
}


var basicAuth = basicauth.New(basicauth.Config{
    Users: map[string]string{
        ""admin"": ""password"",
    },
})


func main() {
    app := iris.New()

    app.Use(basicAuth)

    app.Controller(""/movies"", new(MoviesController))

    app.Run(iris.Addr("":8080""))
}

// MoviesController is our /movies controller.
type MoviesController struct {
    // mvc.C is just a lightweight lightweight alternative
    // to the ""mvc.Controller"" controller type,
    // use it when you don't need mvc.Controller's fields
    // (you don't need those fields when you return values from the method functions).
    mvc.C
}

// Get returns list of the movies
// Demo:
// curl -i http://localhost:8080/movies
func (c *MoviesController) Get() []Movie {
    return movies
}

// GetBy returns a movie
// Demo:
// curl -i http://localhost:8080/movies/1
func (c *MoviesController) GetBy(id int) Movie {
    return movies[id]
}

// PutBy updates a movie
// Demo:
// curl -i -X PUT -F ""genre=Thriller"" -F ""poster=@/Users/kataras/Downloads/out.gif"" http://localhost:8080/movies/1
func (c *MoviesController) PutBy(id int) Movie {
    // get the movie
    m := movies[id]

    // get the request data for poster and genre
    file, info, err := c.Ctx.FormFile(""poster"")
    if err != nil {
        c.Ctx.StatusCode(iris.StatusInternalServerError)
        return Movie{}
    }
    file.Close()            // we don't need the file
    poster := info.Filename // imagine that as the url of the uploaded file...
    genre := c.Ctx.FormValue(""genre"")

    // update the poster
    m.Poster = poster
    m.Genre = genre
    movies[id] = m

    return m
}

// DeleteBy deletes a movie
// Demo:
// curl -i -X DELETE -u admin:password http://localhost:8080/movies/1
func (c *MoviesController) DeleteBy(id int) iris.Map {
    // delete the entry from the movies slice
    deleted := movies[id].Name
    movies = append(movies[:id], movies[id+1:]...)
    // and return the deleted movie's name
    return iris.Map{""deleted"": deleted}
}
```

Another good example with a typical folder structure, that many developers are used to work, is located at the new [README.md](README.md) under the [Quick MVC Tutorial #3](README.md#quick-mvc-tutorial-3) section.

# Fr, 06 October 2017 | v8.4.5

- Badger team added support for transactions [yesterday](https://github.com/dgraph-io/badger/commit/06242925c2f2a5e73dc688e9049004029dd7f9f7), therefore the [badger session database](sessions/sessiondb/badger) is updated via https://github.com/kataras/iris/commit/0b48927562a2202809a7674ebedb738dc3da57e8.
- MVC: Support more than one path parameters with a single `By`, when the `By` keyword is the last word and the func's input arguments are more than one i.e `GetBy(name string, age int)`, note that you can still use the older way of doing this; `GetByBy(string, int)`. It's an enhancement of the https://github.com/kataras/iris/issues/751  feature request.
- MVC: Give controllers the ability to auto-initialize themselves by  `OnActivate` func derives from the new [ActivateListener](mvc/activator/activate_listener.go) interface, this can be used to perform any custom actions when the app registers the supported Controllers. See [mvc/session_controller.go](mvc/session_controller.go) for a good use case.
- errors.Reporter.AddErr returns true if the error is added to the stack, otherwise false.
- @ZaniaDeveloper fixed https://github.com/kataras/iris/issues/778 with PR: https://github.com/kataras/iris/pull/779.
- Add `StatusSeeOther` at [mvc login example](https://github.com/kataras/iris/blob/master/_examples/mvc/login/user/controller.go#L53) for Redirection, reported by @motecshine at https://github.com/kataras/iris/issues/777.
- Fix `DisableVersionChecker` configuration field is not being passed correctly when it was true via `iris.Run(..., iris.WithConfiguration{DisableVersionChecker:true, ...})` call.

# Su, 01 October 2017 | v8.4.4

- Fix https://github.com/kataras/iris/issues/762 reported by @xkylsoft
- Fix https://github.com/kataras/iris/issues/771 reported by @cdren
- Improvements to the memstore's `GetInt`, `GetInt64`, `GetFloat64`, `GetBool` and remove the `golang/net/context`'s interface completion from Context, read the [changes](https://github.com/kataras/iris/commit/caff55748eca4ecb4aa5a770995265b9b3aee544) for more
- Add two examples for folder structuring as requested at https://github.com/kataras/iris/issues/748
	* [Example 1](_examples/mvc/login)
	* [Example 2](_examples/structuring/mvc)
- Add node.js express [benchmarks](_benchmarks) similar to iris and netcore

# We, 27 September 2017 | v8.4.3

- MVC: Support for `ByBy` syntax as requested at https://github.com/kataras/iris/issues/751
- Fix https://github.com/kataras/iris/issues/760
- @itcrow fixed https://github.com/kataras/iris/issues/757 with PR: https://github.com/kataras/iris/pull/758
- @balthild fixed https://github.com/kataras/iris/issues/764 with PR: https://github.com/kataras/iris/pull/765
- Add a new session database(back-end storage) supported by the [badger](github.com/dgraph-io/badger) key-value file-based storage, example [here](https://github.com/kataras/iris/commit/204f8474687bad1178d5108b501c6f0c7d927b9a#diff-26d58a00b7f90165fb32043676ed17a5)

# Fr, 15 September 2017 | v8.4.2

## MVC

Support more than one dynamic method function receivers.

```go
package main

import ""github.com/kataras/iris""

func main() {
    app := iris.New()
    app.Controller(""/user"", new(UserController))
    app.Run(iris.Addr(""localhost:8080""))
}

type UserController struct { iris.Controller }

// Maps to GET /user
// Request example: http://localhost:8080/user
// as usual.
func (c *UserController) Get() {
    c.Text = ""hello from /user""
}

// Maps to GET /user/{paramfirst:long}
// Request example: http://localhost:8080/user/42
// as usual.
func (c *UserController) GetBy(userID int64) {
    c.Ctx.Writef(""hello user with id: %d"", userID)
}

// NEW:
// Maps to GET /user/{paramfirst:long}/business/{paramsecond:long}
// Request example: http://localhost:8080/user/42/business/93
func (c *UserController) GetByBusinessBy(userID int64, businessID int64) {
    c.Ctx.Writef(""fetch a business id: %d that user with id: %d owns, may make your db query faster"",
    businessID, userID)
}
```

# Th, 07 September 2017 | v8.4.1

## Routing

Add a macro type for booleans: `app.Get(""/mypath/{paramName:boolean}"", myHandler)`.

```sh
+------------------------+
| {param:boolean}        |
+------------------------+
bool type
only ""1"" or ""t"" or ""T"" or ""TRUE"" or ""true"" or ""True""
or ""0"" or ""f"" or ""F"" or ""FALSE"" or ""false"" or ""False""
```

Add `context.Params().GetBool(paramName string) (bool, error)` respectfully.

```go
app := iris.New()
app.Get(""/mypath/{has:boolean}"", func(ctx iris.Context) { // <--
    // boolean first return value
    // error as second return value
    //
    // error will be always nil here because
    // we use the {has:boolean} so router
    // makes sure that the parameter is a boolean
    // otherwise it will return a 404 not found http error code
    // skipping the call of this handler.
    has, _ := ctx.Params().GetBool(""has"") // <--
    if has {
        ctx.HTML(""<strong>it's true</strong>"")
    }else {
        ctx.HTML(""<strong>it's false</string>"")
    }
})
// [...]
```

## MVC

Support for boolean method receivers, i.e `GetBy(bool), PostBy(bool)...`.


```go
app := iris.New()

app.Controller(""/equality"", new(Controller))
```

```go
type Controller struct {
    iris.Controller
}

// handles the ""/equality"" path.
func (c *Controller) Get() {

}

// registers and handles the path: ""/equality/{param:boolean}"".
func (c *Controller) GetBy(is bool) { // <--
    // [...]
}
```

> Supported types for method functions receivers are: int, int64, bool and string.

# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application.

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse**

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

https://github.com/kataras/iris/tree/master/_examples/#mvc

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

UPDATE:

> [I am](https://github.com/hiveminded) voluntarily quiting this responsibility because I've been re-positioned as the new Lead Product Manager of the company I'm working for many years, which I accepted with honor. That's a very time consuming position I'm responsible to accomplish and deliver, therefore, I transfer all my rights back to @kataras and I resign from any copyrights over this project. My contribution clearly didn't make the difference but I owe a big ""thank you"" to Gerasimos for the chance he gave me and I hope the bests for him and iris. Thank you all.

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.
",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/8265240/assets,https://api.github.com/repos/kataras/iris/releases/8265240,master,https://api.github.com/repos/kataras/iris/tarball/v8.5.4,https://github.com/kataras/iris/releases/tag/v8.5.4,https://api.github.com/repos/kataras/iris/zipball/v8.5.4,v8.5.4,False,False
8088438,2017-10-12T00:51:06Z,2017-10-12T00:53:16Z,v8.5.2,"### Looking for free support?

    http://support.iris-go.com
    https://chat.iris-go.com

Iris uses the [vendor directory](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo) feature, so you get truly reproducible builds, as this method guards against upstream renames and deletes.

# Th, 12 October 2017 | v8.5.2

This version is part of the [releases](https://github.com/kataras/iris/releases).

## MVC

Add `bool` as a supported return value, if false then skips everything else and fires 404 not found.

New example which covers the Service and Repository layers side-by-side with the MVC Architectural pattern, clean and simple: [_examples/mvc/overview](_examples/mvc/overview).

## Websocket

Fix(?) https://github.com/kataras/iris/issues/782 by @jerson with PR:  https://github.com/kataras/iris/pull/783.

## Minor

Add some minor comments for the view/django's origin type getters-- as pushed at PR: [#765](https://github.com/kataras/iris/pull/765).

[sessions/sessiondb/badger](sessions/sessiondb/badger) vendored with: https://github.com/kataras/iris/commit/e7517ec79b45673e7cad353e52023ebd7237cf38.

# Tu, 10 October 2017 | v8.5.1

## MVC

- fix any manual or before middleware's `ctx.ViewData(key, value)` gets overridden by setting `mvc.Controller.Data` or `return mvc.View {Data: ...}`. See the [test case](mvc/method_result_test.go#L226).

# Mo, 09 October 2017 | v8.5.0

## MVC

Great news for our **MVC** Fans or if you're not you may want to use that powerful feature today, because of the smart coding and decisions the performance is quite the same to the pure handlers, see [_benchmarks](_benchmarks).

A Controller's field that is an interface can now be binded to any type that implements that interface.

Ability to send HTTP responses based on the Controller's method function's output values, see below;

Iris now gives you the ability to render a response based on the **output values** returned from the controller's method functions!

You can return any value of any type from a method function
and it will be sent to the client as expected.

* if `string` then it's the body.
* if `string` is the second output argument then it's the content type.
* if `int` then it's the status code.
* if `error` and not nil then (any type) response will be omitted and error's text with a 400 bad request will be rendered instead.
* if `(int, error)` and error is not nil then the response result will be the error's text with the status code as `int`.
* if  `custom struct` or `interface{}` or `slice` or `map` then it will be rendered as json, unless a `string` content type is following.
* if `mvc.Result` then it executes its `Dispatch` function, so good design patters can be used to split the model's logic where needed.

The example below is not intended to be used in production but it's a good showcase of some of the return types we saw before;

```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/middleware/basicauth""
    ""github.com/kataras/iris/mvc""
)

// Movie is our sample data structure.
type Movie struct {
    Name   string `json:""name""`
    Year   int    `json:""year""`
    Genre  string `json:""genre""`
    Poster string `json:""poster""`
}

// movies contains our imaginary data source.
var movies = []Movie{
    {
        Name:   ""Casablanca"",
        Year:   1942,
        Genre:  ""Romance"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/1.jpg"",
    },
    {
        Name:   ""Gone with the Wind"",
        Year:   1939,
        Genre:  ""Romance"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/2.jpg"",
    },
    {
        Name:   ""Citizen Kane"",
        Year:   1941,
        Genre:  ""Mystery"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/3.jpg"",
    },
    {
        Name:   ""The Wizard of Oz"",
        Year:   1939,
        Genre:  ""Fantasy"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/4.jpg"",
    },
}


var basicAuth = basicauth.New(basicauth.Config{
    Users: map[string]string{
        ""admin"": ""password"",
    },
})


func main() {
    app := iris.New()

    app.Use(basicAuth)

    app.Controller(""/movies"", new(MoviesController))

    app.Run(iris.Addr("":8080""))
}

// MoviesController is our /movies controller.
type MoviesController struct {
    // mvc.C is just a lightweight lightweight alternative
    // to the ""mvc.Controller"" controller type,
    // use it when you don't need mvc.Controller's fields
    // (you don't need those fields when you return values from the method functions).
    mvc.C
}

// Get returns list of the movies
// Demo:
// curl -i http://localhost:8080/movies
func (c *MoviesController) Get() []Movie {
    return movies
}

// GetBy returns a movie
// Demo:
// curl -i http://localhost:8080/movies/1
func (c *MoviesController) GetBy(id int) Movie {
    return movies[id]
}

// PutBy updates a movie
// Demo:
// curl -i -X PUT -F ""genre=Thriller"" -F ""poster=@/Users/kataras/Downloads/out.gif"" http://localhost:8080/movies/1
func (c *MoviesController) PutBy(id int) Movie {
    // get the movie
    m := movies[id]

    // get the request data for poster and genre
    file, info, err := c.Ctx.FormFile(""poster"")
    if err != nil {
        c.Ctx.StatusCode(iris.StatusInternalServerError)
        return Movie{}
    }
    file.Close()            // we don't need the file
    poster := info.Filename // imagine that as the url of the uploaded file...
    genre := c.Ctx.FormValue(""genre"")

    // update the poster
    m.Poster = poster
    m.Genre = genre
    movies[id] = m

    return m
}

// DeleteBy deletes a movie
// Demo:
// curl -i -X DELETE -u admin:password http://localhost:8080/movies/1
func (c *MoviesController) DeleteBy(id int) iris.Map {
    // delete the entry from the movies slice
    deleted := movies[id].Name
    movies = append(movies[:id], movies[id+1:]...)
    // and return the deleted movie's name
    return iris.Map{""deleted"": deleted}
}
```

Another good example with a typical folder structure, that many developers are used to work, is located at the new [README.md](README.md) under the [Quick MVC Tutorial #3](README.md#quick-mvc-tutorial-3) section.

# Fr, 06 October 2017 | v8.4.5

- Badger team added support for transactions [yesterday](https://github.com/dgraph-io/badger/commit/06242925c2f2a5e73dc688e9049004029dd7f9f7), therefore the [badger session database](sessions/sessiondb/badger) is updated via https://github.com/kataras/iris/commit/0b48927562a2202809a7674ebedb738dc3da57e8.
- MVC: Support more than one path parameters with a single `By`, when the `By` keyword is the last word and the func's input arguments are more than one i.e `GetBy(name string, age int)`, note that you can still use the older way of doing this; `GetByBy(string, int)`. It's an enhancement of the https://github.com/kataras/iris/issues/751  feature request.
- MVC: Give controllers the ability to auto-initialize themselves by  `OnActivate` func derives from the new [ActivateListener](mvc/activator/activate_listener.go) interface, this can be used to perform any custom actions when the app registers the supported Controllers. See [mvc/session_controller.go](mvc/session_controller.go) for a good use case.
- errors.Reporter.AddErr returns true if the error is added to the stack, otherwise false.
- @ZaniaDeveloper fixed https://github.com/kataras/iris/issues/778 with PR: https://github.com/kataras/iris/pull/779.
- Add `StatusSeeOther` at [mvc login example](https://github.com/kataras/iris/blob/master/_examples/mvc/login/user/controller.go#L53) for Redirection, reported by @motecshine at https://github.com/kataras/iris/issues/777.
- Fix `DisableVersionChecker` configuration field is not being passed correctly when it was true via `iris.Run(..., iris.WithConfiguration{DisableVersionChecker:true, ...})` call.

# Su, 01 October 2017 | v8.4.4

- Fix https://github.com/kataras/iris/issues/762 reported by @xkylsoft
- Fix https://github.com/kataras/iris/issues/771 reported by @cdren
- Improvements to the memstore's `GetInt`, `GetInt64`, `GetFloat64`, `GetBool` and remove the `golang/net/context`'s interface completion from Context, read the [changes](https://github.com/kataras/iris/commit/caff55748eca4ecb4aa5a770995265b9b3aee544) for more
- Add two examples for folder structuring as requested at https://github.com/kataras/iris/issues/748
	* [Example 1](_examples/mvc/login)
	* [Example 2](_examples/structuring/mvc)
- Add node.js express [benchmarks](_benchmarks) similar to iris and netcore

# We, 27 September 2017 | v8.4.3

- MVC: Support for `ByBy` syntax as requested at https://github.com/kataras/iris/issues/751
- Fix https://github.com/kataras/iris/issues/760
- @itcrow fixed https://github.com/kataras/iris/issues/757 with PR: https://github.com/kataras/iris/pull/758
- @balthild fixed https://github.com/kataras/iris/issues/764 with PR: https://github.com/kataras/iris/pull/765
- Add a new session database(back-end storage) supported by the [badger](github.com/dgraph-io/badger) key-value file-based storage, example [here](https://github.com/kataras/iris/commit/204f8474687bad1178d5108b501c6f0c7d927b9a#diff-26d58a00b7f90165fb32043676ed17a5)

# Fr, 15 September 2017 | v8.4.2

## MVC

Support more than one dynamic method function receivers.

```go
package main

import ""github.com/kataras/iris""

func main() {
    app := iris.New()
    app.Controller(""/user"", new(UserController))
    app.Run(iris.Addr(""localhost:8080""))
}

type UserController struct { iris.Controller }

// Maps to GET /user
// Request example: http://localhost:8080/user
// as usual.
func (c *UserController) Get() {
    c.Text = ""hello from /user""
}

// Maps to GET /user/{paramfirst:long}
// Request example: http://localhost:8080/user/42
// as usual.
func (c *UserController) GetBy(userID int64) {
    c.Ctx.Writef(""hello user with id: %d"", userID)
}

// NEW:
// Maps to GET /user/{paramfirst:long}/business/{paramsecond:long}
// Request example: http://localhost:8080/user/42/business/93
func (c *UserController) GetByBusinessBy(userID int64, businessID int64) {
    c.Ctx.Writef(""fetch a business id: %d that user with id: %d owns, may make your db query faster"",
    businessID, userID)
}
```

# Th, 07 September 2017 | v8.4.1

## Routing

Add a macro type for booleans: `app.Get(""/mypath/{paramName:boolean}"", myHandler)`.

```sh
+------------------------+
| {param:boolean}        |
+------------------------+
bool type
only ""1"" or ""t"" or ""T"" or ""TRUE"" or ""true"" or ""True""
or ""0"" or ""f"" or ""F"" or ""FALSE"" or ""false"" or ""False""
```

Add `context.Params().GetBool(paramName string) (bool, error)` respectfully.

```go
app := iris.New()
app.Get(""/mypath/{has:boolean}"", func(ctx iris.Context) { // <--
    // boolean first return value
    // error as second return value
    //
    // error will be always nil here because
    // we use the {has:boolean} so router
    // makes sure that the parameter is a boolean
    // otherwise it will return a 404 not found http error code
    // skipping the call of this handler.
    has, _ := ctx.Params().GetBool(""has"") // <--
    if has {
        ctx.HTML(""<strong>it's true</strong>"")
    }else {
        ctx.HTML(""<strong>it's false</string>"")
    }
})
// [...]
```

## MVC

Support for boolean method receivers, i.e `GetBy(bool), PostBy(bool)...`.


```go
app := iris.New()

app.Controller(""/equality"", new(Controller))
```

```go
type Controller struct {
    iris.Controller
}

// handles the ""/equality"" path.
func (c *Controller) Get() {

}

// registers and handles the path: ""/equality/{param:boolean}"".
func (c *Controller) GetBy(is bool) { // <--
    // [...]
}
```

> Supported types for method functions receivers are: int, int64, bool and string.

# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/8088438/assets,https://api.github.com/repos/kataras/iris/releases/8088438,master,https://api.github.com/repos/kataras/iris/tarball/v8.5.2,https://github.com/kataras/iris/releases/tag/v8.5.2,https://api.github.com/repos/kataras/iris/zipball/v8.5.2,v8.5.2,False,False
8046560,2017-10-09T12:26:46Z,2017-10-09T12:29:50Z,v8.5.0,"# Su, 09 October 2017 | v8.5.0

## MVC

Great news for our **MVC** Fans or if you're not you may want to use that powerful feature today, because of the smart coding and decisions the performance is quite the same to the pure handlers, see [_benchmarks](_benchmarks).

Iris now gives you the ability to render a response based on the **output values** returned method functions!

You can return any value of any type from a method function
and it will be sent to the client as expected.

* if `string` then it's the body.
* if `string` is the second output argument then it's the content type.
* if `int` then it's the status code.
* if `error` and not nil then (any type) response will be omitted and error's text with a 400 bad request will be rendered instead.
* if `(int, error)` and error is not nil then the response result will be the error's text with the status code as `int`.
* if  `custom struct` or `interface{}` or `slice` or `map` then it will be rendered as json, unless a `string` content type is following.
* if `mvc.Result` then it executes its `Dispatch` function, so good design patters can be used to split the model's logic where needed.

The example below is not intended to be used in production but it's a good showcase of some of the return types we saw before;

```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/middleware/basicauth""
    ""github.com/kataras/iris/mvc""
)

// Movie is our sample data structure.
type Movie struct {
    Name   string `json:""name""`
    Year   int    `json:""year""`
    Genre  string `json:""genre""`
    Poster string `json:""poster""`
}

// movies contains our imaginary data source.
var movies = []Movie{
    {
        Name:   ""Casablanca"",
        Year:   1942,
        Genre:  ""Romance"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/1.jpg"",
    },
    {
        Name:   ""Gone with the Wind"",
        Year:   1939,
        Genre:  ""Romance"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/2.jpg"",
    },
    {
        Name:   ""Citizen Kane"",
        Year:   1941,
        Genre:  ""Mystery"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/3.jpg"",
    },
    {
        Name:   ""The Wizard of Oz"",
        Year:   1939,
        Genre:  ""Fantasy"",
        Poster: ""https://iris-go.com/images/examples/mvc-movies/4.jpg"",
    },
}


var basicAuth = basicauth.New(basicauth.Config{
    Users: map[string]string{
        ""admin"": ""password"",
    },
})


func main() {
    app := iris.New()

    app.Use(basicAuth)

    app.Controller(""/movies"", new(MoviesController))

    app.Run(iris.Addr("":8080""))
}

// MoviesController is our /movies controller.
type MoviesController struct {
    // mvc.C is just a lightweight lightweight alternative
    // to the ""mvc.Controller"" controller type,
    // use it when you don't need mvc.Controller's fields
    // (you don't need those fields when you return values from the method functions).
    mvc.C
}

// Get returns list of the movies
// Demo:
// curl -i http://localhost:8080/movies
func (c *MoviesController) Get() []Movie {
    return movies
}

// GetBy returns a movie
// Demo:
// curl -i http://localhost:8080/movies/1
func (c *MoviesController) GetBy(id int) Movie {
    return movies[id]
}

// PutBy updates a movie
// Demo:
// curl -i -X PUT -F ""genre=Thriller"" -F ""poster=@/Users/kataras/Downloads/out.gif"" http://localhost:8080/movies/1
func (c *MoviesController) PutBy(id int) Movie {
    // get the movie
    m := movies[id]

    // get the request data for poster and genre
    file, info, err := c.Ctx.FormFile(""poster"")
    if err != nil {
        c.Ctx.StatusCode(iris.StatusInternalServerError)
        return Movie{}
    }
    file.Close()            // we don't need the file
    poster := info.Filename // imagine that as the url of the uploaded file...
    genre := c.Ctx.FormValue(""genre"")

    // update the poster
    m.Poster = poster
    m.Genre = genre
    movies[id] = m

    return m
}

// DeleteBy deletes a movie
// Demo:
// curl -i -X DELETE -u admin:password http://localhost:8080/movies/1
func (c *MoviesController) DeleteBy(id int) iris.Map {
    // delete the entry from the movies slice
    deleted := movies[id].Name
    movies = append(movies[:id], movies[id+1:]...)
    // and return the deleted movie's name
    return iris.Map{""deleted"": deleted}
}
```

Another good example with a typical folder structure, that many developers are used to work, is located at the new [README.md](README.md) under the [Quick MVC Tutorial #3](README.md#quick-mvc-tutorial--3) section.

### The complete example source code can be found at [_examples/mvc/using-method-result](_examples/mvc/using-method-result) folder.

----

Upgrade with `go get -u -v github.com/kataras/iris` or let the auto-updater to do its job.

# Fr, 06 October 2017 | v8.4.5

- Badger team added support for transactions [yesterday](https://github.com/dgraph-io/badger/commit/06242925c2f2a5e73dc688e9049004029dd7f9f7), therefore the [badger session database](sessions/sessiondb/badger) is updated via https://github.com/kataras/iris/commit/0b48927562a2202809a7674ebedb738dc3da57e8.
- MVC: Support more than one path parameters with a single `By`, when the `By` keyword is the last word and the func's input arguments are more than one i.e `GetBy(name string, age int)`, note that you can still use the older way of doing this; `GetByBy(string, int)`. It's an enhancement of the https://github.com/kataras/iris/issues/751  feature request.
- MVC: Give controllers the ability to auto-initialize themselves by  `OnActivate` func derives from the new [ActivateListener](mvc/activator/activate_listener.go) interface, this can be used to perform any custom actions when the app registers the supported Controllers. See [mvc/session_controller.go](mvc/session_controller.go) for a good use case.
- errors.Reporter.AddErr returns true if the error is added to the stack, otherwise false.
- @ZaniaDeveloper fixed https://github.com/kataras/iris/issues/778 with PR: https://github.com/kataras/iris/pull/779.
- Add `StatusSeeOther` at [mvc login example](https://github.com/kataras/iris/blob/master/_examples/mvc/login/user/controller.go#L53) for Redirection, reported by @motecshine at https://github.com/kataras/iris/issues/777.
- Fix `DisableVersionChecker` configuration field is not being passed correctly when it was true via `iris.Run(..., iris.WithConfiguration{DisableVersionChecker:true, ...})` call.

# Su, 01 October 2017 | v8.4.4

- Fix https://github.com/kataras/iris/issues/762 reported by @xkylsoft
- Fix https://github.com/kataras/iris/issues/771 reported by @cdren
- Improvements to the memstore's `GetInt`, `GetInt64`, `GetFloat64`, `GetBool` and remove the `golang/net/context`'s interface completion from Context, read the [changes](https://github.com/kataras/iris/commit/caff55748eca4ecb4aa5a770995265b9b3aee544) for more
- Add two examples for folder structuring as requested at https://github.com/kataras/iris/issues/748
	* [Example 1](_examples/mvc/login)
	* [Example 2](_examples/structuring/mvc)
- Add node.js express [benchmarks](_benchmarks) similar to iris and netcore

# We, 27 September 2017 | v8.4.3

- MVC: Support for `ByBy` syntax as requested at https://github.com/kataras/iris/issues/751
- Fix https://github.com/kataras/iris/issues/760
- @itcrow fixed https://github.com/kataras/iris/issues/757 with PR: https://github.com/kataras/iris/pull/758
- @balthild fixed https://github.com/kataras/iris/issues/764 with PR: https://github.com/kataras/iris/pull/765
- Add a new session database(back-end storage) supported by the [badger](github.com/dgraph-io/badger) key-value file-based storage, example [here](https://github.com/kataras/iris/commit/204f8474687bad1178d5108b501c6f0c7d927b9a#diff-26d58a00b7f90165fb32043676ed17a5)

# Fr, 15 September 2017 | v8.4.2

## MVC

Support more than one dynamic method function receivers.

```go
package main

import ""github.com/kataras/iris""

func main() {
    app := iris.New()
    app.Controller(""/user"", new(UserController))
    app.Run(iris.Addr(""localhost:8080""))
}

type UserController struct { iris.Controller }

// Maps to GET /user
// Request example: http://localhost:8080/user
// as usual.
func (c *UserController) Get() {
    c.Text = ""hello from /user""
}

// Maps to GET /user/{paramfirst:long}
// Request example: http://localhost:8080/user/42
// as usual.
func (c *UserController) GetBy(userID int64) {
    c.Ctx.Writef(""hello user with id: %d"", userID)
}

// NEW:
// Maps to GET /user/{paramfirst:long}/business/{paramsecond:long}
// Request example: http://localhost:8080/user/42/business/93
func (c *UserController) GetByBusinessBy(userID int64, businessID int64) {
    c.Ctx.Writef(""fetch a business id: %d that user with id: %d owns, may make your db query faster"",
    businessID, userID)
}
```

# Th, 07 September 2017 | v8.4.1

## Routing

Add a macro type for booleans: `app.Get(""/mypath/{paramName:boolean}"", myHandler)`.

```sh
+------------------------+
| {param:boolean}        |
+------------------------+
bool type
only ""1"" or ""t"" or ""T"" or ""TRUE"" or ""true"" or ""True""
or ""0"" or ""f"" or ""F"" or ""FALSE"" or ""false"" or ""False""
```

Add `context.Params().GetBool(paramName string) (bool, error)` respectfully.

```go
app := iris.New()
app.Get(""/mypath/{has:boolean}"", func(ctx iris.Context) { // <--
    // boolean first return value
    // error as second return value
    //
    // error will be always nil here because
    // we use the {has:boolean} so router
    // makes sure that the parameter is a boolean
    // otherwise it will return a 404 not found http error code
    // skipping the call of this handler.
    has, _ := ctx.Params().GetBool(""has"") // <--
    if has {
        ctx.HTML(""<strong>it's true</strong>"")
    }else {
        ctx.HTML(""<strong>it's false</string>"")
    }
})
// [...]
```

## MVC

Support for boolean method receivers, i.e `GetBy(bool), PostBy(bool)...`.


```go
app := iris.New()

app.Controller(""/equality"", new(Controller))
```

```go
type Controller struct {
    iris.Controller
}

// handles the ""/equality"" path.
func (c *Controller) Get() {

}

// registers and handles the path: ""/equality/{param:boolean}"".
func (c *Controller) GetBy(is bool) { // <--
    // [...]
}
```

> Supported types for method functions receivers are: int, int64, bool and string.

# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/8046560/assets,https://api.github.com/repos/kataras/iris/releases/8046560,master,https://api.github.com/repos/kataras/iris/tarball/v8.5.0,https://github.com/kataras/iris/releases/tag/v8.5.0,https://api.github.com/repos/kataras/iris/zipball/v8.5.0,v8.5.0,False,False
8025349,2017-10-06T05:44:10Z,2017-10-06T14:09:12Z,v8.4.5,"# FAQ

### Looking for free support?

    http://support.iris-go.com
    https://kataras.rocket.chat/channel/iris


# Fr, 06 October 2017 | v8.4.5

- Badger team added support for transactions [yesterday](https://github.com/dgraph-io/badger/commit/06242925c2f2a5e73dc688e9049004029dd7f9f7), therefore the [badger session database](sessions/sessiondb/badger) is updated via https://github.com/kataras/iris/commit/0b48927562a2202809a7674ebedb738dc3da57e8.
- MVC: Support more than one path parameters with a single `By`, when the `By` keyword is the last word and the func's input arguments are more than one i.e `GetBy(name string, age int)`, note that you can still use the older way of doing this; `GetByBy(string, int)`. It's an enhancement of the https://github.com/kataras/iris/issues/751  feature request.
- MVC: Give controllers the ability to auto-initialize themselves by  `OnActivate` func derives from the new [ActivateListener](mvc/activator/activate_listener.go) interface, this can be used to perform any custom actions when the app registers the supported Controllers. See [mvc/session_controller.go](mvc/session_controller.go) for a good use case.
- errors.Reporter.AddErr returns true if the error is added to the stack, otherwise false.
- @ZaniaDeveloper fixed https://github.com/kataras/iris/issues/778 with PR: https://github.com/kataras/iris/pull/779.
- Add `StatusSeeOther` at [mvc login example](https://github.com/kataras/iris/blob/master/_examples/mvc/login/user/controller.go#L53) for Redirection, reported by @motecshine at https://github.com/kataras/iris/issues/777.
- Fix `DisableVersionChecker` configuration field is not being passed correctly when it was true via `iris.Run(..., iris.WithConfiguration{DisableVersionChecker:true, ...})` call.

# Su, 01 October 2017 | v8.4.4

- Fix https://github.com/kataras/iris/issues/762 reported by @xkylsoft
- Fix https://github.com/kataras/iris/issues/771 reported by @cdren
- Improvements to the memstore's `GetInt`, `GetInt64`, `GetFloat64`, `GetBool` and remove the `golang/net/context`'s interface completion from Context, read the [changes](https://github.com/kataras/iris/commit/caff55748eca4ecb4aa5a770995265b9b3aee544) for more
- Add two examples for folder structuring as requested at https://github.com/kataras/iris/issues/748
	* [Example 1](_examples/mvc/login)
	* [Example 2](_examples/structuring/mvc)
- Add node.js express [benchmarks](_benchmarks) similar to iris and netcore

# We, 27 September 2017 | v8.4.3

- MVC: Support for `ByBy` syntax as requested at https://github.com/kataras/iris/issues/751
- Fix https://github.com/kataras/iris/issues/760
- @itcrow fixed https://github.com/kataras/iris/issues/757 with PR: https://github.com/kataras/iris/pull/758
- @balthild fixed https://github.com/kataras/iris/issues/764 with PR: https://github.com/kataras/iris/pull/765
- Add a new session database(back-end storage) supported by the [badger](github.com/dgraph-io/badger) key-value file-based storage, example [here](https://github.com/kataras/iris/commit/204f8474687bad1178d5108b501c6f0c7d927b9a#diff-26d58a00b7f90165fb32043676ed17a5)

# Fr, 15 September 2017 | v8.4.2

## MVC

Support more than one dynamic method function receivers.

```go
package main

import ""github.com/kataras/iris""

func main() {
    app := iris.New()
    app.Controller(""/user"", new(UserController))
    app.Run(iris.Addr(""localhost:8080""))
}

type UserController struct { iris.Controller }

// Maps to GET /user
// Request example: http://localhost:8080/user
// as usual.
func (c *UserController) Get() {
    c.Text = ""hello from /user""
}

// Maps to GET /user/{paramfirst:long}
// Request example: http://localhost:8080/user/42
// as usual.
func (c *UserController) GetBy(userID int64) {
    c.Ctx.Writef(""hello user with id: %d"", userID)
}

// NEW:
// Maps to GET /user/{paramfirst:long}/business/{paramsecond:long}
// Request example: http://localhost:8080/user/42/business/93
func (c *UserController) GetByBusinessBy(userID int64, businessID int64) {
    c.Ctx.Writef(""fetch a business id: %d that user with id: %d owns, may make your db query faster"",
    businessID, userID)
}
```

# Th, 07 September 2017 | v8.4.1

## Routing

Add a macro type for booleans: `app.Get(""/mypath/{paramName:boolean}"", myHandler)`.

```sh
+------------------------+
| {param:boolean}        |
+------------------------+
bool type
only ""1"" or ""t"" or ""T"" or ""TRUE"" or ""true"" or ""True""
or ""0"" or ""f"" or ""F"" or ""FALSE"" or ""false"" or ""False""
```

Add `context.Params().GetBool(paramName string) (bool, error)` respectfully.

```go
app := iris.New()
app.Get(""/mypath/{has:boolean}"", func(ctx iris.Context) { // <--
    // boolean first return value
    // error as second return value
    //
    // error will be always nil here because
    // we use the {has:boolean} so router
    // makes sure that the parameter is a boolean
    // otherwise it will return a 404 not found http error code
    // skipping the call of this handler.
    has, _ := ctx.Params().GetBool(""has"") // <--
    if has {
        ctx.HTML(""<strong>it's true</strong>"")
    }else {
        ctx.HTML(""<strong>it's false</string>"")
    }
})
// [...]
```

## MVC

Support for boolean method receivers, i.e `GetBy(bool), PostBy(bool)...`.


```go
app := iris.New()

app.Controller(""/equality"", new(Controller))
```

```go
type Controller struct {
    iris.Controller
}

// handles the ""/equality"" path.
func (c *Controller) Get() {

}

// registers and handles the path: ""/equality/{param:boolean}"".
func (c *Controller) GetBy(is bool) { // <--
    // [...]
}
```

> Supported types for method functions receivers are: int, int64, bool and string.

# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/8025349/assets,https://api.github.com/repos/kataras/iris/releases/8025349,master,https://api.github.com/repos/kataras/iris/tarball/v8.4.5,https://github.com/kataras/iris/releases/tag/v8.4.5,https://api.github.com/repos/kataras/iris/zipball/v8.4.5,v8.4.5,False,False
7954135,2017-10-01T03:55:01Z,2017-10-01T03:56:17Z,v8.4.4,"# FAQ

https://github.com/kataras/iris/blob/master/faq.md

# History

> Iris uses the [vendor directory](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo) feature, so you get truly reproducible builds, as this method guards against upstream renames and deletes.

# Su, 01 October 2017 | v8.4.4

- Fix https://github.com/kataras/iris/issues/762 reported by @xkylsoft
- Fix https://github.com/kataras/iris/issues/771 reported by @cdren
- Improvements to the memstore's `GetInt`, `GetInt64`, `GetFloat64`, `GetBool` and remove the `golang/net/context`'s interface completion from Context, read the [changes](https://github.com/kataras/iris/commit/caff55748eca4ecb4aa5a770995265b9b3aee544) for more
- Add two examples for folder structuring as requested at https://github.com/kataras/iris/issues/748
	* [Example 1](_examples/mvc/login)
	* [Example 2](_examples/structuring/mvc)
- Add node.js express [benchmarks](_benchmarks) similar to iris and netcore

# We, 27 September 2017 | v8.4.3

- MVC: Support for `ByBy` syntax as requested at https://github.com/kataras/iris/issues/751
- Fix https://github.com/kataras/iris/issues/760
- @itcrow fixed https://github.com/kataras/iris/issues/757 with PR: https://github.com/kataras/iris/pull/758
- @balthild fixed https://github.com/kataras/iris/issues/764 with PR: https://github.com/kataras/iris/pull/765
- Add a new session database(back-end storage) supported by the [badger](github.com/dgraph-io/badger) key-value file-based storage, example [here](https://github.com/kataras/iris/commit/204f8474687bad1178d5108b501c6f0c7d927b9a#diff-26d58a00b7f90165fb32043676ed17a5)

# Fr, 15 September 2017 | v8.4.2

## MVC

Support more than one dynamic method function receivers.

```go
package main

import ""github.com/kataras/iris""

func main() {
    app := iris.New()
    app.Controller(""/user"", new(UserController))
    app.Run(iris.Addr(""localhost:8080""))
}

type UserController struct { iris.Controller }

// Maps to GET /user
// Request example: http://localhost:8080/user
// as usual.
func (c *UserController) Get() {
    c.Text = ""hello from /user""
}

// Maps to GET /user/{paramfirst:long}
// Request example: http://localhost:8080/user/42
// as usual.
func (c *UserController) GetBy(userID int64) {
    c.Ctx.Writef(""hello user with id: %d"", userID)
}

// NEW:
// Maps to GET /user/{paramfirst:long}/business/{paramsecond:long}
// Request example: http://localhost:8080/user/42/business/93
func (c *UserController) GetByBusinessBy(userID int64, businessID int64) {
    c.Ctx.Writef(""fetch a business id: %d that user with id: %d owns, may make your db query faster"",
    businessID, userID)
}
```

# Th, 07 September 2017 | v8.4.1

## Routing

Add a macro type for booleans: `app.Get(""/mypath/{paramName:boolean}"", myHandler)`.

```sh
+------------------------+
| {param:boolean}        |
+------------------------+
bool type
only ""1"" or ""t"" or ""T"" or ""TRUE"" or ""true"" or ""True""
or ""0"" or ""f"" or ""F"" or ""FALSE"" or ""false"" or ""False""
```

Add `context.Params().GetBool(paramName string) (bool, error)` respectfully.

```go
app := iris.New()
app.Get(""/mypath/{has:boolean}"", func(ctx iris.Context) { // <--
    // boolean first return value
    // error as second return value
    //
    // error will be always nil here because
    // we use the {has:boolean} so router
    // makes sure that the parameter is a boolean
    // otherwise it will return a 404 not found http error code
    // skipping the call of this handler.
    has, _ := ctx.Params().GetBool(""has"") // <--
    if has {
        ctx.HTML(""<strong>it's true</strong>"")
    }else {
        ctx.HTML(""<strong>it's false</string>"")
    }
})
// [...]
```

## MVC

Support for boolean method receivers, i.e `GetBy(bool), PostBy(bool)...`.


```go
app := iris.New()

app.Controller(""/equality"", new(Controller))
```

```go
type Controller struct {
    iris.Controller
}

// handles the ""/equality"" path.
func (c *Controller) Get() {

}

// registers and handles the path: ""/equality/{param:boolean}"".
func (c *Controller) GetBy(is bool) { // <--
    // [...]
}
```

> Supported types for method functions receivers are: int, int64, bool and string.

# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/7954135/assets,https://api.github.com/repos/kataras/iris/releases/7954135,master,https://api.github.com/repos/kataras/iris/tarball/v8.4.4,https://github.com/kataras/iris/releases/tag/v8.4.4,https://api.github.com/repos/kataras/iris/zipball/v8.4.4,v8.4.4,False,False
7911094,2017-09-27T14:30:09Z,2017-09-27T14:33:52Z,v8.4.3,"# FAQ

## Learning

More than 50 practical examples, tutorials and articles at:

- https://github.com/kataras/iris/tree/master/_examples
- https://github.com/iris-contrib/examples
- https://iris-go.com/v8/recipe
- https://docs.iris-go.com (in-progress)
- https://godoc.org/github.com/kataras/iris

> [Stay tuned](https://github.com/kataras/iris/stargazers), community prepares even more tutorials.

Want to help and join to the greatest community? Describe your skills and push your own sections at: https://github.com/kataras/build-a-better-web-together/issues/new

### common errors that new gophers may meet

#### type aliases

| build error | reason | solution |
| -----------|--------|--------|
| `undefined iris.Context` | caused of using the **optional type alias** `iris.Context` instead of the `context.Context` when building with Go 1.8 | import the original package `github.com/kataras/iris/context` and declare as `func(context.Context){})` **or** download and install the [latest go version](https://golang.org/dl) _recommended_ |

Type alias is a new feature, introduced at Go version 1.9, so if you want to use Iris' type aliases you have to build using the latest Go version. Nothing really changes for your application if you use type alias or not, Iris' type aliases helps you to omit import statements -- to reduce lines of code, nothing more.

**Details...**

Go version 1.9 introduced the [type alias](https://golang.org/doc/go1.9#language) feature.

Iris uses the `type alias` feature to help you writing less code by omitting some package imports. The examples and documentation are written using Go 1.9 as well.

If you build your Go app with Go 1.9 you can, optionally, use all Iris web framework's features by importing one single package, the `github.com/kataras/iris`.

Available type aliases;

| Go 1.8 | Go 1.8 usage | Go 1.9 usage (optionally) |
| -----------|--------|--------|
| `import ""github.com/kataras/iris/context""` | `func(context.Context) {}`, `context.Handler`, `context.Map` |  `func(iris.Context) {}`, `iris.Handler`,  `iris.Map` |
| `import ""github.com/kataras/iris/mvc""` | `type MyController struct { mvc.Controller }` , `mvc.SessionController` | `type MyController struct { iris.Controller }`, `iris.SessionController` |
| `import ""github.com/kataras/iris/core/router""` | `app.PartyFunc(""/users"", func(p router.Party) {})` |  `app.PartyFunc(""/users"", func(p iris.Party) {})` |
| `import ""github.com/kataras/iris/core/host""` | `app.ConfigureHost(func(s *host.Supervisor) {})` | `app.ConfigureHost(func(s *iris.Supervisor) {})` |

You can find all type aliases and their original package import statements at the [./context.go file](context.go).

> Remember; this doesn't mean that you have to use those type aliases, you can still import the original packages as you did with Go version 1.8, it's up to you.

## Active development mode

Iris may have reached version 8, but we're not stopping there. We have many feature ideas on our board that we're anxious to add and other innovative web development solutions that we're planning to build into Iris.

## Can I found a job if I learn how to use Iris?

Yes, not only because you will learn Golang in the same time, but there are some positions
open for Iris-specific developers the time we speak.

- https://glints.id/opportunities/jobs/5553

## Can Iris be used in production after Dubai purchase?

Yes, now more than ever.

https://github.com/kataras/iris/issues/711

## Do we have a community Chat?

Yes, https://kataras.rocket.chat/channel/iris.

https://github.com/kataras/iris/issues/646

## How this open-source project still active and shine?

By normal people like you, who help us by donating small or larger amounts of money.

Help this project to continue deliver awesome and unique features with the higher code quality as possible by donating any amount.

[![](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=kataras2006%40hotmail%2ecom&lc=GR&item_name=Iris%20web%20framework&item_number=iriswebframeworkdonationid2016&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donateCC_LG%2egif%3aNonHosted)

# History

# We, 27 September 2017 | v8.4.3

- MVC: Support for `ByBy` syntax as requested at https://github.com/kataras/iris/issues/751
- Fix https://github.com/kataras/iris/issues/760
- @itcrow fixed https://github.com/kataras/iris/issues/757 with PR: https://github.com/kataras/iris/pull/758
- @balthild fixed https://github.com/kataras/iris/issues/764 with PR: https://github.com/kataras/iris/pull/765
- Add a new session database(back-end storage) supported by the [badger](github.com/dgraph-io/badger) key-value file-based storage, example [here](https://github.com/kataras/iris/commit/204f8474687bad1178d5108b501c6f0c7d927b9a#diff-26d58a00b7f90165fb32043676ed17a5)

# Fr, 15 September 2017 | v8.4.2

## MVC

Support more than one dynamic method function receivers.

```go
package main

import ""github.com/kataras/iris""

func main() {
    app := iris.New()
    app.Controller(""/user"", new(UserController))
    app.Run(iris.Addr(""localhost:8080""))
}

type UserController struct { iris.Controller }

// Maps to GET /user
// Request example: http://localhost:8080/user
// as usual.
func (c *UserController) Get() {
    c.Text = ""hello from /user""
}

// Maps to GET /user/{paramfirst:long}
// Request example: http://localhost:8080/user/42
// as usual.
func (c *UserController) GetBy(userID int64) {
    c.Ctx.Writef(""hello user with id: %d"", userID)
}

// NEW:
// Maps to GET /user/{paramfirst:long}/business/{paramsecond:long}
// Request example: http://localhost:8080/user/42/business/93
func (c *UserController) GetByBusinessBy(userID int64, businessID int64) {
    c.Ctx.Writef(""fetch a business id: %d that user with id: %d owns, may make your db query faster"",
    businessID, userID)
}
```

# Th, 07 September 2017 | v8.4.1

## Routing

Add a macro type for booleans: `app.Get(""/mypath/{paramName:boolean}"", myHandler)`.

```sh
+------------------------+
| {param:boolean}        |
+------------------------+
bool type
only ""1"" or ""t"" or ""T"" or ""TRUE"" or ""true"" or ""True""
or ""0"" or ""f"" or ""F"" or ""FALSE"" or ""false"" or ""False""
```

Add `context.Params().GetBool(paramName string) (bool, error)` respectfully.

```go
app := iris.New()
app.Get(""/mypath/{has:boolean}"", func(ctx iris.Context) { // <--
    // boolean first return value
    // error as second return value
    //
    // error will be always nil here because
    // we use the {has:boolean} so router
    // makes sure that the parameter is a boolean
    // otherwise it will return a 404 not found http error code
    // skipping the call of this handler.
    has, _ := ctx.Params().GetBool(""has"") // <--
    if has {
        ctx.HTML(""<strong>it's true</strong>"")
    }else {
        ctx.HTML(""<strong>it's false</string>"")
    }
})
// [...]
```

## MVC

Support for boolean method receivers, i.e `GetBy(bool), PostBy(bool)...`.


```go
app := iris.New()

app.Controller(""/equality"", new(Controller))
```

```go
type Controller struct {
    iris.Controller
}

// handles the ""/equality"" path.
func (c *Controller) Get() {

}

// registers and handles the path: ""/equality/{param:boolean}"".
func (c *Controller) GetBy(is bool) { // <--
    // [...]
}
```

> Supported types for method functions receivers are: int, int64, bool and string.

# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/7911094/assets,https://api.github.com/repos/kataras/iris/releases/7911094,master,https://api.github.com/repos/kataras/iris/tarball/v8.4.3,https://github.com/kataras/iris/releases/tag/v8.4.3,https://api.github.com/repos/kataras/iris/zipball/v8.4.3,v8.4.3,False,False
7782863,2017-09-17T11:43:35Z,2017-09-17T11:44:32Z,v8.4.2,"# Fr, 15 September 2017 | v8.4.2

## MVC

Support more than one dynamic method function receivers.

```go
package main

import ""github.com/kataras/iris""

func main() {
    app := iris.New()
    app.Controller(""/user"", new(UserController))
    app.Run(iris.Addr(""localhost:8080""))
}

type UserController struct { iris.Controller }

// Maps to GET /user
// Request example: http://localhost:8080/user
// as usual.
func (c *UserController) Get() {
    c.Text = ""hello from /user""
}

// Maps to GET /user/{paramfirst:long}
// Request example: http://localhost:8080/user/42
// as usual.
func (c *UserController) GetBy(userID int64) {
    c.Ctx.Writef(""hello user with id: %d"", userID)
}

// NEW:
// Maps to GET /user/{paramfirst:long}/business/{paramsecond:long}
// Request example: http://localhost:8080/user/42/business/93
func (c *UserController) GetByBusinessBy(userID int64, businessID int64) {
    c.Ctx.Writef(""fetch a business id: %d that user with id: %d owns, may make your db query faster"",
    businessID, userID)
}
```

# Th, 07 September 2017 | v8.4.1

## Routing

Add a macro type for booleans: `app.Get(""/mypath/{paramName:boolean}"", myHandler)`.

```sh
+------------------------+
| {param:boolean}        |
+------------------------+
bool type
only ""1"" or ""t"" or ""T"" or ""TRUE"" or ""true"" or ""True""
or ""0"" or ""f"" or ""F"" or ""FALSE"" or ""false"" or ""False""
```

Add `context.Params().GetBool(paramName string) (bool, error)` respectfully.

```go
app := iris.New()
app.Get(""/mypath/{has:boolean}"", func(ctx iris.Context) { // <--
    // boolean first return value
    // error as second return value
    //
    // error will be always nil here because
    // we use the {has:boolean} so router
    // makes sure that the parameter is a boolean
    // otherwise it will return a 404 not found http error code
    // skipping the call of this handler.
    has, _ := ctx.Params().GetBool(""has"") // <--
    if has {
        ctx.HTML(""<strong>it's true</strong>"")
    }else {
        ctx.HTML(""<strong>it's false</string>"")
    }
})
// [...]
```

## MVC

Support for boolean method receivers, i.e `GetBy(bool), PostBy(bool)...`.


```go
app := iris.New()

app.Controller(""/equality"", new(Controller))
```

```go
type Controller struct {
    iris.Controller
}

// handles the ""/equality"" path.
func (c *Controller) Get() {

}

// registers and handles the path: ""/equality/{param:boolean}"".
func (c *Controller) GetBy(is bool) { // <--
    // [...]
}
```

> Supported types for method functions receivers are: int, int64, bool and string.

# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/7782863/assets,https://api.github.com/repos/kataras/iris/releases/7782863,master,https://api.github.com/repos/kataras/iris/tarball/v8.4.2,https://github.com/kataras/iris/releases/tag/v8.4.2,https://api.github.com/repos/kataras/iris/zipball/v8.4.2,v8.4.2,False,False
7557938,2017-08-29T11:11:36Z,2017-08-29T14:03:34Z,v8.4.0,"# Su, 27 August 2017 | v8.4.0

## Miscellaneous

- Update `vendor blackfriday` package to its latest version, 2.0.0
- Update [documentation](https://godoc.org/github.com/kataras/iris) for go 1.9
- Update [_examples](_examples) folder for go 1.9
- Update examples inside https://github.com/iris-contrib/middleware for go 1.9
- Update https://github.com/kataras/iris-contrib/examples for go 1.9
- Update https://iris-go.com/v8/recipe for go 1.9

## Router

Add a new macro type for path parameters, `long`, it's the go type `int64`.

```go
app.Get(""/user/{id:long}"", func(ctx context.Context) {
	userID, _ := ctx.Params().GetInt64(""id"")
})
```

## MVC

The ability to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that after a `go get -u github.com/kataras/iris` you will be able to use things like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(*Controller) Get()` - `GET:/user` , as usual.
- `func(*Controller) Post()` - `POST:/user`, as usual.
- `func(*Controller) GetLogin()` - `GET:/user/login`
- `func(*Controller) PostLogin()` - `POST:/user/login`
- `func(*Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(*Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(*Controller) GetBy(id int64)` - `GET:/user/{param:long}`
- `func(*Controller) PostBy(id int64)` - `POST:/user/{param:long}`

If `app.Controller(""/profile"", new(profile.Controller))`

- `func(*Controller) GetBy(username string)` - `GET:/profile/{param:string}`

If `app.Controller(""/assets"", new(file.Controller))`

- `func(*Controller) GetByWildard(path string)` - `GET:/assets/{param:path}`


**Example** can be found at: [_examples/mvc/login/user/controller.go](_examples/mvc/login/user/controller.go).

## Pretty [awesome](https://github.com/kataras/iris/stargazers), right?

# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route().Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

**Updated: 24 August 2017**

This evening, on the next version 8.3.5:

Able to pre-calculate, register and map different (relative) paths inside a single controller
with zero performance cost.

Meaning that in the future you will be able to use something like these:

If `app.Controller(""/user"", new(user.Controller))`

- `func(c *Controller) Get()` - `GET:/user` , as usual.
- `func(c *Controller) Post()` - `POST:/user`, as usual.
- `func(c *Controller) GetLogin()` - `GET:/user/login`
- `func(c *Controller) PostLogin()` - `POST:/user/login`
- `func(c *Controller) GetProfileFollowers()` - `GET:/user/profile/followers`
- `func(c *Controller) PostProfileFollowers()` - `POST:/user/profile/followers`
- `func(c *Controller) GetBy()` - `GET:/user/{param}`
- `func(c *Controller) GetByName(name string)` - `GET:/user/{name}`
- `func(c *Controller) PostByName(name string)` - `POST:/user/{name}`
- `func(c *Controller) GetByID(id int64 || int)` - `GET:/user/{id:int}`
- `func(c *Controller) PostByID(id int64 || int)` - `POST:/user/{id:int}`

Watch and stay tuned my friends.

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    https://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the https://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (**NEW**: this import path is optional, use `iris.Context` if you've installed Go 1.9)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/7557938/assets,https://api.github.com/repos/kataras/iris/releases/7557938,master,https://api.github.com/repos/kataras/iris/tarball/v8.4.0,https://github.com/kataras/iris/releases/tag/v8.4.0,https://api.github.com/repos/kataras/iris/zipball/v8.4.0,v8.4.0,False,False
7494450,2017-08-23T14:01:51Z,2017-08-23T14:05:06Z,v8.3.4,"# We, 23 August 2017 | v8.3.4

Give read access to the current request context's route, a feature that many of you asked a lot.

```go
func(ctx context.Context) {
	_ = ctx.GetCurrentRoute().Name()
	//					.Method() returns string, same as ctx.Method().
	//					.Subdomain() returns string, the registered subdomain.
	//					.Path() returns string, the registered path.
	//					.IsOnline() returns boolean.
}
```  

```go
type MyController struct {
	mvc.Controller
}

func (c *MyController) Get(){
	_ = c.Route.Name() // same as `c.Ctx.GetCurrentRoute().Name()`.
	// [...]
}
```

# We, 23 August 2017 | v8.3.3

Better debug messages when using MVC.

Add support for recursively binding and **custom controllers embedded to other custom controller**, that's the new feature. That simply means that Iris users are able to use ""shared"" controllers everywhere; when binding, using models, get/set persistence data, adding middleware, intercept request flow.

This will help web authors to split the logic at different controllers. Those controllers can be also used as ""standalone"" to serve a page somewhere else in the application as well.

My personal advice to you is to always organize and split your code nicely and wisely in order to avoid using such as an advanced MVC feature, at least any time soon.

I'm aware that this is not always an easy task to do, therefore is here if you ever need it :)

A ridiculous simple example of this feature can be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L424) file.


# Tu, 22 August 2017 | v8.3.2

### MVC

When one or more values of handler type (`func(ctx context.Context)`) are passed
right to the controller initialization then they will be recognised and act as middleware(s)
that ran even before the controller activation, there is no reason to load
the whole controller if the main handler or its `BeginRequest` are not ""allowed"" to be executed.

Example Code

```go
func checkLogin(ctx context.Context) {
	if !myCustomAuthMethodPassed {
		// [set a status or redirect, you know what to do]
		ctx.StatusCode(iris.StatusForbidden)
		return
	}

	// [continue to the next handler, at this example is our controller itself]
	ctx.Next()
}

// [...]
app.Controller(new(ProfileController), checkLogin)
// [...]
```

Usage of these kind of MVC features could be found at the [mvc/controller_test.go](https://github.com/kataras/iris/blob/master/mvc/controller_test.go#L174) file.

### Other minor enhancements

- fix issue [#726](https://github.com/kataras/iris/issues/726)[*](https://github.com/kataras/iris/commit/5e435fc54fe3dbf95308327c2180d1b444ef7e0d)
- fix redis sessiondb expiration[*](https://github.com/kataras/iris/commit/85cfc91544c981e87e09c5aa86bad4b85d0b96d3)
- update recursively when new version is available[*](https://github.com/kataras/iris/commit/cd3c223536c6a33653a7fcf1f0648123f2b968fd)
- some minor session enhancements[*](https://github.com/kataras/iris/commit/2830f3b50ee9c526ac792c3ce1ec1c08c24ea024)


# Sa, 19 August 2017 | v8.3.1

First of all I want to thank you for the 100% green feedback you gratefully sent me you about
my latest article `Go vs .NET Core in terms of HTTP performance`, published at [medium's hackernoon.com](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8) and [dev.to](https://dev.to/kataras/go-vsnet-core-in-terms-of-http-performance). I really appreciate itüíì

No API Changes.

However two more methods added to the `Controller`.

- `RelPath() string`, returns the relative path based on the controller's name and the request path.
- `RelTmpl() string`, returns the relative template directory based on the controller's name.

These are useful when dealing with big `controllers`, they help you to keep align with any
future changes inside your application. 

Let's refactor our [ProfileController](_examples/mvc/controller-with-model-and-view/main.go) enhancemed by these two new functions.

```go
func (pc *ProfileController) tmpl(relativeTmplPath string) {
	// the relative template files directory of this controller.
	views := pc.RelTmpl()
	pc.Tmpl = views + relativeTmplPath
}

func (pc *ProfileController) match(relativeRequestPath string) bool {
	// the relative request path of this controller.
	path := pc.RelPath()
	return path == relativeRequestPath
}

func (pc *ProfileController) Get() {
	// requested: ""/profile""
	// so relative path is ""/"" because of the ProfileController.
	if pc.match(""/"") {

		// views/profile/index.html
		pc.tmpl(""index.html"")
		return
	}

	// requested: ""/profile/browse""
	// so relative path is ""/browse"".
	if pc.match(""/browse"") {
		pc.Path = ""/profile""
		return
	}

	// requested: ""/profile/me""
	// so the relative path is ""/me""
	if pc.match(""/me"") {
		
		// views/profile/me.html
		pc.tmpl(""me.html"")
		return
	}

	// requested: ""/profile/$ID""
	// so the relative path is ""/$ID""
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound

		// views/profile/notfound.html
		pc.tmpl(""notfound.html"")
		pc.Data[""ID""] = id
		return
	}

	// views/profile/profile.html
	pc.tmpl(""profile.html"")
	pc.User = user
}
```

Want to learn more about these functions? Go to the [mvc/controller_test.go](mvc/controller_test.go) file and scroll to the bottom!

# Fr, 18 August 2017 | v8.3.0

Good news for devs that are used to write their web apps using the `MVC` architecture pattern.

Implement a whole new `mvc` package with additional support for models and easy binding.

@kataras started to develop that feature by version 8.2.5, back then it didn't seem
to be a large feature and maybe a game-changer, so it lived inside the `kataras/iris/core/router/controller.go` file.
However with this version, so many things are implemented for the MVC and we needed a new whole package,
this new package is the `kataras/iris/mvc`, but if you used go 1.9 to build then you don't have to do any refactor, you could use the `iris.Controller` type alias.

People who used the mvc from its baby steps(v8.2.5) the only syntactic change you'll have to do is to rename the `router.Controller` to `mvc.Controller`:

Before: 
```go
import ""github.com/kataras/iris/core/router""
type MyController struct {
    router.Controller
}
```
Now:
```go
import ""github.com/kataras/iris/mvc""
type MyController struct {
    mvc.Controller
    // if you build with go1.9 you can omit the import of mvc package
    // and just use `iris.Controller` instead.
}
```

### MVC (Model View Controller)

![](_examples/mvc/web_mvc_diagram.png)

From version 8.3 and after Iris has **first-class support for the MVC pattern**, you'll not find
these stuff anywhere else in the Go world.


Example Code


```go
package main

import (
	""sync""

	""github.com/kataras/iris""
	""github.com/kataras/iris/mvc""
)

func main() {
	app := iris.New()
	app.RegisterView(iris.HTML(""./views"", "".html""))

	// when we have a path separated by spaces
	// then the Controller is registered to all of them one by one.
	//
	// myDB is binded to the controller's `*DB` field: use only structs and pointers.
	app.Controller(""/profile /profile/browse /profile/{id:int} /profile/me"",
		new(ProfileController), myDB) // IMPORTANT

	app.Run(iris.Addr("":8080""))
}

// UserModel our example model which will render on the template.
type UserModel struct {
	ID       int64
	Username string
}

// DB is our example database.
type DB struct {
	usersTable map[int64]UserModel
	mu         sync.RWMutex
}

// GetUserByID imaginary database lookup based on user id.
func (db *DB) GetUserByID(id int64) (u UserModel, found bool) {
	db.mu.RLock()
	u, found = db.usersTable[id]
	db.mu.RUnlock()
	return
}

var myDB = &DB{
	usersTable: map[int64]UserModel{
		1:  {1, ""kataras""},
		2:  {2, ""makis""},
		42: {42, ""jdoe""},
	},
}

// ProfileController our example user controller which controls
// the paths of ""/profile"" ""/profile/{id:int}"" and ""/profile/me"".
type ProfileController struct {
	mvc.Controller // IMPORTANT

	User UserModel `iris:""model""`
	// we will bind it but you can also tag it with`iris:""persistence""`
	// and init the controller with manual &PorifleController{DB: myDB}.
	DB *DB
}

// Get method handles all ""GET"" HTTP Method requests of the controller's paths.
func (pc *ProfileController) Get() { // IMPORTANT
	path := pc.Path

	// requested: /profile path
	if path == ""/profile"" {
		pc.Tmpl = ""profile/index.html""
		return
	}
	// requested: /profile/browse
	// this exists only to proof the concept of changing the path:
	// it will result to a redirection.
	if path == ""/profile/browse"" {
		pc.Path = ""/profile""
		return
	}

	// requested: /profile/me path
	if path == ""/profile/me"" {
		pc.Tmpl = ""profile/me.html""
		return
	}

	// requested: /profile/$ID
	id, _ := pc.Params.GetInt64(""id"")

	user, found := pc.DB.GetUserByID(id)
	if !found {
		pc.Status = iris.StatusNotFound
		pc.Tmpl = ""profile/notfound.html""
		pc.Data[""ID""] = id
		return
	}

	pc.Tmpl = ""profile/profile.html""
	pc.User = user
}


/*
func (pc *ProfileController) Post() {}
func (pc *ProfileController) Put() {}
func (pc *ProfileController) Delete() {}
func (pc *ProfileController) Connect() {}
func (pc *ProfileController) Head() {}
func (pc *ProfileController) Patch() {}
func (pc *ProfileController) Options() {}
func (pc *ProfileController) Trace() {}
*/

/*
func (pc *ProfileController) All() {}
//        OR
func (pc *ProfileController) Any() {}
*/
```

Iris web framework supports Request data, Models, Persistence Data and Binding
with the fastest possible execution.

**Characteristics**

All HTTP Methods are supported, for example if want to serve `GET`
then the controller should have a function named `Get()`,
you can define more than one method function to serve in the same Controller struct.

Persistence data inside your Controller struct (share data between requests)
via `iris:""persistence""` tag right to the field or Bind using `app.Controller(""/"" , new(myController), theBindValue)`.

Models inside your Controller struct (set-ed at the Method function and rendered by the View)
via `iris:""model""` tag right to the field, i.e ```User UserModel `iris:""model"" name:""user""` ``` view will recognise it as `{{.user}}`.
If `name` tag is missing then it takes the field's name, in this case the `""User""`.

Access to the request path and its parameters via the `Path and Params` fields.

Access to the template file that should be rendered via the `Tmpl` field.

Access to the template data that should be rendered inside
the template file via `Data` field.

Access to the template layout via the `Layout` field.

Access to the low-level `context.Context` via the `Ctx` field.

Get the relative request path by using the controller's name via `RelPath()`.

Get the relative template path directory by using the controller's name via `RelTmpl()`.

Flow as you used to, `Controllers` can be registered to any `Party`,
including Subdomains, the Party's begin and done handlers work as expected.

Optional `BeginRequest(ctx)` function to perform any initialization before the method execution,
useful to call middlewares or when many methods use the same collection of data.

Optional `EndRequest(ctx)` function to perform any finalization after any method executed.

Inheritance, recursively, see for example our `mvc.SessionController`, it has the `mvc.Controller` as an embedded field
and it adds its logic to its `BeginRequest`, [here](https://github.com/kataras/iris/blob/master/mvc/session_controller.go). 

Read access to the current route  via the `Route` field.

**Using Iris MVC for code reuse** 

By creating components that are independent of one another, developers are able to reuse components quickly and easily in other applications. The same (or similar) view for one application can be refactored for another application with different data because the view is simply handling how the data is being displayed to the user.

If you're new to back-end web development read about the MVC architectural pattern first, a good start is that [wikipedia article](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).


Follow the examples below,

- [Hello world](_examples/mvc/hello-world/main.go)
- [Session Controller](_examples/mvc/session-controller/main.go)
- [A simple but featured Controller with model and views](_examples/mvc/controller-with-model-and-view).

### Bugs

Fix [#723](https://github.com/kataras/iris/issues/723) reported by @speedwheel.


# Mo, 14 August 2017 | v8.2.6

Able to call done/end handlers inside a `Controller`, via optional `EndRequest(ctx context.Context)` function inside the controller struct.

```go
// it's called after t.Get()/Post()/Put()/Delete()/Connect()/Head()/Patch()/Options()/Trace().
func (t *testControllerEndRequestFunc) EndRequest(ctx context.Context) {
    // 2.
    // [your code goes here...]
}

// will handle ""GET"" request HTTP method only.
func (t *testControllerEndRequestFunc) Get() {
    // 1.
    // [your code goes here...]
}
```

Look at the [v8.2.5 changelog](#su-13-august-2017--v825) to learn more about the new Iris Controllers feature.

# Su, 13 August 2017 | v8.2.5

Good news for devs that are used to write their web apps using the `MVC-style` app architecture.

Yesterday I wrote a [tutorial](tutorial/mvc-from-scratch) on how you can transform your raw `Handlers` to `Controllers` using the existing tools only ([Iris is the most modular web framework out there](https://medium.com/@corebreaker/iris-web-cd684b4685c7), we all have no doubt about this).

Today, I did implement the `Controller` idea as **built'n feature inside Iris**.
Our `Controller` supports many things among them are:

- all HTTP Methods are supported, for example if want to serve `GET` then the controller should have a function named `Get()`, you can define more than one method function to serve in the same Controller struct
- `persistence` data inside your Controller struct (share data between requests) via **`iris:""persistence""`** tag right to the field
- optional `BeginRequest(ctx)` function to perform any initialization before the methods, useful to call middlewares or when many methods use the same collection of data
- optional `EndRequest(ctx)` function to perform any finalization after the methods executed
- access to the request path parameters via the `Params` field
- access to the template file that should be rendered via the `Tmpl` field
- access to the template data that should be rendered inside the template file via `Data` field
- access to the template layout via the `Layout` field
- access to the low-level `context.Context` via the `Ctx` field
- flow as you used to, `Controllers` can be registered to any `Party`, including Subdomains, the Party's begin and done handlers work as expected. 

It's very easy to get started, the only function you need to call instead of `app.Get/Post/Put/Delete/Connect/Head/Patch/Options/Trace` is the `app.Controller`.

Example Code:

```go
// file: main.go

package main

import (
    ""github.com/kataras/iris""

    ""controllers""
)

func main() {
    app := iris.New()
    app.RegisterView(iris.HTML(""./views"", "".html""))

    app.Controller(""/"", new(controllers.Index))

    // http://localhost:8080/
    app.Run(iris.Addr("":8080""))
}

```

```go
// file: controllers/index.go

package controllers

import (
    ""github.com/kataras/iris/core/router""
)

// Index is our index example controller.
type Index struct {
    mvc.Controller
    // if you're using go1.9: 
    // you can omit the /core/router import statement
    // and just use the `iris.Controller` instead.
}

// will handle GET method on http://localhost:8080/
func (c *Index) Get() {
    c.Tmpl = ""index.html""
    c.Data[""title""] = ""Index page""
    c.Data[""message""] = ""Hello world!""
}

// will handle POST method on http://localhost:8080/
func (c *Index) Post() {}

```

> Tip: declare a func(c *Index) All() {} or Any() to register all HTTP Methods.

A full example can be found at the [_examples/mvc](_examples/mvc) folder.


# Sa, 12 August 2017 | v8.2.4

No API Changes.

Fix https://github.com/kataras/iris/issues/717, users are welcomed to follow the thread for any questions or reports about Gzip and Static Files Handlers **only**.

# Th, 10 August 2017 | v8.2.3

No API Changes.

Fix https://github.com/kataras/iris/issues/714

Continue to v8.2.2 for more...

# Th, 10 August 2017 | v8.2.2

No API Changes.

- Implement [Google reCAPTCHA](middleware/recaptcha) middleware, example [here](_examples/miscellaneous/recaptcha/main.go)
- Fix [kataras/golog](https://github.com/kataras/golog) prints with colors on windows server 2012 while it shouldn't because its command line tool does not support 256bit colors
- Improve the updater by a custom self-updated back-end version checker, can be disabled by:

```go
app.Run(iris.Addr("":8080""), iris.WithoutVersionChecker)
```
Or
```go
app.Configure(iris.WithoutVersionChecker)
```
Or 
```go
app.Configure(iris.WithConfiguration(iris.Configuration{DisableVersionChecker:true}))
```

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    http://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the http://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (on August this import path will be optional)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/7494450/assets,https://api.github.com/repos/kataras/iris/releases/7494450,master,https://api.github.com/repos/kataras/iris/tarball/v8.3.4,https://github.com/kataras/iris/releases/tag/v8.3.4,https://api.github.com/repos/kataras/iris/zipball/v8.3.4,v8.3.4,False,False
7321186,2017-08-08T13:05:16Z,2017-08-08T16:20:45Z,v8.2.1,"> Iris uses the [vendor directory](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo) feature, so you get truly reproducible builds, as this method guards against upstream renames and deletes.

# Tu, 08 August 2017 | v8.2.1

No API Changes. Great news for the unique iris sessions library, once again.

**NEW**: [LevelDB-based](https://github.com/google/leveldb) session database implemented, example [here](_examples/sessions/database/leveldb/main.go).

[Redis-based sessiondb](sessions/sessiondb/redis) has no longer the `MaxAgeSeconds` config field,
this is passed automatically by the session manager, now.

All [sessions databases](sessions/sessiondb) have an `Async(bool)` function, if turned on
then all synchronization between the memory store and the back-end database will happen
inside different go routines. By-default async is false but it's recommended to turn it on, it will make sessions to be stored faster, at most.

All reported issues have been fixed, the API is simplified by `v8.2.0` so everyone can
create and use any back-end storage for application's sessions persistence.

# Mo, 07 August 2017 | v8.2.0

No Common-API Changes.

Good news for [iris sessions back-end databases](_examples/sessions) users.

<details>
<summary>Info for session database authors</summary>
Session Database API Changed to:

```go
type Database interface {
	Load(sid string) RemoteStore
	Sync(p SyncPayload)
}

// SyncPayload reports the state of the session inside a database sync action.
type SyncPayload struct {
	SessionID string

	Action Action
	// on insert it contains the new key and the value
	// on update it contains the existing key and the new value
	// on delete it contains the key (the value is nil)
	// on clear it contains nothing (empty key, value is nil)
	// on destroy it contains nothing (empty key, value is nil)
	Value memstore.Entry
	// Store contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Store RemoteStore
}


// RemoteStore is a helper which is a wrapper
// for the store, it can be used as the session ""table"" which will be
// saved to the session database.
type RemoteStore struct {
	// Values contains the whole memory store, this store
	// contains the current, updated from memory calls,
	// session data (keys and values). This way
	// the database has access to the whole session's data
	// every time.
	Values memstore.Store
	// on insert it contains the expiration datetime
	// on update it contains the new expiration datetime(if updated or the old one)
	// on delete it will be zero
	// on clear it will be zero
	// on destroy it will be zero
	Lifetime LifeTime
}
```

Read more at [sessions/database.go](sessions/database.go), view how three built'n session databases are being implemented [here](sessions/sessiondb).
</details> 

All sessions databases are updated and they performant even faster than before.

- **NEW** raw file-based session database implemented, example [here](_examples/sessions/database/file)
- **NEW** [boltdb-based](https://github.com/boltdb/bolt) session database implemented, example [here](_examples/sessions/database/boltdb) (recommended as it's safer and faster)
- [redis sessiondb](_examples/sessions/database/redis) updated to the latest api

Under the cover, session database works entirely differently than before but nothing changed from the user's perspective, so upgrade with `go get -u github.com/kataras/iris` and sleep well.

# Tu, 01 August 2017 | v8.1.3

- Add `Option` function to the `html view engine`: https://github.com/kataras/iris/issues/694
- Fix sessions backend databases restore expiration: https://github.com/kataras/iris/issues/692 by @corebreaker
- Add `PartyFunc`, same as `Party` but receives a function with the sub router as its argument instead [GO1.9 Users-ONLY]

# Mo, 31 July 2017 | v8.1.2

Add a `ConfigureHost` function as an alternative way to customize the hosts via `host.Configurator`.
The first way was to pass `host.Configurator` as optional arguments on `iris.Runner`s built'n functions (`iris#Server, iris#Listener, iris#Addr, iris#TLS, iris#AutoTLS`), example of this can be found [there](https://github.com/kataras/iris/blob/master/_examples/http-listening/notify-on-shutdown).

Example Code:

```go
package main

import (
	stdContext ""context""
	""time""

	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
	""github.com/kataras/iris/core/host""
)

func main() {
	app := iris.New()

	app.Get(""/"", func(ctx context.Context) {
		ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
	})

    app.ConfigureHost(configureHost) // or pass ""configureHost"" as `app.Addr` argument, same result.

	app.Logger().Info(""Wait 10 seconds and check your terminal again"")
	// simulate a shutdown action here...
	go func() {
		<-time.After(10 * time.Second)
		timeout := 5 * time.Second
		ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
		defer cancel()
		// close all hosts, this will notify the callback we had register
		// inside the `configureHost` func.
		app.Shutdown(ctx)
	}()

	// http://localhost:8080
	// wait 10 seconds and check your terminal.
	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func configureHost(su *host.Supervisor) {
	// here we have full access to the host that will be created
	// inside the `app.Run` or `app.NewHost` function .
	//
	// we're registering a shutdown ""event"" callback here:
	su.RegisterOnShutdown(func() {
		println(""server is closed"")
	})
	// su.RegisterOnError
	// su.RegisterOnServe
}
```

# Su, 30 July 2017

Greetings my friends, nothing special today, no version number yet.

We just improve the, external, Iris Logging library and the `Columns` config field from `middleware/logger` defaults to `false` now. Upgrade with `go get -u github.com/kataras/iris` and have fun!

# Sa, 29 July 2017 | v8.1.1

No breaking changes, just an addition to make your life easier.

This feature has been implemented after @corebreaker 's request, posted at: https://github.com/kataras/iris/issues/688. He was also tried to fix that by a [PR](https://github.com/kataras/iris/pull/689), we thanks him but the problem with that PR was the duplication and the separation of concepts, however we thanks him for pushing for a solution. The current feature's implementation gives a permant solution to host supervisor access issues.

Optional host configurators added to all common serve and listen functions.

Below you'll find how to gain access to the host, **the second way is the new feature.**

### Hosts

Access to all hosts that serve your application can be provided by
the `Application#Hosts` field, after the `Run` method.

But the most common scenario is that you may need access to the host before the `Run` method,
there are two ways of gain access to the host supervisor, read below.

First way is to use the `app.NewHost` to create a new host
and use one of its `Serve` or `Listen` functions
to start the application via the `iris#Raw` Runner.
Note that this way needs an extra import of the `net/http` package.

Example Code:

```go
h := app.NewHost(&http.Server{Addr:"":8080""})
h.RegisterOnShutdown(func(){
    println(""server was closed!"")
})

app.Run(iris.Raw(h.ListenAndServe))
```

Second, and probably easier way is to use the `host.Configurator`.

Note that this method requires an extra import statement of
""github.com/kataras/iris/core/host"" when using go < 1.9,
if you're targeting on go1.9 then you can use the `iris#Supervisor`
and omit the extra host import.

All common `Runners` we saw earlier (`iris#Addr, iris#Listener, iris#Server, iris#TLS, iris#AutoTLS`)
accept a variadic argument of `host.Configurator`, there are just `func(*host.Supervisor)`.
Therefore the `Application` gives you the rights to modify the auto-created host supervisor through these.


Example Code:

```go
package main

import (
    stdContext ""context""
    ""time""

    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
    ""github.com/kataras/iris/core/host""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
        ctx.HTML(""<h1>Hello, try to refresh the page after ~10 secs</h1>"")
    })

    app.Logger().Info(""Wait 10 seconds and check your terminal again"")
    // simulate a shutdown action here...
    go func() {
        <-time.After(10 * time.Second)
        timeout := 5 * time.Second
        ctx, cancel := stdContext.WithTimeout(stdContext.Background(), timeout)
        defer cancel()
        // close all hosts, this will notify the callback we had register
        // inside the `configureHost` func.
        app.Shutdown(ctx)
    }()

    // start the server as usual, the only difference is that
    // we're adding a second (optional) function
    // to configure the just-created host supervisor.
    //
    // http://localhost:8080
    // wait 10 seconds and check your terminal.
    app.Run(iris.Addr("":8080"", configureHost), iris.WithoutServerError(iris.ErrServerClosed))

}

func configureHost(su *host.Supervisor) {
    // here we have full access to the host that will be created
    // inside the `Run` function.
    //
    // we register a shutdown ""event"" callback
    su.RegisterOnShutdown(func() {
        println(""server is closed"")
    })
    // su.RegisterOnError
    // su.RegisterOnServe
}
```

Read more about listening and gracefully shutdown by navigating to: https://github.com/kataras/iris/tree/master/_examples/#http-listening

# We, 26 July 2017 | v8.1.0

The `app.Logger() *logrus.Logger` was replaced with a custom implementation [[golog](https://github.com/kataras/golog)], it's compatible with the [logrus](https://github.com/sirupsen/logrus) package and other open-source golang loggers as well, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

The API didn't change much except these:

-  the new implementation does not recognise `Fatal` and `Panic` because, actually, iris never panics
- the old `app.Logger().Out = io.Writer` should be written as `app.Logger().SetOutput(io.Writer)`

The new implementation, [golog](https://github.com/kataras/golog) is featured, **[three times faster than logrus](https://github.com/kataras/golog/tree/master/_benchmarks)**
and it completes every common usage.

### Integration

I understand that many of you may use logrus outside of Iris too. To integrate an external `logrus` logger just 
`Install` it-- all print operations will be handled by the provided `logrus instance`.

```go
import (
    ""github.com/kataras/iris""
    ""github.com/sirupsen/logrus""
)

package main(){
    app := iris.New()
    app.Logger().Install(logrus.StandardLogger()) // the package-level logrus instance
    // [...]
}
```

For more information about our new logger please navigate to: https://github.com/kataras/golog -  contributions are welcomed as well!

# Sa, 23 July 2017 | v8.0.7

Fix [It's true that with UseGlobal the ""/path1.txt"" route call the middleware but cause the prepend, the order is inversed](https://github.com/kataras/iris/issues/683#issuecomment-317229068)

# Sa, 22 July 2017 | v8.0.5 & v8.0.6

No API Changes.

### Performance

Add an experimental [Configuration#EnableOptimizations](https://github.com/kataras/iris/blob/master/configuration.go#L170) option.

```go
type Configuration {
    // [...]

    // EnableOptimization when this field is true
    // then the application tries to optimize for the best performance where is possible.
    //
    // Defaults to false.
    EnableOptimizations bool `yaml:""EnableOptimizations"" toml:""EnableOptimizations""`

    // [...]
}
```

Usage:

```go
app.Run(iris.Addr("":8080""), iris.WithOptimizations)
```

### Django view engine

@corebreaker pushed a [PR](https://github.com/kataras/iris/pull/682) to solve the [Problem for {%extends%} in Django Engine with embedded files](https://github.com/kataras/iris/issues/681).

### Logger

Remove the `vendor/github.com/sirupsen/logrus` folder, as a temporary solution for the https://github.com/kataras/iris/issues/680#issuecomment-316196126.

#### Future versions

The logrus will be replaced with a custom implementation, because of that: https://github.com/kataras/iris/issues/680#issuecomment-316184570. 

As far as we know, @kataras is working on this new implementation, see [here](https://github.com/kataras/iris/issues/680#issuecomment-316544906), 
which will be compatible with the logrus package and other open-source golang loggers as well.


# Mo, 17 July 2017 | v8.0.4

No API changes.

### HTTP Errors

Fix a rare behavior: error handlers are not executed correctly
when a before-handler by-passes the order of execution, relative to the [previous feature](https://github.com/kataras/iris/blob/master/HISTORY.md#su-16-july-2017--v803). 

### Request Logger

Add `Configuration#MessageContextKey`. Example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L48).

# Su, 16 July 2017 | v8.0.3

No API changes.

Relative issues: 

- https://github.com/kataras/iris/issues/674
- https://github.com/kataras/iris/issues/675
- https://github.com/kataras/iris/issues/676

### HTTP Errors

Able to register a chain of Handlers (and middleware with `ctx.Next()` support like routes) for a specific error code, read more at [issues/674](https://github.com/kataras/iris/issues/674). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L41).


New function to register a Handler or a chain of Handlers for all official http error codes, by calling the new `app.OnAnyErrorCode(func(ctx context.Context){})`, read more at [issues/675](https://github.com/kataras/iris/issues/675). Usage example can be found at [_examples/http_request/request-logger/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/main.go#L42).

### Request Logger

Add `Configuration#LogFunc` and `Configuration#Columns` fields, read more at [issues/676](https://github.com/kataras/iris/issues/676). Example can be found at [_examples/http_request/request-logger/request-logger-file/main.go](https://github.com/kataras/iris/blob/master/_examples/http_request/request-logger/request-logger-file/main.go).


Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Sa, 15 July 2017 | v8.0.2

Okay my friends, this is a good time to upgrade, I did implement a feature that you were asking many times at the past.

Iris' router can now handle root-level wildcard paths `app.Get(""/{paramName:path})`.

In case you're wondering: no it does not conflict with other static or dynamic routes, meaning that you can code something like this:

```go
// it isn't conflicts with the rest of the static routes or dynamic routes with a path prefix.
app.Get(""/{pathParamName:path}"", myHandler) 
```

Or even like this:

```go
package main

import (
	""github.com/kataras/iris""
	""github.com/kataras/iris/context""
)

func main() {
	app := iris.New()

	// this works as expected now,
	// will handle all GET requests
	// except:
	// /                     -> because of app.Get(""/"", ...)
	// /other/anything/here  -> because of app.Get(""/other/{paramother:path}"", ...)
	// /other2/anything/here -> because of app.Get(""/other2/{paramothersecond:path}"", ...)
	// /other2/static        -> because of app.Get(""/other2/static"", ...)
	//
	// It isn't conflicts with the rest of the routes, without routing performance cost!
	//
	// i.e /something/here/that/cannot/be/found/by/other/registered/routes/order/not/matters
	app.Get(""/{p:path}"", h)

	// this will handle only GET /
	app.Get(""/"", staticPath)

	// this will handle all GET requests starting with ""/other/""
	//
	// i.e /other/more/than/one/path/parts
	app.Get(""/other/{paramother:path}"", other)

	// this will handle all GET requests starting with ""/other2/""
	// except /other2/static (because of the next static route)
	//
	// i.e /other2/more/than/one/path/parts
	app.Get(""/other2/{paramothersecond:path}"", other2)

	// this will handle only GET /other2/static
	app.Get(""/other2/static"", staticPath)

	app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
}

func h(ctx context.Context) {
	param := ctx.Params().Get(""p"")
	ctx.WriteString(param)
}

func other(ctx context.Context) {
	param := ctx.Params().Get(""paramother"")
	ctx.Writef(""from other: %s"", param)
}

func other2(ctx context.Context) {
	param := ctx.Params().Get(""paramothersecond"")
	ctx.Writef(""from other2: %s"", param)
}

func staticPath(ctx context.Context) {
	ctx.Writef(""from the static path: %s"", ctx.Path())
}
``` 

If you find any bugs with this change please send me a [chat message](https://kataras.rocket.chat/channel/iris) in order to investigate it, I'm totally free at weekends.

Have fun and don't forget to [star](https://github.com/kataras/iris/stargazers) the github repository, it gives me power to continue publishing my work!

# Th, 13 July 2017 | v8.0.1

Nothing tremendous at this minor version.

We've just added a configuration field in order to ignore errors received by the `Run` function, see below.

[Configuration#IgnoreServerErrors](https://github.com/kataras/iris/blob/master/configuration.go#L255)
```go
type Configuration struct {
    // [...]

    // IgnoreServerErrors will cause to ignore the matched ""errors""
    // from the main application's `Run` function.
    // This is a slice of string, not a slice of error
    // users can register these errors using yaml or toml configuration file
    // like the rest of the configuration fields.
    //
    // See `WithoutServerError(...)` function too.
    //
    // Defaults to an empty slice.
    IgnoreServerErrors []string `yaml:""IgnoreServerErrors"" toml:""IgnoreServerErrors""`

    // [...]
}
```
[Configuration#WithoutServerError](https://github.com/kataras/iris/blob/master/configuration.go#L106)
```go
// WithoutServerError will cause to ignore the matched ""errors""
// from the main application's `Run` function.
//
// Usage:
// err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
// will return `nil` if the server's error was `http/iris#ErrServerClosed`.
//
// See `Configuration#IgnoreServerErrors []string` too.
WithoutServerError(errors ...error) Configurator
```

By default no error is being ignored, of course.

Example code:
[_examples/http-listening/listen-addr/omit-server-errors](https://github.com/kataras/iris/tree/master/_examples/http-listening/listen-addr/omit-server-errors)
```go
package main

import (
    ""github.com/kataras/iris""
    ""github.com/kataras/iris/context""
)

func main() {
    app := iris.New()

    app.Get(""/"", func(ctx context.Context) {
    	ctx.HTML(""<h1>Hello World!/</h1>"")
    })

    err := app.Run(iris.Addr("":8080""), iris.WithoutServerError(iris.ErrServerClosed))
    if err != nil {
        // do something
    }
    // same as:
    // err := app.Run(iris.Addr("":8080""))
    // if err != nil && (err != iris.ErrServerClosed || err.Error() != iris.ErrServerClosed.Error()) {
    //     [...]
    // }
}
```

At first we didn't want to implement something like that because it's ridiculous easy to do it manually but a second thought came to us,
that many applications are based on configuration, therefore it would be nice to have something to ignore errors
by simply string values that can be passed to the application's configuration via `toml` or `yaml` files too.

This feature has been implemented after a request of ignoring the `iris/http#ErrServerClosed` from the `Run` function: 
https://github.com/kataras/iris/issues/668

# Mo, 10 July 2017 | v8.0.0

## üìà One and a half years with Iris and You...

Despite the deflamations, the clickbait articles, the removed posts of mine at reddit/r/golang, the unexpected and inadequate ban from the gophers slack room by @dlsniper alone the previous week without any reason or inform, Iris is still here and will be.

- 7070 github stars
- 749 github forks
- 1m total views at its documentation
- ~800$ at donations (there're a lot for a golang open-source project, thanks to you)
- ~550 reported bugs fixed
- ~30 community feature requests have been implemented

## üî• Reborn

As you may have heard I have huge responsibilities on my new position at Dubai nowadays, therefore I don't have the needed time to work on this project anymore.

After a month of negotiations and searching I succeed to find a decent software engineer to continue my work on the open source community.

The leadership of this, open-source, repository was transferred to [hiveminded](https://github.com/hiveminded), the author of iris-based [get-ion/ion](https://github.com/get-ion/ion), he actually did an excellent job on the framework, he kept the code as minimal as possible and at the same time added more features, examples and middleware(s).

These types of projects need heart and sacrifices to continue offer the best developer experience like a paid software, please do support him as you did with me!

## üì∞ Changelog

> app. = `app := iris.New();` **app.**

> ctx. = `func(ctx context.Context) {` **ctx.** `}`

### Docker

Docker and kubernetes integration showcase, see the [iris-contrib/cloud-native-go](https://github.com/iris-contrib/cloud-native-go) repository as an example.

### Logger

* Logger which was an `io.Writer` was replaced with the pluggable `logrus`.
    * which you still attach an `io.Writer` with `app.Logger().Out = an io.Writer`.
    * iris as always logs only critical errors, you can disable them with `app.Logger().Level = iris.NoLog`
    * the request logger outputs the incoming requests as INFO level.

### Sessions

Remove `ctx.Session()` and `app.AttachSessionManager`, devs should import and use the `sessions` package as standalone, it's totally optional, devs can use any other session manager too. [Examples here](sessions#table-of-contents).

### Websockets

The `github.com/kataras/iris/websocket` package does not handle the endpoint and client side automatically anymore. Example code:

```go
func setupWebsocket(app *iris.Application) {
    // create our echo websocket server
    ws := websocket.New(websocket.Config{
    	ReadBufferSize:  1024,
    	WriteBufferSize: 1024,
    })
    ws.OnConnection(handleConnection)
    // serve the javascript built'n client-side library,
    // see weboskcets.html script tags, this path is used.
    app.Any(""/iris-ws.js"", func(ctx context.Context) {
    	ctx.Write(websocket.ClientSource)
    })

    // register the server on an endpoint.
    // see the inline javascript code in the websockets.html, this endpoint is used to connect to the server.
    app.Get(""/echo"", ws.Handler())
}
```

> More examples [here](websocket#table-of-contents)

### View

Rename `app.AttachView(...)` to `app.RegisterView(...)`.

Users can omit the import of `github.com/kataras/iris/view` and use the `github.com/kataras/iris` package to
refer to the view engines, i.e: `app.RegisterView(iris.HTML(""./templates"", "".html""))` is the same as `import ""github.com/kataras/iris/view"" [...] app.RegisterView(view.HTML(""./templates"" ,"".html""))`.

> Examples [here](_examples/#view)

### Security

At previous versions, when you called `ctx.Remoteaddr()` Iris could parse and return the client's IP from the ""X-Real-IP"", ""X-Forwarded-For"" headers. This was a security leak as you can imagine, because the user can modify them. So we've disabled these headers by-default and add an option to add/remove request headers that are responsible to parse and return the client's real IP.

```go
// WithRemoteAddrHeader enables or adds a new or existing request header name
// that can be used to validate the client's real IP.
//
// Existing values are:
// ""X-Real-Ip"":             false,
// ""X-Forwarded-For"":       false,
// ""CF-Connecting-IP"": false
//
// Look `context.RemoteAddr()` for more.
WithRemoteAddrHeader(headerName string) Configurator // enables a header.
WithoutRemoteAddrHeader(headerName string) Configurator // disables a header.
```
For example, if you want to enable the ""CF-Connecting-IP"" header (cloudflare) 
you have to add the `WithRemoteAddrHeader` option to the `app.Run` function, at the end of your program.

```go
app.Run(iris.Addr("":8080""), iris.WithRemoteAddrHeader(""CF-Connecting-IP""))
// This header name will be checked when ctx.RemoteAddr() called and if exists
// it will return the client's IP, otherwise it will return the default *http.Request's `RemoteAddr` field.
```

### Miscellaneous

Fix [typescript tools](typescript).

[_examples](_examples/) folder has been ordered by feature and usage:
    - contains tests on some examples
    - new examples added, one of them shows how the `reuseport` feature on UNIX and BSD systems can be used to listen for incoming connections, [see here](_examples/#http-listening)


Replace supervisor's tasks with events, like `RegisterOnShutdown`, `RegisterOnError`, `RegisterOnServe` and fix the (unharmful) race condition when output the banner to the console. Global notifier for interrupt signals which can be disabled via `app.Run([...], iris.WithoutInterruptHandler)`, look [graceful-shutdown](_examples/http-listening/graceful-shutdown/main.go) example for more.


More handlers are ported to Iris (they can be used as they are without `iris.FromStd`), these handlers can be found at [iris-contrib/middleware](https://github.com/iris-contrib/middleware). Feel free to put your own there.


| Middleware | Description | Example |
| -----------|--------|-------------|
| [jwt](https://github.com/iris-contrib/middleware/tree/master/jwt) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it. | [iris-contrib/middleware/jwt/_example](https://github.com/iris-contrib/middleware/tree/master/jwt/_example) |
| [cors](https://github.com/iris-contrib/middleware/tree/master/cors) | HTTP Access Control. | [iris-contrib/middleware/cors/_example](https://github.com/iris-contrib/middleware/tree/master/cors/_example) |
| [secure](https://github.com/iris-contrib/middleware/tree/master/secure) | Middleware that implements a few quick security wins. | [iris-contrib/middleware/secure/_example](https://github.com/iris-contrib/middleware/tree/master/secure/_example/main.go) |
| [tollbooth](https://github.com/iris-contrib/middleware/tree/master/tollboothic) | Generic middleware to rate-limit HTTP requests. | [iris-contrib/middleware/tollbooth/_examples/limit-handler](https://github.com/iris-contrib/middleware/tree/master/tollbooth/_examples/limit-handler) |
| [cloudwatch](https://github.com/iris-contrib/middleware/tree/master/cloudwatch) |  AWS cloudwatch metrics middleware. |[iris-contrib/middleware/cloudwatch/_example](https://github.com/iris-contrib/middleware/tree/master/cloudwatch/_example) |
| [new relic](https://github.com/iris-contrib/middleware/tree/master/newrelic) | Official [New Relic Go Agent](https://github.com/newrelic/go-agent). | [iris-contrib/middleware/newrelic/_example](https://github.com/iris-contrib/middleware/tree/master/newrelic/_example) |
| [prometheus](https://github.com/iris-contrib/middleware/tree/master/prometheus)| Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool | [iris-contrib/middleware/prometheus/_example](https://github.com/iris-contrib/middleware/tree/master/prometheus/_example) |


v7.x is deprecated because it sold as it is and it is not part of the public, stable `gopkg.in` iris versions. Developers/users of this library should upgrade their apps to v8.x, the refactor process will cost nothing for most of you, as the most common API remains as it was. The changelog history from that are being presented below.


# Th, 15 June 2017 | v7.2.0

### About our new home page
    http://iris-go.com

Thanks to [Santosh Anand](https://github.com/santoshanand) the http://iris-go.com has been upgraded and it's really awesome!

[Santosh](https://github.com/santoshanand) is a freelancer, he has a great knowledge of nodejs and express js, Android, iOS, React Native, Vue.js etc, if you need a developer to find or create a solution for your problem or task, please contact with him.


The amount of the next two or three donations you'll send they will be immediately transferred to his own account balance, so be generous please!

### Cache

Declare the `iris.Cache alias` to the new, improved and most-suited for common usage, `cache.Handler function`.

`iris.Cache` be used as middleware in the chain now, example [here](_examples/intermediate/cache-markdown/main.go). However [you can still use the cache as a wrapper](cache/cache_test.go) by importing the `github.com/kataras/iris/cache` package. 


### File server

- **Fix** [that](https://github.com/iris-contrib/community-board/issues/12).

- `app.StaticHandler(requestPath string, systemPath string, showList bool, gzip bool)` -> `app.StaticHandler(systemPath,showList bool, gzip bool)`

- **New** feature for Single Page Applications, `app.SPA(assetHandler context.Handler)` implemented.

- **New** `app.StaticEmbeddedHandler(vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)` added in order to be able to pass that on `app.SPA(app.StaticEmbeddedHandler(""./public"", Asset, AssetNames))`.

- **Fix** `app.StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string)`.

Examples: 
- [Embedding Files Into Executable App](_examples/file-server/embedding-files-into-app)
- [Single Page Application](_examples/file-server/single-page-application)
- [Embedding Single Page Application](_examples/file-server/embedding-single-page-application)

> [app.StaticWeb](_examples/file-server/basic/main.go) doesn't works for root request path ""/""  anymore, use the new `app.SPA` instead.   

### WWW subdomain entry

- [Example](_examples/subdomains/www/main.go) added to copy all application's routes, including parties, to the `www.mydomain.com`


### Wrapping the Router

- [Example](_examples/routing/custom-wrapper/main.go) added to show you how you can use the `app.WrapRouter` 
to implement a similar to `app.SPA` functionality, don't panic, it's easier than it sounds.


### Testing

- `httptest.New(app *iris.Application, t *testing.T)` -> `httptest.New(t *testing.T, app *iris.Application)`.

- **New** `httptest.NewLocalListener() net.Listener` added.
- **New** `httptest.NewLocalTLSListener(tcpListener net.Listener) net.Listener` added.

Useful for testing tls-enabled servers: 

Proxies are trying to understand local addresses in order to allow `InsecureSkipVerify`.

-  `host.ProxyHandler(target *url.URL) *httputil.ReverseProxy`.
-  `host.NewProxy(hostAddr string, target *url.URL) *Supervisor`.
        
    Tests [here](core/host/proxy_test.go).

# Tu, 13 June 2017 | v7.1.1

Fix [that](https://github.com/iris-contrib/community-board/issues/11).

# Mo, 12 June 2017 | v7.1.0

Fix [that](https://github.com/iris-contrib/community-board/issues/10).


# Su, 11 June 2017 | v7.0.5

Iris now supports static paths and dynamic paths for the same path prefix with zero performance cost:

`app.Get(""/profile/{id:int}"", handler)` and `app.Get(""/profile/create"", createHandler)` are not in conflict anymore.


The rest of the special Iris' routing features, including static & wildcard subdomains are still work like a charm.

> This was one of the most popular community's feature requests. Click [here](https://github.com/kataras/iris/blob/master/_examples/beginner/routing/overview/main.go) to see a trivial example.

# Sa, 10 June 2017 | v7.0.4

- Simplify and add a test for the [basicauth middleware](https://github.com/kataras/iris/tree/master/middleware/basicauth), no need to be
stored inside the Context anymore, developers can get the validated user(username and password) via `context.Request().BasicAuth()`. `basicauth.Config.ContextKey` was removed, just remove that field from your configuration, it's useless now. 

# Sa, 10 June 2017 | v7.0.3

- New `context.Session().PeekFlash(""key"")` added, unlike `GetFlash` this will return the flash value but keep the message valid for the next requests too.
- Complete the [httptest example](https://github.com/iris-contrib/examples/tree/master/httptest).
- Fix the (marked as deprecated) `ListenLETSENCRYPT` function.
- Upgrade the [iris-contrib/middleware](https://github.com/iris-contrib/middleware) including JWT, CORS and Secure handlers.
- Add [OAuth2 example](https://github.com/iris-contrib/examples/tree/master/oauth2) -- showcases the third-party package [goth](https://github.com/markbates/goth) integration with Iris.

### Community

 - Add github integration on https://kataras.rocket.chat/channel/iris , so users can login with their github accounts instead of creating new for the chat only.

# Th, 08 June 2017 | v7.0.2

- Able to set **immutable** data on sessions and context's storage. Aligned to fix an issue on slices and maps as reported [here](https://github.com/iris-contrib/community-board/issues/5).

# We, 07 June 2017 | v7.0.1

- Proof of concept of an internal release generator, navigate [here](https://github.com/iris-contrib/community-board/issues/2) to read more. 
- Remove tray icon ""feature"", click [here](https://github.com/iris-contrib/community-board/issues/1) to learn why.

# Sa, 03 June 2017 

After 2+ months of hard work and collaborations, Iris [version 7](https://github.com/kataras/iris) was published earlier today.

If you're new to Iris you don't have to read all these, just navigate to the [updated examples](https://github.com/kataras/iris/tree/master/_examples) and you should be fine:)

Note that this section will not
cover the internal changes, the difference is so big that anybody can see them with a glimpse, even the code structure itself.


## Changes from [v6](https://github.com/kataras/iris/tree/v6)

The whole framework was re-written from zero but I tried to keep the most common public API that iris developers use.

Vendoring /w update 

The previous vendor action for v6 was done by-hand, now I'm using the [go dep](https://github.com/golang/dep) tool, I had to do
some small steps:

- remove files like testdata to reduce the folder size
- rollback some of the ""golang/x/net/ipv4"" and ""ipv6"" source files because they are downloaded to their latest versions
by go dep, but they had lines with the `typealias` feature, which is not ready by current golang version (it will be on August)
- fix ""cannot use internal package"" at golang/x/net/ipv4 and ipv6 packages
	- rename the interal folder to was-internal, everywhere and fix its references.
- fix ""main redeclared in this block""
	- remove all examples folders.
- remove main.go files on jsondiff lib, used by gavv/httpexpect, produces errors on `test -v ./...` while jd and jp folders are not used at all.

The go dep tool does what is says, as expected, don't be afraid of it now.
I am totally recommending this tool for package authors, even if it's in its alpha state.
I remember when Iris was in its alpha state and it had 4k stars on its first weeks/or month and that helped me a lot to fix reported bugs by users and make the framework even better, so give love to go dep from today!

General

- Several enhancements for the typescript transpiler, view engine, websocket server and sessions manager
- All `Listen` methods replaced with a single `Run` method, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/listening)
- Configuration, easier to modify the defaults, see [here](https://github.com/kataras/iris/tree/master/_examples/beginner/cofiguration)
- `HandlerFunc` removed, just `Handler` of `func(context.Context)` where context.Context derives from `import ""github.com/kataras/iris/context""` (on August this import path will be optional)
    - Simplify API, i.e: instead of `Handle,HandleFunc,Use,UseFunc,Done,DoneFunc,UseGlobal,UseGlobalFunc` use `Handle,Use,Done,UseGlobal`.
- Response time decreased even more (9-35%, depends on the application)
- The `Adaptors` idea replaced with a more structural design pattern, but you have to apply these changes: 
    - `app.Adapt(view.HTML/Pug/Amber/Django/Handlebars...)` -> `app.AttachView(view.HTML/Pug/Amber/Django/Handlebars...)` 
    - `app.Adapt(sessions.New(...))` -> `app.AttachSessionManager(sessions.New(...))`
    - `app.Adapt(iris.LoggerPolicy(...))` -> `app.AttachLogger(io.Writer)`
    - `app.Adapt(iris.RenderPolicy(...))` -> removed and replaced with the ability to replace the whole context with a custom one or override some methods of it, see below.

Routing
- Remove of multiple routers, now we have the fresh Iris router which is based on top of the julien's [httprouter](https://github.com/julienschmidt/httprouter).
    > Update 11 June 2017: As of 7.0.5 this is changed, read [here](https://github.com/kataras/iris/blob/master/HISTORY.md#su-11-june-2017--v705).
- Subdomains routing algorithm has been improved.
- Iris router is using a custom interpreter with parser and path evaluator to achieve the best expressiveness, with zero performance loss, you ever seen so far, i.e: 
    - `app.Get(""/"", ""/users/{userid:int min(1)}"", handler)`,
        - `{username:string}` or just `{username}`
        - `{asset:path}`,
        - `{firstname:alphabetical}`,
        - `{requestfile:file}` ,
        - `{mylowercaseParam regexp([a-z]+)}`.
        - The previous syntax of `:param` and `*param` still working as expected. Previous rules for paths confliction remain as they were.
            - Also, path parameter names should be only alphabetical now, numbers and symbols are not allowed (for your own good, I have seen a lot the last year...).

Click [here](https://github.com/kataras/iris/tree/master/_examples/beginner/routing) for details.
> It was my first attempt/experience on the interpreters field, so be good with it :)

Context
- `iris.Context pointer` replaced with `context.Context interface` as we already mention
    - in order to be able to use a custom context and/or catch lifetime like `BeginRequest` and `EndRequest` from context itself, see below
- `context.JSON, context.JSONP, context.XML, context.Markdown, context.HTML` work faster
- `context.Render(""filename.ext"", bindingViewData{}, options) ` -> `context.View(""filename.ext"")`
    - `View` renders only templates, it will not try to search if you have a restful renderer adapted, because, now, you can do it via method overriding using a custom Context.
    - Able to set `context.ViewData` and `context.ViewLayout` via middleware when executing a template.
- `context.SetStatusCode(statusCode)` -> `context.StatusCode(statusCode)`
    - which is equivalent with the old `EmitError` too:
        - if status code >=400 given can automatically fire a custom http error handler if response wasn't written already.
    - `context.StatusCode()` -> `context.GetStatusCode()`
    - `app.OnError` -> `app.OnErrorCode`
    - Errors per party are removed by-default, you can just use one global error handler with logic like ""if path starts with 'prefix' fire this error handler, else..."". 
- Easy way to change Iris' default `Context` with a custom one, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/custom-context)
- `context.ResponseWriter().SetBeforeFlush(...)` works for Flush and HTTP/2 Push, respectfully
- Several improvements under the `Request transactions` 
- Remember that you had to set a status code on each of the render-relative methods? Now it's not required, it just renders
with the status code that user gave with `context.StatusCode` or with `200 OK`, i.e:
    -`context.JSON(iris.StatusOK, myJSON{})` -> `context.JSON(myJSON{})`.
    - Each one of the context's render methods has optional per-call settings,
    - **the new API is even more easier to read, understand and use.**

Server
- Able to set custom underline *http.Server(s) with new Host (aka Server Supervisor) feature 
    - `Done` and `Err` channels to catch shutdown or any errors on custom hosts,
    - Schedule custom tasks(with cancelation) when server is running, see [here](https://github.com/kataras/iris/tree/master/_examples/intermediate/graceful-shutdown)
- Interrupt handler task for gracefully shutdown (when `CTRL/CMD+C`) are enabled by-default, you can disable its via configuration: `app.Run(iris.Addr("":8080""), iris.WithoutInterruptHandler)`

Future plans
- Future Go1.9's [ServeTLS](https://go-review.googlesource.com/c/38114/2/src/net/http/server.go) is ready when 1.9 released
- Future Go1.9's typealias feature is ready when 1.9 released, i.e `context.Context` -> `iris.Context` just one import path instead of todays' two.",https://api.github.com/users/kataras,22900943,kataras,https://api.github.com/repos/kataras/iris/releases/7321186/assets,https://api.github.com/repos/kataras/iris/releases/7321186,master,https://api.github.com/repos/kataras/iris/tarball/v8.2.1,https://github.com/kataras/iris/releases/tag/v8.2.1,https://api.github.com/repos/kataras/iris/zipball/v8.2.1,v8.2.1,False,False
6595285,2017-06-03T19:18:43Z,2017-06-03T19:24:15Z,v6.2,"## v5 -> v6.2 

-  **FIX**: Upgrade the [httpcache](https://github.com/geekypanda/httpcache) vendor. As requested [here](http://support.iris-go.com/d/44-upgrade-httpcache-module).


- **View**: Provide an easier method on the community's question about ""injecting"" additional data outside of the route's main handler which calls the .Render, via middleware. 
	- As discussed [above](http://support.iris-go.com/d/27-using-middleware-to-inject-properties-for-templates). 
	- Click [here](https://github.com/kataras/iris/tree/v6/_examples/intermediate/view/context-view-data) for an example.

- **Sessions**: Enchance the community's feature request about custom encode and decode methods for the cookie value(sessionid) as requested [here](http://support.iris-go.com/d/29-mark-cookie-for-session-as-secure).

- Enhance Custom http errors with gzip and static files handler, as requested/reported [here](http://support.iris-go.com/d/17-fallback-handler-for-non-matched-routes).
- Enhance per-party custom http errors (now it works on any wildcard path too).
- Add a third parameter on `app.OnError(...)` for custom http errors with regexp validation, see [status_test.go](https://github.com/kataras/iris/blob/v6/status_test.go) for an example.
- Add a `context.ParamIntWildcard(...)` to skip the first slash, useful for wildcarded paths' parameters.

- Shutdown with `app.Shutdown(context.Context) error`, no need for any third-parties, with `EventPolicy.Interrupted` and Go's 1.8 Gracefully Shutdown feature you're ready to go!
- HTTP/2 Go 1.8 `context.Push(target string, opts *http.PushOptions) error` is supported, example can be found [here](https://github.com/kataras/iris/blob/v6/adaptors/websocket/_examples/websocket_secure/main.go)

- Router (two lines to add, new features)
- Template engines (two lines to add, same features as before, except their easier configuration)
- Basic middleware, that have been written by me, are transfared to the main repository[/middleware](https://github.com/kataras/iris/tree/v6/middleware) with a lot of improvements to the `recover middleware` (see the next)
- `func(http.ResponseWriter, r *http.Request, next http.HandlerFunc)` signature is fully compatible using `iris.ToHandler` helper wrapper func, without any need of custom boilerplate code. So all net/http middleware out there are supported, no need to re-invert the world here, search to the internet and you'll find a suitable to your case.

- Load Configuration from an external file, yaml and toml:

	- [yaml-based](http://www.yaml.org/) configuration file using the `iris.YAML` function: `app := iris.New(iris.YAML(""myconfiguration.yaml""))`
	- [toml-based](https://github.com/toml-lang/toml) configuration file using the `iris.TOML` function: `app := iris.New(iris.TOML(""myconfiguration.toml""))`


- Add `.Regex` middleware which does path validation using the `regexp` package, i.e `.Regex(""param"", ""[0-9]+$"")`. Useful for routers that don't support regex route path validation out-of-the-box.

- Websocket additions: `c.Context() *iris.Context`, `ws.GetConnectionsByRoom(""room name"") []websocket.Connection`, `c.OnLeave(func(roomName string){})`, 
```go
		// SetValue sets a key-value pair on the connection's mem store.
		c.SetValue(key string, value interface{})
		// GetValue gets a value by its key from the connection's mem store.
		c.GetValue(key string) interface{}
		// GetValueArrString gets a value as []string by its key from the connection's mem store.
		c.GetValueArrString(key string) []string
		// GetValueString gets a value as string by its key from the connection's mem store.
		c.GetValueString(key string) string
		// GetValueInt gets a value as integer by its key from the connection's mem store.
		c.GetValueInt(key string) int

``` 
[examples here](https://github.com/kataras/iris/blob/v6/adaptors/websocket/_examples). 

Fixes:

- Websocket improvements and fix errors when using custom golang client
- Sessions performance improvements
- Fix cors by using `rs/cors` and add a new adaptor to be able to wrap the entire router
- Fix and improve oauth/oauth2 plugin(now adaptor)
- Improve and fix recover middleware
- Fix typescript compiler and hot-reloader plugin(now adaptor)
- Fix and improve the cloud-editor `alm/alm-tools` plugin(now adaptor)
- Fix gorillamux serve static files (custom routers are supported with a workaround, not a complete solution as they are now)
- Fix `iris run main.go` app reload while user saved the file from gogland
- Fix [StaticEmbedded doesn't works on root ""/""](https://github.com/kataras/iris/issues/633)

Changes:

- `context.TemplateString` replaced with `app.Render(w io.Writer, name string, bind interface{}, options ...map[string]interface{}) error)` which gives you more functionality.

```go
import ""bytes""
// ....
app := iris.New()
// ....

buff := &bytes.Buffer{}
app.Render(buff, ""my_template.html"", nil)
// buff.String() is the template parser's result, use that string to send a rich-text e-mail based on a template.
```

```go
// you can take the app(*Framework instance) via *Context.Framework() too:

app.Get(""/send_mail"", func(ctx *iris.Context){
	buff := &bytes.Buffer{}
	ctx.Framework().Render(buff, ""my_template.html"", nil)
	// ...
})

```
- `.Close() error` replaced with gracefully `.Shutdown(context.Context) error`
- Remove all the package-level functions and variables for a default `*iris.Framework, iris.Default`
- Remove `.API`, use `iris.Handle/.HandleFunc/.Get/.Post/.Put/.Delete/.Trace/.Options/.Use/.UseFunc/.UseGlobal/.Party/` instead
- Remove `.Logger`, `.Config.IsDevelopment`, `.Config.LoggerOut`, `.Config.LoggerPrefix` you can adapt a logger which will log to each log message mode by `app.Adapt(iris.DevLogger())` or adapt a new one, it's just a `func(mode iris.LogMode, message string)`.
- Remove `.Config.DisableTemplateEngines`, are disabled by-default, you have to `.Adapt` a view engine by yourself
- Remove `context.RenderTemplateSource` you should make a new template file and use the `iris.Render` to specify an `io.Writer` like `bytes.Buffer`
- Remove  `plugins`, replaced with more pluggable echosystem that I designed from zero on this release, named `Policy` [Adaptors](https://github.com/kataras/iris/tree/v6/adaptors) (all plugins have been converted, fixed and improvement, except the iriscontrol).
- `context.Log(string,...interface{})` -> `context.Log(iris.LogMode, string)`
- Remove `.Config.DisableBanner`, now it's controlled by `app.Adapt(iris.LoggerPolicy(func(mode iris.LogMode, msg string)))`
- Remove `.Config.Websocket` , replaced with the `kataras/iris/adaptors/websocket.Config` adaptor.

- https://github.com/iris-contrib/plugin      ->  https://github.com/iris-contrib/adaptors

- `import ""github.com/iris-contrib/middleware/basicauth""` -> `import ""gopkg.in/kataras/iris.v6/middleware/basicauth""`
- `import ""github.com/iris-contrib/middleware/i18n""` -> `import ""gopkg.in/kataras/iris.v6/middleware/i18n""`
- `import ""github.com/iris-contrib/middleware/logger""` -> `import ""gopkg.in/kataras/iris.v6/middleware/logger""`
- `import ""github.com/iris-contrib/middleware/recovery""` -> `import ""gopkg.in/kataras/iris.v6/middleware/recover""`


- `import ""github.com/iris-contrib/plugin/typescript""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/typescript""`
- `import ""github.com/iris-contrib/plugin/editor""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/typescript/editor""`
- `import ""github.com/iris-contrib/plugin/cors""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/cors""`
- `import ""github.com/iris-contrib/plugin/gorillamux""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/gorillamux""`
- `import github.com/iris-contrib/plugin/oauth""` -> `import ""github.com/iris-contrib/adaptors/oauth""`


- `import ""github.com/kataras/go-template/html""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/view""`
- `import ""github.com/kataras/go-template/django""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/view""`
- `import ""github.com/kataras/go-template/pug""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/view""`
- `import ""github.com/kataras/go-template/handlebars""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/view""`
- `import ""github.com/kataras/go-template/amber""` -> `import ""gopkg.in/kataras/iris.v6/adaptors/view""`

**Read more below** for the lines you have to change. Package-level removal is critical, you will have build-time errors. Router(less) is MUST, otherwise your app will fatal with a detailed error message.

> If I missed something please [chat](https://kataras.rocket.chat/channel/iris).


### Router(less)

**Iris server does not contain a default router anymore**, yes your eyes are ok.

This decision came up because of your requests of using other routers than the iris' defaulted.
At the past I gave you many workarounds, but they are just workarounds, not a complete solution.

**Don't worry:**

- you have to add only two lines, one is the `import path` and another is the `.Adapt`, after the `iris.New()`, so it can be tolerated.
- you are able to use all iris' features as you used before, **the API for routing has not been changed**.

Two routers available to use, today:


- [httprouter](https://github.com/kataras/iris/tree/v6/adaptors/httprouter), the old defaulted. A router that can be adapted, it's a custom version of https://github.comjulienschmidt/httprouter which is edited to support iris' subdomains, reverse routing, custom http errors and a lot features, it should be a bit faster than the original too because of iris' Context. It uses `/mypath/:firstParameter/path/:secondParameter` and `/mypath/*wildcardParamName` .


Example:

```go
package main

import (
  ""gopkg.in/kataras/iris.v6""
  ""gopkg.in/kataras/iris.v6/adaptors/httprouter"" // <---- NEW
)

func main() {
  app := iris.New()
  app.Adapt(iris.DevLogger())
  app.Adapt(httprouter.New()) // <---- NEW


  app.OnError(iris.StatusNotFound, func(ctx *iris.Context){
    ctx.HTML(iris.StatusNotFound, ""<h1> custom http error page </h1>"")
  })


  app.Get(""/healthcheck"", h)

  gamesMiddleware := func(ctx *iris.Context) {
    println(ctx.Method() + "": "" + ctx.Path())
    ctx.Next()
  }

  games:= app.Party(""/games"", gamesMiddleware)
  { // braces are optional of course, it's just a style of code
	 games.Get(""/:gameID/clans"", h)
	 games.Get(""/:gameID/clans/clan/:publicID"", h)
	 games.Get(""/:gameID/clans/search"", h)

	 games.Put(""/:gameID/players/:publicID"", h)
	 games.Put(""/:gameID/clans/clan/:publicID"", h)

	 games.Post(""/:gameID/clans"", h)
	 games.Post(""/:gameID/players"", h)
	 games.Post(""/:gameID/clans/:publicID/leave"", h)
	 games.Post(""/:gameID/clans/:clanPublicID/memberships/application"", h)
	 games.Post(""/:gameID/clans/:clanPublicID/memberships/application/:action"", h)
	 games.Post(""/:gameID/clans/:clanPublicID/memberships/invitation"", h)
	 games.Post(""/:gameID/clans/:clanPublicID/memberships/invitation/:action"", h)
	 games.Post(""/:gameID/clans/:clanPublicID/memberships/delete"", h)
	 games.Post(""/:gameID/clans/:clanPublicID/memberships/promote"", h)
	 games.Post(""/:gameID/clans/:clanPublicID/memberships/demote"", h)
  }

  app.Get(""/anything/*anythingparameter"", func(ctx *iris.Context){
    s := ctx.Param(""anythingparameter"")
    ctx.Writef(""The path after /anything is: %s"",s)
  })

  app.Listen("":80"")

	/*
		gameID  = 1
		publicID = 2
		clanPublicID = 22
		action = 3

		GET
		http://localhost/healthcheck
		http://localhost/games/1/clans
		http://localhost/games/1/clans/clan/2
		http://localhost/games/1/clans/search

		PUT
		http://localhost/games/1/players/2
		http://localhost/games/1/clans/clan/2

		POST
		http://localhost/games/1/clans
		http://localhost/games/1/players
		http://localhost/games/1/clans/2/leave
		http://localhost/games/1/clans/22/memberships/application -> 494
		http://localhost/games/1/clans/22/memberships/application/3- > 404
		http://localhost/games/1/clans/22/memberships/invitation
		http://localhost/games/1/clans/22/memberships/invitation/3
		http://localhost/games/1/clans/2/memberships/delete
		http://localhost/games/1/clans/22/memberships/promote
		http://localhost/games/1/clans/22/memberships/demote

	*/
}

func h(ctx *iris.Context) {
	ctx.HTML(iris.StatusOK, ""<h1>Path<h1/>""+ctx.Path())
}

```

- [gorillamux](https://github.com/kataras/iris/tree/v6/adaptors/gorillamux), a router that can be adapted, it's the https://github.com/gorilla/mux which supports subdomains, custom http errors, reverse routing, pattern matching via regex and the rest of the iris' features.


Example:

```go
package main

import (
  ""gopkg.in/kataras/iris.v6""
  ""gopkg.in/kataras/iris.v6/adaptors/gorillamux"" // <---- NEW
)

func main() {
  app := iris.New()
  app.Adapt(iris.DevLogger())
  app.Adapt(gorillamux.New()) // <---- NEW


  app.OnError(iris.StatusNotFound, func(ctx *iris.Context){
    ctx.HTML(iris.StatusNotFound, ""<h1> custom http error page </h1>"")
  })


  app.Get(""/healthcheck"", h)

  gamesMiddleware := func(ctx *iris.Context) {
    println(ctx.Method() + "": "" + ctx.Path())
    ctx.Next()
  }

  games:= app.Party(""/games"", gamesMiddleware)
  { // braces are optional of course, it's just a style of code
	 games.Get(""/{gameID:[0-9]+}/clans"", h)
	 games.Get(""/{gameID:[0-9]+}/clans/clan/{publicID:[0-9]+}"", h)
	 games.Get(""/{gameID:[0-9]+}/clans/search"", h)

	 games.Put(""/{gameID:[0-9]+}/players/{publicID:[0-9]+}"", h)
	 games.Put(""/{gameID:[0-9]+}/clans/clan/{publicID:[0-9]+}"", h)

	 games.Post(""/{gameID:[0-9]+}/clans"", h)
	 games.Post(""/{gameID:[0-9]+}/players"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{publicID:[0-9]+}/leave"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{clanPublicID:[0-9]+}/memberships/application"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{clanPublicID:[0-9]+}/memberships/application/:action"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{clanPublicID:[0-9]+}/memberships/invitation"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{clanPublicID:[0-9]+}/memberships/invitation/:action"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{clanPublicID:[0-9]+}/memberships/delete"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{clanPublicID:[0-9]+}/memberships/promote"", h)
	 games.Post(""/{gameID:[0-9]+}/clans/{clanPublicID:[0-9]+}/memberships/demote"", h)
  }

  app.Get(""/anything/{anythingparameter:.*}"", func(ctx *iris.Context){
    s := ctx.Param(""anythingparameter"")
    ctx.Writef(""The path after /anything is: %s"",s)
  })

  app.Listen("":80"")

	/*
		gameID  = 1
		publicID = 2
		clanPublicID = 22
		action = 3

		GET
		http://localhost/healthcheck
		http://localhost/games/1/clans
		http://localhost/games/1/clans/clan/2
		http://localhost/games/1/clans/search

		PUT
		http://localhost/games/1/players/2
		http://localhost/games/1/clans/clan/2

		POST
		http://localhost/games/1/clans
		http://localhost/games/1/players
		http://localhost/games/1/clans/2/leave
		http://localhost/games/1/clans/22/memberships/application -> 494
		http://localhost/games/1/clans/22/memberships/application/3- > 404
		http://localhost/games/1/clans/22/memberships/invitation
		http://localhost/games/1/clans/22/memberships/invitation/3
		http://localhost/games/1/clans/2/memberships/delete
		http://localhost/games/1/clans/22/memberships/promote
		http://localhost/games/1/clans/22/memberships/demote

	*/
}

func h(ctx *iris.Context) {
	ctx.HTML(iris.StatusOK, ""<h1>Path<h1/>""+ctx.Path())
}

```

**No changes whatever router you use**, only the `path` is changed(otherwise it doesn't make sense to support more than one router).
At the `gorillamux`'s path example we get pattern matching using regexp, at the other hand `httprouter` doesn't provides path validations
but it provides parameter and wildcard parameters too, it's also a lot faster than gorillamux.

Original Gorilla Mux made my life easier when I had to adapt the reverse routing and subdomains features, it has got these features by its own too, so it was easy.

Original Httprouter doesn't supports subdomains, multiple paths on different methods, reverse routing, custom http errors, I had to implement
all of them by myself and after adapt them using the policies, it was a bit painful but this is my job. Result: It runs blazy-fast!


As we said, all iris' features works as before even if you are able to adapt any custom router. Template funcs that were relative-closed to reverse router, like `{{ url }} and {{ urlpath }}`, works as before too, no change for your app's side need.


> I would love to see more routers (as more as they can provide different `path declaration` features) from the community, create an adaptor for an iris' router and I will share your repository to the rest of the users!


Adaptors are located [there](https://github.com/kataras/iris/tree/v6/adaptors).

### View engine (5 template engine adaptors)

At the past, If no template engine was used then iris selected the [html standard](https://github.com/kataras/go-template/tree/master/html).

**Now, iris doesn't defaults any template engine** (also the `.Config.DisableTemplateEngines` has been removed, it has no use anymore).

So, again you have to do two changes, the `import path` and the `.Adapt`.

**Template files are no need to change, the template engines does the same exactly things as before**


All of these **five template engines** have common features with common API, like Layout, Template Funcs, Party-specific layout, partial rendering and more.
   - **the standard html**, based on [go-template/html](https://github.com/kataras/go-template/tree/master/html), its template parser is the [html/template](https://golang.org/pkg/html/template/).

   - **django**, based on [go-template/django](https://github.com/kataras/go-template/tree/master/django), its template parser is the [pongo2](https://github.com/flosch/pongo2)

   - **pug**, based on [go-template/pug](https://github.com/kataras/go-template/tree/master/pug), its template parser is the [jade](https://github.com/Joker/jade)

   - **handlebars**, based on [go-template/handlebars](https://github.com/kataras/go-template/tree/master/handlebars), its template parser is the [raymond](https://github.com/aymerick/raymond)

   - **amber**, based on [go-template/amber](https://github.com/kataras/go-template/tree/master/amber), its template parser is the [amber](https://github.com/eknkc/amber).

Each of the template engines has different options, view adaptors are located [here](https://github.com/kataras/iris/tree/v6/adaptors/view).


Example:


```go
package main

import (
	""gopkg.in/kataras/iris.v6""
	""gopkg.in/kataras/iris.v6/adaptors/gorillamux"" // <--- NEW (previous section)
	""gopkg.in/kataras/iris.v6/adaptors/view"" // <--- NEW it contains all the template engines
)

func main() {
	app := iris.New()
	app.Adapt(iris.DevLogger())
	app.Adapt(gorillamux.New()) // <--- NEW (previous section)

  // - standard html  | view.HTML(...)
  // - django         | view.Django(...)
  // - pug(jade)      | view.Pug(...)
  // - handlebars     | view.Handlebars(...)
  // - amber          | view.Amber(...)
	app.Adapt(view.HTML(""./templates"", "".html"").Reload(true)) // <---- NEW (set .Reload to true when you're in dev mode.)

  // default template funcs:
  //
  // - {{ url ""mynamedroute"" ""pathParameter_ifneeded""} }
  // - {{ urlpath ""mynamedroute"" ""pathParameter_ifneeded"" }}
  // - {{ render ""header.html"" }}
  // - {{ render_r ""header.html"" }} // partial relative path to current page
  // - {{ yield }}
  // - {{ current }}
  //
  // to adapt custom funcs, use:
  app.Adapt(iris.TemplateFuncsPolicy{""myfunc"": func(s string) string {
        return ""hi ""+s
  }}) // usage inside template: {{ hi ""kataras""}}

	app.Get(""/hi"", func(ctx *iris.Context) {
		ctx.MustRender(
			""hi.html"",                // the file name of the template relative to the './templates'
			iris.Map{""Name"": ""Iris""}, // the .Name inside the ./templates/hi.html
			iris.Map{""gzip"": false},  // enable gzip for big files
		)

	})

  // http://127.0.0.1:8080/hi
	app.Listen("":8080"")
}


```

`.UseTemplate` have been removed and replaced with the `.Adapt` which is using `iris.RenderPolicy` and `iris.TemplateFuncsPolicy`
to adapt the behavior of the custom template engines.

**BEFORE**
```go
import ""github.com/kataras/go-template/django""
// ...
app := iris.New()
app.UseTemplate(django.New()).Directory(""./templates"", "".html"")/*.Binary(...)*/)
```

**AFTER**
```go
import """"gopkg.in/kataras/iris.v6/adaptors/view""
// ...
app := iris.New()
app.Adapt(view.Django(""./templates"","".htmll"")/*.Binary(...)*/)
```

The rest remains the same. Don't forget the real changes were `only import path and .Adapt(imported)`, at general when you see an 'adaptor' these two declarations should happen to your code.



### Package-level functions and variables for `iris.Default` have been removed.

The form of variable use for an Iris *Framework remains as it was:
```go
app := iris.New()
app.$FUNCTION/$VARIABLE
```


> When I refer to `iris.$FUNCTION/$VARIABLE` it means `iris.Handle/.HandleFunc/.Get/.Post/.Put/.Delete/.Trace/.Options/.Use/.UseFunc/.UseGlobal/.Party/.Set/.Config`
and the rest of the package-level functions referred to the `iris.Default` variable.

**BEFORE**

```go
iris.Config.FireMethodNotAllowed = true
iris.Set(OptionDisableBodyConsumptionOnUnmarshal(true))
```

```go
iris.Get(""/"", func(ctx *iris.Context){

})

iris.ListenLETSENCRYPT("":8080"")
```

**AFTER**


```go
app := iris.New()
app.Config.FireMethodNotAllowed = true
// or iris.Default.Config.FireMethodNotAllowed = true and so on
app.Set(OptionDisableBodyConsumptionOnUnmarshal(true))
// same as
// app := iris.New(iris.Configuration{FireMethodNotAllowed:true, DisableBodyConsumptionOnUnmarshal:true})
```

```go
app := iris.New()
app.Get(""/"", func(ctx *iris.Context){

})

app.ListenLETSENCRYPT("":8080"")
```

For those who had splitted the application in different packages they could do just that `iris.$FUNCTION/$VARIABLE` without the need
of import a singleton package which would initialize a new `App := iris.New()`.

`Iris.Default` remains, so you can refer to that if you don't want to initialize a new `App := iris.New()` by your own.

**BEFORE**

```go
package controllers
import ""github.com/kataras/iris""
func init(){
   iris.Get(""/"", func(ctx *iris.Context){

   })
}
```

```go
package main

import (
  ""github.com/kataras/iris""
   _ ""github.com/mypackage/controllers""
)

func main(){
	iris.Listen("":8080"")
}
```


**AFTER**

```go
package controllers

import (
  ""gopkg.in/kataras/iris.v6""
  ""gopkg.in/kataras/iris.v6/adaptors/httprouter""
)

func init(){
   iris.Default.Adapt(httprouter.New())
   iris.Default.Get(""/"", func(ctx *iris.Context){

   })
}
```

```go
package main

import (
  ""gopkg.in/kataras/iris.v6""
   _ ""github.com/mypackage/controllers""
)

func main(){
 iris.Default.Listen("":8080"")
}
```

You got the point, let's continue to the next conversion.

### Remove the slow .API | iris.API(...) / app := iris.New(); app.API(...)


The deprecated `.API` has been removed entirely, it should be removed after v5(look on the v5 history tag).

At first I created that func in order to give newcovers a chance to be able to quick start a new `controller-like`
with one function, but that function was using generics at runtime and it was very slow compared to the
`iris.Handle/.HandleFunc/.Get/.Post/.Put/.Delete/.Trace/.Options/.Use/.UseFunc/.UseGlobal/.Party`.

Also some users they used only `.API`, they didn't bother to 'learn' about the standard rest api functions
and their power(including per-route middleware, cors, recover and so on). So we had many unrelational questions about the `.API` func.


**BEFORE**

```go
package main

import (
	""github.com/kataras/iris""
)

type UserAPI struct {
	*iris.Context
}

// GET /users
func (u UserAPI) Get() {
	u.Writef(""Get from /users"")
	// u.JSON(iris.StatusOK,myDb.AllUsers())
}

// GET /users/:param1 which its value passed to the id argument
func (u UserAPI) GetBy(id string) { // id equals to u.Param(""param1"")
	u.Writef(""Get from /users/%s"", id)
	// u.JSON(iris.StatusOK, myDb.GetUserById(id))

}

// POST /users
func (u UserAPI) Post() {
	name := u.FormValue(""name"")
	// myDb.InsertUser(...)
	println(string(name))
	println(""Post from /users"")
}

// PUT /users/:param1
func (u UserAPI) PutBy(id string) {
	name := u.FormValue(""name"") // you can still use the whole Context's features!
	// myDb.UpdateUser(...)
	println(string(name))
	println(""Put from /users/"" + id)
}

// DELETE /users/:param1
func (u UserAPI) DeleteBy(id string) {
	// myDb.DeleteUser(id)
	println(""Delete from /"" + id)
}

func main() {

	iris.API(""/users"", UserAPI{})
	iris.Listen("":8080"")
}

```


**AFTER**

```go
package main

import (
	""gopkg.in/kataras/iris.v6""
  ""gopkg.in/kataras/iris.v6/adaptors/gorillamux""
)

func  GetAllUsersHandler(ctx *iris.Context) {
	ctx.Writef(""Get from /users"")
	// ctx.JSON(iris.StatusOK,myDb.AllUsers())
}

func GetUserByIdHandler(ctx *iris.Context) {
	ctx.Writef(""Get from /users/%s"",
	  ctx.Param(""id"")) 	// or id, err := ctx.ParamInt(""id"")
	// ctx.JSON(iris.StatusOK, myDb.GetUserById(id))
}

func InsertUserHandler(ctx *iris.Context){
	name := ctx.FormValue(""name"")
	// myDb.InsertUser(...)
	println(string(name))
	println(""Post from /users"")
}

func UpdateUserHandler(ctx *iris.Context) {
	name := ctx.FormValue(""name"")
	// myDb.UpdateUser(...)
	println(string(name))
	println(""Put from /users/"" + ctx.Param(""id""))
}

func  DeleteUserById(id string) {
	// myDb.DeleteUser(id)
	println(""Delete from /"" + ctx.param(""id""))
}

func main() {
	app := iris.New()
  app.Adapt(gorillamux.New())

	// create a new router targeted for ""/users"" path prefix
	// you can learn more about Parties on the examples and book too
	// they can share middleware, template layout and more.
	userRoutes := app.Party(""users"")

	// GET  http://localhost:8080/users/ and /users
	userRoutes.Get(""/"", GetAllUsersHandler)

	// GET  http://localhost:8080/users/:id
	userRoutes.Get(""/:id"", GetUserByIdHandler)
	// POST  http://localhost:8080/users
	userRoutes.Post(""/"", InsertUserHandler)

	// PUT  http://localhost:8080/users/:id
	userRoutes.Put(""/:id"", UpdateUserHandler)

	// DELETE http://localhost:8080/users/:id
	userRoutes.Delete(""/:id"", DeleteUserById)

  app.Listen("":8080"")
}

```

### Old Plugins and the new `.Adapt` Policies

A lot of changes to old -so-called Plugins and many features have been adopted to this new ecosystem.


First of all plugins renamed to `policies with adaptors which, adaptors, adapts the policies to the framework`
(it is not just a simple rename of the word, it's a new concept).


Policies are declared inside Framework, they are implemented outside of the Framework and they are adapted to Framework by a user call.

Policy adaptors are just like a plugins but they have to implement a specific action/behavior to a specific policy type(or more than one at the time).

The old plugins are fired 'when something happens do that' (ex: PreBuild,PostBuild,PreListen and so on) this behavior is the new `EventPolicy`
which has **4 main flow events** with their callbacks been wrapped, so you can use more than EventPolicy (most of the policies works this way).

```go
type (
	// EventListener is the signature for type of func(*Framework),
	// which is used to register events inside an EventPolicy.
	//
	// Keep note that, inside the policy this is a wrapper
	// in order to register more than one listener without the need of slice.
	EventListener func(*Framework)

	// EventPolicy contains the available Framework's flow event callbacks.
	// Available events:
	// - Boot
	// - Build
	// - Interrupted
	// - Recovery
	EventPolicy struct {
		// Boot with a listener type of EventListener.
		//   Fires when '.Boot' is called (by .Serve functions or manually),
		//   before the Build of the components and the Listen,
		//   after VHost and VSCheme configuration has been setted.
		Boot EventListener
		// Before Listen, after Boot
		Build EventListener
		// Interrupted with a listener type of EventListener.
		//   Fires after the terminal is interrupted manually by Ctrl/Cmd + C
		//   which should be used to release external resources.
		// Iris will close and os.Exit at the end of custom interrupted events.
		// If you want to prevent the default behavior just block on the custom Interrupted event.
		Interrupted EventListener
		// Recovery with a listener type of func(*Framework,error).
		//   Fires when an unexpected error(panic) is happening at runtime,
		//   while the server's net.Listener accepting requests
		//   or when a '.Must' call contains a filled error.
		//   Used to release external resources and '.Close' the server.
		//   Only one type of this callback is allowed.
		//
		//   If not empty then the Framework will skip its internal
		//   server's '.Close' and panic to its '.Logger' and execute that callback instaed.
		//   Differences from Interrupted:
		//    1. Fires on unexpected errors
		//    2. Only one listener is allowed.
		Recovery func(*Framework, error)
	}
)
```

**A quick overview on how they can be adapted** to an iris *Framework (iris.New()'s result).
Let's adapt `EventPolicy`:

```go
app := iris.New()

evts := iris.EventPolicy{
  // we ommit the *Framework's variable name because we have already the 'app'
  // if we were on different file with no access to the 'app' then the varialbe name will be useful.
  Boot: func(*Framework){
      app.Log(""Here you can change any field and configuration for iris before being used
        also you can adapt more policies that should be used to the next step which is the Build and Listen,
        only the app.Config.VHost and  app.Config.VScheme have been setted here, but you can change them too\n"")
  },
  Build: func(*Framework){
    app.Log(""Here all configuration and all app' fields and features  have been builded, here you are ready to call
      anything (you shouldn't change fields and configuration here)\n"")
  },
}
// Adapt the EventPolicy 'evts' to the Framework
app.Adapt(evts)

// let's register one more
app.Adapt(iris.EventPolicy{
  Boot: func(*Framework){
      app.Log(""the second log message from .Boot!\n"")
}})

// you can also adapt multiple and different(or same) types of policies in the same call
// using: app.Adapt(iris.EventPolicy{...}, iris.LoggerPolicy(...), iris.RouterWrapperPolicy(...))

// starts the server, executes the Boot -> Build...
app.Adapt(httprouter.New()) // read below for this line
app.Listen("":8080"")
```



This pattern allows us to be very pluggable and add features that the *Framework itself doesn't knows,
it knows only the main policies which implement but their features are our(as users) business.


We have 8 policies, so far, and some of them have 'subpolicies' (the RouterReversionPolicy for example).

- LoggerPolicy
- EventPolicy
     - Boot
     - Build
     - Interrupted
     - Recover
- RouterReversionPolicy
     - StaticPath
     - WildcardPath
	 - Param
     - URLPath
- RouterBuilderPolicy
- RouterWrapperPolicy
- RenderPolicy
- TemplateFuncsPolicy
- SessionsPolicy


**Details** of these can be found at [policy.go](https://github.com/kataras/iris/blob/v6/policy.go).

The **Community**'s adaptors are [here](https://github.com/iris-contrib/adaptors).

**Iris' Built'n Adaptors** for these policies can be found at [/adaptors folder](https://github.com/kataras/iris/tree/v6/adaptors).

The folder contains:

- cors, a cors (router) wrapper based on `rs/cors`.
It's a `RouterWrapperPolicy`

- gorillamux, a router that can be adapted, it's the `gorilla/mux` which supports subdomains, custom http errors, reverse routing, pattern matching.
It's a compination of`EventPolicy`, `RouterReversionPolicy with StaticPath, WildcardPath, URLPath, RouteContextLinker` and the `RouterBuilderPolicy`.

- httprouter, a router that can be adapted, it's a custom version of `julienschmidt/httprouter` which is edited to support iris' subdomains, reverse routing, custom http errors and a lot features, it should be a bit faster than the original too.
It's a compination of`EventPolicy`, `RouterReversionPolicy with StaticPath, WildcardPath, URLPath, RouteContextLinker` and the `RouterBuilderPolicy`.


- typescript and cloud editor, contains the typescript compiler with hot reload feature and a typescript cloud editor ([alm-tools](https://github.com/alm-tools/alm)), it's an `EventPolicy`

- view, contains 5 template engines based on the `kataras/go-template`.
All of these have common features with common API, like Layout, Template Funcs, Party-specific layout, partial rendering and more.
It's a `RenderPolicy` with a compinaton of `EventPolicy` and use of `TemplateFuncsPolicy`.
   - the standard html
   - pug(jade)
   - django(pongo2)
   - handlebars
   - amber.





#### Note
Go v1.8 introduced a new plugin system with `.so` files, users should not be confused with old iris' plugins and new adaptors.
It is not ready for all operating systems(yet) when it will be ready, Iris will take leverage of this Golang's feature.


### http.Handler and third-party middleware

We were compatible before this version but if a third-party middleware had the form of:
`func(http.ResponseWriter, *http.Request, http.HandlerFunc)`you were responsible of make a wrapper
which would return an `iris.Handler/HandlerFunc`.

Now you're able to pass an `func(http.ResponseWriter, *http.Request, http.HandlerFunc)` third-party net/http middleware(Chain-of-responsibility pattern)  using the `iris.ToHandler` wrapper func without any other custom boilerplate.

Example:

```go
package main

import (
	""gopkg.in/kataras/iris.v6""
  ""gopkg.in/kataras/iris.v6/adaptors/gorillamux""
	""github.com/rs/cors""
)

// myCors returns a new cors middleware
// with the provided options.
myCors := func(opts cors.Options) iris.HandlerFunc {
  handlerWithNext := cors.New(opts).ServeHTTP
	return iris.ToHandler(handlerWithNext)
}

func main(){
   app := iris.New()
   app.Adapt(httprouter.New())

   app.Post(""/user"", myCors(cors.Options{}), func(ctx *iris.Context){
     // ....
   })

   app.Listen("":8080"")
}

```

-  Irrelative info but this is the best place to put it: `iris/app.AcquireCtx/.ReleaseCtx` replaced to: `app.Context.Acquire/.Release/.Run`.



### iris cmd

- FIX: [iris run main.go](https://github.com/kataras/iris/tree/v6/iris#run) not reloading when file changes maden by some of the IDEs,
because they do override the operating system's fs signals. The majority of
editors worked before but I couldn't let some developers without support.


### Sessions


Sessions manager is also an Adaptor now, `iris.SessionsPolicy`.
So far we used the `kataras/go-sessions`, you could always use other session manager ofcourse but you would lose the `context.Session()`
and its returning value, the `iris.Session` now.

`SessionsPolicy` gives the developers the opportunity to adapt any,
compatible with a particular simple interface(Start and Destroy methods), third-party sessions managers.

- The API for sessions inside context is the same, no  matter what session manager you wanna to adapt.
- The API for sessions inside context didn't changed, it's the same as you knew it.

- Iris, of course, has built'n `SessionsPolicy` adaptor(the kataras/go-sessions: edited to remove fasthttp dependencies).
    - Sessions manager works even faster now and a bug fixed for some browsers.

- Functions like, adding a database or store(i.e: `UseDatabase`) depends on the session manager of your choice,
Iris doesn't requires these things
to adapt a package as a session manager. So `iris.UseDatabase` has been removed and depends on the `mySessions.UseDatabase` you 'll see below.

- `iris.DestroySessionByID and iris.DestroyAllSessions` have been also removed, depends on the session manager of your choice, `mySessions.DestroyByID and mySessions.DestroyAll`  should do the job now.


> Don't worry about forgetting to adapt any feature that you use inside Iris, Iris will print you a how-to-fix message at iris.DevMode log level.


**[Examples folder](https://github.com/kataras/iris/tree/v6/adaptors/sessions/_examples)**



```go
package main

import (
	""time""

	""gopkg.in/kataras/iris.v6""
	""gopkg.in/kataras/iris.v6/adaptors/httprouter""
	""gopkg.in/kataras/iris.v6/adaptors/sessions""
)

func main() {
	app := iris.New()
	app.Adapt(iris.DevLogger()) // enable all (error) logs
	app.Adapt(httprouter.New()) // select the httprouter as the servemux

	mySessions := sessions.New(sessions.Config{
		// Cookie string, the session's client cookie name, for example: ""mysessionid""
		//
		// Defaults to ""irissessionid""
		Cookie: ""mysessionid"",
		// base64 urlencoding,
		// if you have strange name cookie name enable this
		DecodeCookie: false,
		// it's time.Duration, from the time cookie is created, how long it can be alive?
		// 0 means no expire.
		// -1 means expire when browser closes
		// or set a value, like 2 hours:
		Expires: time.Hour * 2,
		// the length of the sessionid's cookie's value
		CookieLength: 32,
		// if you want to invalid cookies on different subdomains
		// of the same host, then enable it
		DisableSubdomainPersistence: false,
	})

	// OPTIONALLY:
	// import ""gopkg.in/kataras/iris.v6/adaptors/sessions/sessiondb/redis""
	// or import ""github.com/kataras/go-sessions/sessiondb/$any_available_community_database""
	// mySessions.UseDatabase(redis.New(...))

	app.Adapt(mySessions) // Adapt the session manager we just created.

	app.Get(""/"", func(ctx *iris.Context) {
		ctx.Writef(""You should navigate to the /set, /get, /delete, /clear,/destroy instead"")
	})
	app.Get(""/set"", func(ctx *iris.Context) {

		//set session values
		ctx.Session().Set(""name"", ""iris"")

		//test if setted here
		ctx.Writef(""All ok session setted to: %s"", ctx.Session().GetString(""name""))
	})

	app.Get(""/get"", func(ctx *iris.Context) {
		// get a specific key, as string, if no found returns just an empty string
		name := ctx.Session().GetString(""name"")

		ctx.Writef(""The name on the /set was: %s"", name)
	})

	app.Get(""/delete"", func(ctx *iris.Context) {
		// delete a specific key
		ctx.Session().Delete(""name"")
	})

	app.Get(""/clear"", func(ctx *iris.Context) {
		// removes all entries
		ctx.Session().Clear()
	})

	app.Get(""/destroy"", func(ctx *iris.Context) {

		//destroy, removes the entire session and cookie
		ctx.SessionDestroy()
		msg := ""You have to refresh the page to completely remove the session (browsers works this way, it's not iris-specific.)""

		ctx.Writef(msg)
		ctx.Log(iris.DevMode, msg)
	}) // Note about destroy:
	//
	// You can destroy a session outside of a handler too, using the:
	// mySessions.DestroyByID
	// mySessions.DestroyAll

	app.Listen("":8080"")
}

```

### Websockets

There are many internal improvements to the websocket server, it
operates slighty faster to.


Websocket is an Adaptor too and you can edit more configuration fields than before.
No Write and Read timeout by default, you have to set the fields if you want to enable timeout.

Below you'll see the before and the after, keep note that the static and templates didn't changed, so I am not putting the whole
html and javascript sources here, you can run the full examples from [here](https://github.com/kataras/iris/tree/v6/adaptors/websocket/_examples).

**BEFORE:***

```go

package main

import (
	""fmt"" // optional

	""github.com/kataras/iris""
)

type clientPage struct {
	Title string
	Host  string
}

func main() {
	iris.StaticWeb(""/js"", ""./static/js"")

	iris.Get(""/"", func(ctx *iris.Context) {
		ctx.Render(""client.html"", clientPage{""Client Page"", ctx.Host()})
	})

	// the path which the websocket client should listen/registered to ->
	iris.Config.Websocket.Endpoint = ""/my_endpoint""
	// by-default all origins are accepted, you can change this behavior by setting:
	// iris.Config.Websocket.CheckOrigin

	var myChatRoom = ""room1""
	iris.Websocket.OnConnection(func(c iris.WebsocketConnection) {
		// Request returns the (upgraded) *http.Request of this connection
		// avoid using it, you normally don't need it,
		// websocket has everything you need to authenticate the user BUT if it's necessary
		// then  you use it to receive user information, for example: from headers.

		// httpRequest := c.Request()
		// fmt.Printf(""Headers for the connection with ID: %s\n\n"", c.ID())
		// for k, v := range httpRequest.Header {
		// fmt.Printf(""%s = '%s'\n"", k, strings.Join(v, "", ""))
		// }

		// join to a room (optional)
		c.Join(myChatRoom)

		c.On(""chat"", func(message string) {
			if message == ""leave"" {
				c.Leave(myChatRoom)
				c.To(myChatRoom).Emit(""chat"", ""Client with ID: ""+c.ID()+"" left from the room and cannot send or receive message to/from this room."")
				c.Emit(""chat"", ""You have left from the room: ""+myChatRoom+"" you cannot send or receive any messages from others inside that room."")
				return
			}
			// to all except this connection ->
			// c.To(iris.Broadcast).Emit(""chat"", ""Message from: ""+c.ID()+""-> ""+message)
			// to all connected clients: c.To(iris.All)

			// to the client itself ->
			//c.Emit(""chat"", ""Message from myself: ""+message)

			//send the message to the whole room,
			//all connections are inside this room will receive this message
			c.To(myChatRoom).Emit(""chat"", ""From: ""+c.ID()+"": ""+message)
		})

		// or create a new leave event
		// c.On(""leave"", func() {
		// 	c.Leave(myChatRoom)
		// })

		c.OnDisconnect(func() {
			fmt.Printf(""Connection with ID: %s has been disconnected!\n"", c.ID())

		})
	})

	iris.Listen("":8080"")
}



```


**AFTER**
```go
package main

import (
	""fmt"" // optional

	""gopkg.in/kataras/iris.v6""
	""gopkg.in/kataras/iris.v6/adaptors/httprouter""
	""gopkg.in/kataras/iris.v6/adaptors/view""
	""gopkg.in/kataras/iris.v6/adaptors/websocket""
)

type clientPage struct {
	Title string
	Host  string
}

func main() {
	app := iris.New()
	app.Adapt(iris.DevLogger())                  // enable all (error) logs
	app.Adapt(httprouter.New())                  // select the httprouter as the servemux
	app.Adapt(view.HTML(""./templates"", "".html"")) // select the html engine to serve templates

	ws := websocket.New(websocket.Config{
		// the path which the websocket client should listen/registered to,
		Endpoint: ""/my_endpoint"",
		// the client-side javascript static file path
		// which will be served by Iris.
		// default is /iris-ws.js
		// if you change that you have to change the bottom of templates/client.html
		// script tag:
		ClientSourcePath: ""/iris-ws.js"",
		//
		// Set the timeouts, 0 means no timeout
		// websocket has more configuration, go to ../../config.go for more:
		// WriteTimeout: 0,
		// ReadTimeout:  0,
		// by-default all origins are accepted, you can change this behavior by setting:
		// CheckOrigin: (r *http.Request ) bool {},
		//
		//
		// IDGenerator used to create (and later on, set)
		// an ID for each incoming websocket connections (clients).
		// The request is an argument which you can use to generate the ID (from headers for example).
		// If empty then the ID is generated by DefaultIDGenerator: randomString(64):
		// IDGenerator func(ctx *iris.Context) string {},
	})

	app.Adapt(ws) // adapt the websocket server, you can adapt more than one with different Endpoint

	app.StaticWeb(""/js"", ""./static/js"") // serve our custom javascript code

	app.Get(""/"", func(ctx *iris.Context) {
		ctx.Render(""client.html"", clientPage{""Client Page"", ctx.Host()})
	})

	var myChatRoom = ""room1""

	ws.OnConnection(func(c websocket.Connection) {
		// Context returns the (upgraded) *iris.Context of this connection
		// avoid using it, you normally don't need it,
		// websocket has everything you need to authenticate the user BUT if it's necessary
		// then  you use it to receive user information, for example: from headers.

		// ctx := c.Context()

		// join to a room (optional)
		c.Join(myChatRoom)

		c.On(""chat"", func(message string) {
			if message == ""leave"" {
				c.Leave(myChatRoom)
				c.To(myChatRoom).Emit(""chat"", ""Client with ID: ""+c.ID()+"" left from the room and cannot send or receive message to/from this room."")
				c.Emit(""chat"", ""You have left from the room: ""+myChatRoom+"" you cannot send or receive any messages from others inside that room."")
				return
			}
			// to all except this connection ->
			// c.To(websocket.Broadcast).Emit(""chat"", ""Message from: ""+c.ID()+""-> ""+message)
			// to all connected clients: c.To(websocket.All)

			// to the client itself ->
			//c.Emit(""chat"", ""Message from myself: ""+message)

			//send the message to the whole room,
			//all connections are inside this room will receive this message
			c.To(myChatRoom).Emit(""chat"", ""From: ""+c.ID()+"": ""+message)
		})

		// or create a new leave event
		// c.On(""leave"", func() {
		// 	c.Leave(myChatRoom)
		// })

		c.OnDisconnect(func() {
			fmt.Printf(""Connection with ID: %s has been disconnected!\n"", c.ID())
		})
	})

	app.Listen("":8080"")
}

```




If the iris' websocket feature does not cover your app's needs, you can simply use any other
library for websockets that you used to use, like the Golang's compatible to `socket.io`, simple example:

```go
package main

import (
     ""log""

    ""gopkg.in/kataras/iris.v6""
    ""gopkg.in/kataras/iris.v6/adaptors/httprouter""
    ""github.com/googollee/go-socket.io""
)

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())
    server, err := socketio.NewServer(nil)
    if err != nil {
        log.Fatal(err)
    }
    server.On(""connection"", func(so socketio.Socket) {
        log.Println(""on connection"")
        so.Join(""chat"")
        so.On(""chat message"", func(msg string) {
            log.Println(""emit:"", so.Emit(""chat message"", msg))
            so.BroadcastTo(""chat"", ""chat message"", msg)
        })
        so.On(""disconnection"", func() {
            log.Println(""on disconnect"")
        })
    })
    server.On(""error"", func(so socketio.Socket, err error) {
        log.Println(""error:"", err)
    })

    app.Any(""/socket.io"", iris.ToHandler(server))

    app.Listen("":5000"")
}
```

### Typescript compiler and cloud-based editor

The Typescript compiler adaptor(old 'plugin') has been fixed (it had an issue on new typescript versions).
Example can be bound [here](https://github.com/kataras/iris/tree/v6/adaptors/typescript/_example).

The Cloud-based editor adaptor(old 'plugin') also fixed and improved to show debug messages to your iris' LoggerPolicy.
Example can be bound [here](https://github.com/kataras/iris/tree/v6/adaptors/typescript/editor/_example).

Their import paths also changed as the rest of the old plugins from: https://github.com/iris-contrib/plugin to https://github.com/kataras/adaptors and https://github.com/iris-contrib/adaptors
I had them on iris-contrib because I thought that community would help but it didn't, no problem, they are at the same codebase now
which making things easier to debug for me.


### Oauth/OAuth2
Fix the oauth/oauth2 adaptor (old 'plugin') .
Example can be found [here](https://github.com/iris-contrib/adaptors/tree/master/oauth/_example).


### CORS Middleware and the new Wrapper

Lets speak about history of cors middleware, almost all the issues users reported to the iris-contrib/middleware repository
were relative to the CORS middleware, some users done it work some others don't... it was strange. Keep note that this was one of the two middleware that I didn't
wrote by myself, it was a PR by a member who wrote that middleware and after didn't answer on users' issues.

Forget about it I removed it entirely and replaced with the `rs/cors`: we now use the https://github.com/rs/cors in two forms:

First, you can use the original middlare that you can install by `go get -u github.com/rs/cors`
(You had already see its example on the net/http handlers and iris.ToHandler section)

Can be registered globally or per-route but the `MethodsAllowed option doesn't works`.

Example:

```go
package main

import (
	""gopkg.in/kataras/iris.v6""
  ""gopkg.in/kataras/iris.v6/adaptors/gorillamux""
	""github.com/rs/cors""
)

func main(){
   app := iris.New()
   app.Adapt(httprouter.New()) // see below for that
   corsMiddleware := iris.ToHandler(cors.Default().ServeHTTP)
   app.Post(""/user"", corsMiddleware, func(ctx *iris.Context){
     // ....
   })

   app.Listen("":8080"")
}
```

Secondly, probably the one which you will choose to use, is the `cors` Router Wrapper Adaptor.
It's already installed when you install iris because it's located at `kataras/iris/adaptors/cors`.

This will wrap the entirely router so the whole of your app will be passing by the rules you setted up on its `cors.Options`.

Again, it's functionality comes from the well-tested `rs/cors`, all known Options are working as expected.

Example:

```go
package main

import (
    ""gopkg.in/kataras/iris.v6""
    ""gopkg.in/kataras/iris.v6/adaptors/httprouter""
    ""gopkg.in/kataras/iris.v6/adaptors/cors""
)

func main(){
   app := iris.New()
   app.Adapt(httprouter.New()) // see below for that
   app.Adapt(cors.New(cors.Options{})) // or cors.Default()

   app.Post(""/user"", func(ctx *iris.Context){
     // ....
   })

   app.Listen("":8080"")
}

```",,,,https://api.github.com/repos/kataras/iris/releases/6595285/assets,https://api.github.com/repos/kataras/iris/releases/6595285,v6,https://api.github.com/repos/kataras/iris/tarball/v6.2,https://github.com/kataras/iris/releases/tag/v6.2,https://api.github.com/repos/kataras/iris/zipball/v6.2,v6.2,False,False
5520652,2017-02-21T13:02:50Z,2017-02-21T13:03:52Z,v5,"## [v4](https://github.com/kataras/iris/tree/4.0.0) -> [v5](https://github.com/kataras/iris/tree/5.0.0)

21 Feb 2017: Fix HTML and Text after last go-serializer changes, as reported [here](https://github.com/kataras/go-serializer/issues/1)
- Some not-so-important fixes on websockets, sessions and cli
- **More on Transactions vol 3**: Recovery from any (unexpected error) panics inside `context.BeginTransaction` without loud, continue the execution as expected. Next version will have a little cleanup if I see that the transactions code is going very large or hard to understand the flow*
- **More on Transactions vol 2**: Added **iris.UseTransaction** and **iris.DoneTransaction** to register transactions as you register middleware(handlers). new named type **iris.TransactionFunc**, shortcut of `func(scope *iris.TransactionScope)`, that gives you a function which you can convert a transaction to a normal handler/middleware using its `.ToMiddleware()`, for more see the `test code inside context_test.go:TestTransactionsMiddleware`.

Two hours after the previous update,
- **More on Transactions**: By-default transaction's lifetime is 'per-call/transient' meaning that each transaction has its own scope on the context, rollbacks when `scope.Complete(notNilAndNotEmptyError)` and the rest of transactions in chain are executed as expected, from now and on you have the ability to `skip the rest of the next transactions on first failure` by simply call `scope.RequestScoped(true)`.

Note: `RequestTransactionScope` renamed to ,simply, `TransactionScope`.
- **NEW (UNIQUE?) FEATURE**: Request-scoped transactions inside handler's context. Proof-of-concept example [here](https://github.com/iris-contrib/examples/tree/master/transactions).

The use of `iris.BodyDecoder` as a custom decoder that you can implement to a type in order to be used as the decoder/binder for the request body and override the json.Unmarshal(`context.ReadJSON`) or xml.Unmarshal(`context.ReadXML`) was very useful and gave you some kind of **per-type-binder** extensibility.

**NEW** `context.UnmarshalBody`: **Per-service-binder**. Side by side with the `iris.BodyDecoder`. We now have a second way to pass a custom `Unmarshaler` to override the `json.Unmarshal` and `xml.Unmarshal`.

 If the object doesn't implements the `iris.BodyDecoder` but you still want to implement your own algorithm to parse []byte as an 'object' instead of the iris' defaults.

``` go
 type Unmarshaler interface {
    Unmarshal(data []byte, v interface{}) error
 }

```

`context.ReadJSON & context.ReadXML` have been also refactored to work with this interface and the new `context.DeodeBody` function, look:

``` go
// ReadJSON reads JSON from request's body
// and binds it to a value of any json-valid type
func (ctx *Context) ReadJSON(jsonObject interface{}) error {
    return ctx.UnmarshalBody(jsonObject, UnmarshalerFunc(json.Unmarshal))
}

// ReadXML reads XML from request's body
// and binds it to a value of any xml-valid type
func (ctx *Context) ReadXML(xmlObject interface{}) error {
    return ctx.UnmarshalBody(xmlObject, UnmarshalerFunc(xml.Unmarshal))
}

```

Both  `encoding/json` and `encoding/xml` standard packages have valid `Unmarshal function` so they can be used as `iris.Unmarshaller` (with the help of `iris.UnmarshallerFunc` which just converts the signature to the `iris.Unmarshaller` interface). You only have to implement one function and it will work with any 'object' passed to the `UnmarshalBody` even if the object doesn't implements the `iris.BodyDecoder`.
- Fix `https relative redirect paths`, a very old issue, which I just saw, peaceful, again :)
- [geekypanda/httpcache](https://github.com/geekypanda/httpcache) has been re-written,
  by me, got rid of the mutex locks and use individual statcks instead,
  gain even more performance boost
- `InvalidateCache` has been removed,
  it wasn't working well for big apps, let cache work with
  its automation, is better.
- Add tests for the `iris.Cache`

## v3 -> [v4](https://github.com/kataras/iris/tree/4.0.0) (fasthttp-based) long term support
- **NEW FEATURE**: `CacheService` simple, cache service for your app's static body content(can work as external service if you are doing horizontal scaling, the `Cache` is just a `Handler` :) )

Cache any content, templates, static files, even the error handlers, anything.

> Bombardier: 5 million requests and 100k clients per second to this markdown  static content(look below) with cache(3 seconds) can be served up to ~x12 times faster. Imagine what happens with bigger content like full page and templates!

**OUTLINE**

``` go

// Cache is just a wrapper for a route's handler which you want to enable body caching
// Usage: iris.Get(""/"", iris.Cache(func(ctx *iris.Context){
//    ctx.WriteString(""Hello, world!"") // or a template or anything else
// }, time.Duration(10*time.Second))) // duration of expiration
// if <=time.Second then it tries to find it though request header's ""cache-control"" maxage value
//
// Note that it depends on a station instance's cache service.
// Do not try to call it from default' station if you use the form of app := iris.New(),
// use the app.Cache instead of iris.Cache
Cache(bodyHandler HandlerFunc, expiration time.Duration) HandlerFunc

// InvalidateCache clears the cache body for a specific context's url path(cache unique key)
//
// Note that it depends on a station instance's cache service.
// Do not try to call it from default' station if you use the form of app := iris.New(),
// use the app.InvalidateCache instead of iris.InvalidateCache
InvalidateCache(ctx *Context)


```

**OVERVIEW**

``` go
iris.Get(""/hi"", iris.Cache(func(c *iris.Context) {
    c.WriteString(""Hi this is a big content, do not try cache on small content it will not make any significant difference!"")
}, time.Duration(10)*time.Second))

```

[EXAMPLE](https://github.com/iris-contrib/examples/tree/master/cache_body):

``` go
package main

import (
    ""github.com/kataras/iris""
    ""time""
)

var testMarkdownContents = `## Hello Markdown from Iris

This is an example of Markdown with Iris



Features
--------

All features of Sundown are supported, including:

*   **Compatibility**. The Markdown v1.0.3 test suite passes with
    the --tidy option.  Without --tidy, the differences are
    mostly in whitespace and entity escaping, where blackfriday is
    more consistent and cleaner.

*   **Common extensions**, including table support, fenced code
    blocks, autolinks, strikethroughs, non-strict emphasis, etc.

*   **Safety**. Blackfriday is paranoid when parsing, making it safe
    to feed untrusted user input without fear of bad things
    happening. The test suite stress tests this and there are no
    known inputs that make it crash.  If you find one, please let me
    know and send me the input that does it.

    NOTE: ""safety"" in this context means *runtime safety only*. In order to
    protect yourself against JavaScript injection in untrusted content, see
    [this example](https://github.com/russross/blackfriday#sanitize-untrusted-content).

*   **Fast processing**. It is fast enough to render on-demand in
    most web applications without having to cache the output.

*   **Thread safety**. You can run multiple parsers in different
    goroutines without ill effect. There is no dependence on global
    shared state.

*   **Minimal dependencies**. Blackfriday only depends on standard
    library packages in Go. The source code is pretty
    self-contained, so it is easy to add to any project, including
    Google App Engine projects.

*   **Standards compliant**. Output successfully validates using the
    W3C validation tool for HTML 4.01 and XHTML 1.0 Transitional.

    [this is a link](https://github.com/kataras/iris) `

func main() {
    // if this is not setted then iris set this duration to the lowest expiration entry from the cache + 5 seconds
    // recommentation is to left as it's or
    // iris.Config.CacheGCDuration = time.Duration(5) * time.Minute

    bodyHandler := func(ctx *iris.Context) {
        ctx.Markdown(iris.StatusOK, testMarkdownContents)
    }

    expiration := time.Duration(5 * time.Second)

    iris.Get(""/"", iris.Cache(bodyHandler, expiration))

    // if expiration is <=time.Second then the cache tries to set the expiration from the ""cache-control"" maxage header's value(in seconds)
    // // if this header doesn't founds then the default is 5 minutes
    iris.Get(""/cache_control"", iris.Cache(func(ctx *iris.Context) {
        ctx.HTML(iris.StatusOK, ""<h1>Hello!</h1>"")
    }, -1))

    iris.Listen("":8080"")
}

```
- **IMPROVE**: [Iris command line tool](https://github.com/kataras/iris/tree/master/iris) introduces a **new** `get` command (replacement for the old `create`)

**The get command** downloads, installs and runs a project based on a `prototype`, such as `basic`, `static` and `mongo` .

> These projects are located [online](https://github.com/iris-contrib/examples/tree/master/AIO_examples)

``` sh
iris get basic
```

Downloads the  [basic](https://github.com/iris-contrib/examples/tree/master/AIO_examples/basic) sample protoype project to the `$GOPATH/src/github.com/iris-contrib/examples` directory(the iris cmd will open this folder to you, automatically) builds, runs and watch for source code changes (hot-reload)

[![Iris get command preview](https://raw.githubusercontent.com/iris-contrib/website/gh-pages/assets/iriscmd.gif)](https://raw.githubusercontent.com/iris-contrib/website/gh-pages/assets/iriscmd.gif)
- **CHANGE**: The `Path parameters` are now **immutable**. Now you don't have to copy a `path parameter` before passing to another function which maybe modifies it, this has a side-affect of `context.GetString(""key"") = context.Param(""key"")`  so you have to be careful to not override a path parameter via other custom (per-context) user value.
- **NEW**: `iris.StaticEmbedded`/`app := iris.New(); app.StaticEmbedded` - Embed static assets into your executable with [go-bindata](https://github.com/jteeuwen/go-bindata) and serve them.

> Note: This was already buitl'n feature for templates using `iris.UseTemplate(html.New()).Directory(""./templates"","".html"").Binary(Asset,AssetNames)`, after v4.6.1 you can do that for other static files too, with the `StaticEmbedded` function

**outline**

``` go

// StaticEmbedded  used when files are distrubuted inside the app executable, using go-bindata mostly
// First parameter is the request path, the path which the files in the vdir(second parameter) will be served to, for example ""/static""
// Second parameter is the (virtual) directory path, for example ""./assets""
// Third parameter is the Asset function
// Forth parameter is the AssetNames function
//
// For more take a look at the
// example: https://github.com/iris-contrib/examples/tree/master/static_files_embedded
StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string) RouteNameFunc

```

**example**

You can view and run it from [here](https://github.com/iris-contrib/examples/tree/master/static_files_embedded) *

``` go
package main

// First of all, execute: $ go get https://github.com/jteeuwen/go-bindata
// Secondly, execute the command: cd $GOPATH/src/github.com/iris-contrib/examples/static_files_embedded && go-bindata ./assets/...

import (
    ""github.com/kataras/iris""
)

func main() {

    // executing this go-bindata command creates a source file named 'bindata.go' which
    // gives you the Asset and AssetNames funcs which we will pass into .StaticAssets
    // for more viist: https://github.com/jteeuwen/go-bindata
    // Iris gives you a way to integrade these functions to your web app

    // For the reason that you may use go-bindata to embed more than your assets, you should pass the 'virtual directory path', for example here is the : ""./assets""
    // and the request path, which these files will be served to, you can set as ""/assets"" or ""/static"" which resulting on http://localhost:8080/static/*anyfile.*extension
    iris.StaticEmbedded(""/static"", ""./assets"", Asset, AssetNames)


    // that's all
    // this will serve the ./assets (embedded) files to the /static request path for example the favicon.ico will be served as :
    // http://localhost:8080/static/favicon.ico
    // Methods: GET and HEAD



    iris.Get(""/"", func(ctx *iris.Context) {
        ctx.HTML(iris.StatusOK, ""<b> Hi from index</b>"")
    })

    iris.Listen("":8080"")
}

// Navigate to:
// http://localhost:8080/static/favicon.ico
// http://localhost:8080/static/js/jquery-2.1.1.js
// http://localhost:8080/static/css/bootstrap.min.css

// Now, these files are stored inside into your executable program, no need to keep it in the same location with your assets folder.


```
- **FIX**: httptest flags caused by httpexpect which used to help you with tests inside **old** func `iris.Tester` as reported [here](https://github.com/kataras/iris/issues/337#issuecomment-253429976)
- **NEW**: `iris.ResetDefault()` func which resets the default iris instance which is the station for the most part of the public/package API
- **NEW**: package `httptest` with configuration which can be passed per 'tester' instead of iris instance( this is very helpful for testers)
- **CHANGED**: All tests are now converted for 'white-box' testing, means that tests now have package named: `iris_test` instead of `iris` in the same main directory.
- **CHANGED**: `iris.Tester` moved to `httptest.New` which lives inside the new `/kataras/iris/httptest` package, so:

**old**

``` go
import (
    ""github.com/kataras/iris""
    ""testing""
)

func MyTest(t *testing.T) {
    iris.Get(""/mypath"", func(ctx *iris.Context){
        ctx.Write(""my body"")
    })
    // with configs: iris.Config.Tester.ExplicitURL/Debug = true
    e:= iris.Tester(t)
    e.GET(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""my body"")
}
```

**used that instead/new**

``` go
import (
    ""github.com/kataras/iris/httptest""
    ""github.com/kataras/iris""
    ""testing""
)

func MyTest(t *testing.T) {
    // make sure that you reset your default station if you don't use the form of app := iris.New()
    iris.ResetDefault()

    iris.Get(""/mypath"", func(ctx *iris.Context){
        ctx.Write(""my body"")
    })

    e:= httptest.New(iris.Default, t)
    // with configs: e:= httptest.New(iris.Default, t, httptest.ExplicitURL(true), httptest.Debug(true))
    e.GET(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""my body"")
}
```

Finally, some plugins container's additions:
- **NEW**: `iris.Plugins.Len()` func which returns the length of the current activated plugins in the default station
- **NEW**: `iris.Plugins.Fired(""event"") int` func which returns how much times and from how many plugins a particular event type is fired, event types are: `""prelookup"", ""prebuild"", ""prelisten"", ""postlisten"", ""preclose"", ""predownload""`
- **NEW**: `iris.Plugins.PreLookupFired() bool` func which returns true if `PreLookup` fired at least one time
- **NEW**: `iris.Plugins.PreBuildFired() bool` func which returns true if `PreBuild` fired at least one time
- **NEW**: `iris.Plugins.PreListenFired() bool` func which returns true if `PreListen/PreListenParallel` fired at least one time
- **NEW**: `iris.Plugins.PostListenFired() bool` func which returns true if `PostListen` fired at least one time
- **NEW**: `iris.Plugins.PreCloseFired() bool` func which returns true if `PreClose` fired at least one time
- **NEW**: `iris.Plugins.PreDownloadFired() bool` func which returns true if `PreDownload` fired at least one time
- **Feature request**: I never though that it will be easier for users to catch 405 instead of simple 404, I though that will make your life harder, but it's requested by the Community [here](https://github.com/kataras/iris/issues/469), so I did my duty. Enable firing Status Method Not Allowed (405) with a simple configuration field: `iris.Config.FireMethodNotAllowed=true` or `iris.Set(iris.OptionFireMethodNotAllowed(true))` or `app := iris.New(iris.Configuration{FireMethodNotAllowed:true})`. A trivial, test example can be shown here:

``` go
func TestMuxFireMethodNotAllowed(t *testing.T) {

    iris.Config.FireMethodNotAllowed = true // enable catching 405 errors

    h := func(ctx *iris.Context) {
        ctx.Write(""%s"", ctx.MethodString())
    }

    iris.OnError(iris.StatusMethodNotAllowed, func(ctx *iris.Context) {
        ctx.Write(""Hello from my custom 405 page"")
    })

    iris.Get(""/mypath"", h)
    iris.Put(""/mypath"", h)

    e := iris.Tester(t)

    e.GET(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""GET"")
    e.PUT(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""PUT"")
    // this should fail with 405 and catch by the custom http error

    e.POST(""/mypath"").Expect().Status(iris.StatusMethodNotAllowed).Body().Equal(""Hello from my custom 405 page"")
    iris.Close()
}
```
- **NEW**: `PreBuild` plugin type, raises before `.Build`. Used by third-party plugins to register any runtime routes or make any changes to the iris main configuration, example of this usage is the [OAuth/OAuth2 Plugin](https://github.com/iris-contrib/plugin/tree/master/oauth).
- **FIX**: The [OAuth example](https://github.com/iris-contrib/examples/tree/master/plugin_oauth_oauth2).
- **NEW**: Websocket configuration fields:
  - `Error func(ctx *Context, status int, reason string)`. Manually catch  any handshake errors. Default calls the `ctx.EmitError(status)` with a stored error message in the `WsError` key(`ctx.Set(""WsError"", reason)`), as before.
  - `CheckOrigin func(ctx *Context)`. Manually allow or dissalow client's websocket access, ex: via header **Origin**. Default allow all origins(CORS-like) as before.
  - `Headers bool`. Allow websocket handler to copy request's headers on the handshake. Default is true
    With these in-mind the `WebsocketConfiguration` seems like this now :

``` go
type WebsocketConfiguration struct {
    // WriteTimeout time allowed to write a message to the connection.
    // Default value is 15 * time.Second
    WriteTimeout time.Duration
    // PongTimeout allowed to read the next pong message from the connection
    // Default value is 60 * time.Second
    PongTimeout time.Duration
    // PingPeriod send ping messages to the connection with this period. Must be less than PongTimeout
    // Default value is (PongTimeout * 9) / 10
    PingPeriod time.Duration
    // MaxMessageSize max message size allowed from connection
    // Default value is 1024
    MaxMessageSize int64
    // BinaryMessages set it to true in order to denotes binary data messages instead of utf-8 text
    // see https://github.com/kataras/iris/issues/387#issuecomment-243006022 for more
    // defaults to false
    BinaryMessages bool
    // Endpoint is the path which the websocket server will listen for clients/connections
    // Default value is empty string, if you don't set it the Websocket server is disabled.
    Endpoint string
    // ReadBufferSize is the buffer size for the underline reader
    ReadBufferSize int
    // WriteBufferSize is the buffer size for the underline writer
    WriteBufferSize int
    // Headers  if true then the client's headers are copy to the websocket connection
    //
    // Default is true
    Headers bool
    // Error specifies the function for generating HTTP error responses.
    //
    // The default behavior is to store the reason in the context (ctx.Set(reason)) and fire any custom error (ctx.EmitError(status))
    Error func(ctx *Context, status int, reason string)
    // CheckOrigin returns true if the request Origin header is acceptable. If
    // CheckOrigin is nil, the host in the Origin header must not be set or
    // must match the host of the request.
    //
    // The default behavior is to allow all origins
    // you can change this behavior by setting the iris.Config.Websocket.CheckOrigin = iris.WebsocketCheckSameOrigin
    CheckOrigin func(ctx *Context) bool
}

```
- **REMOVE**: `github.com/kataras/iris/context/context.go` , this is no needed anymore. Its only usage was inside `sessions` and `websockets`, a month ago I did improvements to the sessions as a standalone package, the IContext interface is not being used there. With the today's changes, the iris-contrib/websocket doesn't needs the IContext interface too, so the whole folder `./context` is useless and removed now. Users developers don't have any side-affects from this change.

[Examples](https://github.com/iris-contrib/examples), [Book](https://github.com/iris-contrib/gitbook) are up-to-date, just new configuration fields.
- **FIX**: Previous CORS fix wasn't enough and produces error before server's startup[*](https://github.com/kataras/iris/issues/461) if many paths were trying to auto-register an `.OPTIONS` route, now this is fixed in combined with some improvements on the [cors middleware](https://github.com/iris-contrib/middleware/tree/master/cors) too.
- **NEW**: `BodyDecoder` gives the ability to set a custom decoder **per passed object** when `context.ReadJSON` and `context.ReadXML`

``` go
// BodyDecoder is an interface which any struct can implement in order to customize the decode action
// from ReadJSON and ReadXML
//
// Trivial example of this could be:
// type User struct { Username string }
//
// func (u *User) Decode(data []byte) error {
//    return json.Unmarshal(data, u)
// }
//
// the 'context.ReadJSON/ReadXML(&User{})' will call the User's
// Decode option to decode the request body
//
// Note: This is totally optionally, the default decoders
// for ReadJSON is the encoding/json and for ReadXML is the encoding/xml
type BodyDecoder interface {
    Decode(data []byte) error
}

```

> for a usage example go to https://github.com/kataras/iris/blob/master/context_test.go#L262
> - **small fix**: websocket server is nil when more than the default websocket station tries to be registered before `OnConnection` called[*](https://github.com/kataras/iris/issues/460)
> - **FIX**: CORS not worked for all http methods
> - **FIX**: Unexpected Party root's route slash  when `DisablePathCorrection` is false(default), as reported [here](https://github.com/kataras/iris/issues/453)
> - **small fix**: DisablePathEscape not affects the uri string
> - **small fix**: when Path Correction on POST redirect to the GET instead of POST
> - **NEW**: Template PreRenders, as requested [here](https://github.com/kataras/iris/issues/412).

``` go
// ...
iris.UsePreRender(func(ctx *iris.Context, filename string, binding interface{}, options ...map[string]interface{}) bool {
    // put the 'Error' binding here, for the shake of the test
    if b, isMap := binding.(map[string]interface{}); isMap {
        b[""Error""] = ""error!""
    }
    // true= continue to the next PreRender
  // false= do not continue to the next PreRender
  // * but the actual Render will be called at any case *
  return true
})

iris.Get(""/"", func(ctx *Context) {
    ctx.Render(""hi.html"", map[string]interface{}{""Username"": ""anybody""})
    // hi.html: <h1>HI {{.Username}}. Error: {{.Error}}</h1>
})

// ...
```

**NOTE**: For normal users this update offers nothing, read that only if you run Iris behind a proxy or balancer like `nginx` or you need to serve using a custom `net.Listener`.

This update implements the [support of using native servers and net.Listener instead of Iris' defined](https://github.com/kataras/iris/issues/438).

### Breaking changes
- `iris.Config.Profile` field removed and the whole pprof transfered to the [iris-contrib/middleware/pprof](https://github.com/iris-contrib/middleware/tree/master/pprof).
- `iris.ListenTLSAuto` renamed to `iris.ListenLETSENCRYPT`
- `iris.Default.Handler` is `iris.Router` which is the Handler you can use to setup a custom router or bind Iris' router, after `iris.Build` call, to an external custom server.
- `iris.ServerConfiguration`, `iris.ListenVirtual`, `iris.AddServer`, `iris.Go` & `iris.TesterConfiguration.ListeningAddr` removed, read below the reason and their alternatives

### New features
- Boost Performance on server's startup
- **NEW**: `iris.Reserve()` re-starts the server if `iris.Close()` called previously.
- **NEW**: `iris.Config.VHost` and `iris.Config.VScheme` replaces the previous `ListenVirtual`, `iris.TesterConfiguration.ListeningAddr`, `iris.ServerConfiguration.VListeningAddr`, `iris.ServerConfiguration.VScheme`.
- **NEW**: `iris.Build` it's called automatically on Listen functions or Serve function. **CALL IT, MANUALLY, ONLY** WHEN YOU WANT TO BE ABLE TO GET THE IRIS ROUTER(`iris.Router`) AND PASS THAT, HANDLER, TO ANOTHER EXTERNAL FASTHTTP SERVER.
- **NEW**: `iris.Serve(net.Listener)`. Starts the server using a custom net.Listener, look below for example link
- **NEW**: now that iris supports custom net.Listener bind, I had to provide to you some net.Listeners too, such as `iris.TCP4`, `iris.UNIX`, `iris.TLS` , `iris.LETSENCRPYPT` & `iris.CERT` , all of these are optionals because you can just use the `iris.Listen`, `iris.ListenUNIX`, `iris.ListenTLS` & `iris.ListenLETSENCRYPT`, but if you want, for example, to pass your own `tls.Config` then you will have to create a custom net.Listener and pass that to the `iris.Serve(net.Listener)`.

With these in mind, developers are now able to fill their advanced needs without use the `iris.AddServer, ServerConfiguration and V fields`, so it's easier to:
- use any external (fasthttp compatible) server or router. Examples: [server](https://github.com/iris-contrib/tree/master/custom_fasthtthttp_server) and [router]((https://github.com/iris-contrib/tree/master/custom_fasthtthttp_router)
- bind any `net.Listener` which will be used to run the Iris' HTTP server, as requested [here](https://github.com/kataras/iris/issues/395). Example [here](https://github.com/iris-contrib/tree/master/custom_net_listener)
- setup virtual host and scheme, useful when you run Iris behind `nginx` (etc) and want template function `{{url }}` and subdomains to work as you expected. Usage:

``` go
iris.Config.VHost = ""mydomain.com""
iris.Config.VScheme = ""https://""

iris.Listen("":8080"")

// this will run on localhost:8080 but templates, subdomains and all that will act like https://mydomain.com,
// before this update you used the iris.AddServer and iris.Go and pass some strange fields into

```

Last, for testers:

Who used the `iris.ListenVirtual(...).Handler`:
If closed server, then `iris.Build()` and `iris.Router`, otherwise just `iris.Router`.

To test subdomains or a custom domain just set the `iris.Config.VHost` and `iris.Config.VScheme` fields, instead of the old `subdomain_test_handler := iris.AddServer(iris.ServerConfiguration{VListeningAddr:""..."", Virtual: true, VScheme:false}).Handler`. Usage [here](https://github.com/kataras/blob/master/http_test.go).

**Finally**, I have to notify you that [examples](https://github.com/iris-contrib/examples), [plugins](https://github.com/iris-contrib/plugin), [middleware](https://github.com/iris-contrib/middleware) and [book](https://github.com/iris-contrib/gitbook) have been updated.
- Align with the latest version of [go-websocket](https://github.com/kataras/go-websocket), remove vendoring for compression on [go-fs](https://github.com/kataras/go-fs) which produced errors on sqllite and gorm(mysql and mongo worked fine before too) as reported [here](https://github.com/kataras/go-fs/issues/1).
- **External FIX**: [template syntax error causes a ""template doesn't exist""](https://github.com/kataras/iris/issues/415)
- **ADDED**: You are now able to use a raw fasthttp handler as the router instead of the default Iris' one. Example [here](https://github.com/iris-contrib/examples/blob/master/custom_fasthttp_router/main.go). But remember that I'm always recommending to use the Iris' default which supports subdomains, group of routes(parties), auto path correction and many other built'n features. This exists for specific users who told me that they need a feature like that inside Iris, we have no performance cost at all so that's ok to exists.
- **CHANGE**: Updater (See 4.2.4 and 4.2.3) runs in its own goroutine now, unless the `iris.Config.CheckForUpdatesSync` is true.
- **ADDED**: To align with fasthttp server's configuration, iris has these new Server Configuration's fields, which allows you to set a type of rate limit:

``` go
// Maximum number of concurrent client connections allowed per IP.
//
// By default unlimited number of concurrent connections
// may be established to the server from a single IP address.
MaxConnsPerIP int

// Maximum number of requests served per connection.
//
// The server closes connection after the last request.
// 'Connection: close' header is added to the last response.
//
// By default unlimited number of requests may be served per connection.
MaxRequestsPerConn int

// Usage: iris.ListenTo{iris.OptionServerListeningAddr("":8080""), iris.OptionServerMaxConnsPerIP(300)}
//    or: iris.ListenTo(iris.ServerConfiguration{ListeningAddr: "":8080"", MaxConnsPerIP: 300, MaxRequestsPerConn:100})
// for an optional second server with a different port you can always use:
//        iris.AddServer(iris.ServerConfiguration{ListeningAddr: "":9090"", MaxConnsPerIP: 300, MaxRequestsPerConn:100})
```
- **ADDED**: `iris.CheckForUpdates(force bool)` which can run the updater(look 4.2.4) at runtime too, updater is tested and worked at dev machine.
- **NEW Experimental feature**: Updater with a `CheckForUpdates` [configuration](https://github.com/kataras/iris/blob/master/configuration.go) field, as requested [here](https://github.com/kataras/iris/issues/401)

``` go
// CheckForUpdates will try to search for newer version of Iris based on the https://github.com/kataras/iris/releases
// If a newer version found then the app will ask the he dev/user if want to update the 'x' version
// if 'y' is pressed then the updater will try to install the latest version
// the updater, will notify the dev/user that the update is finished and should restart the App manually.
// Notes:
// 1. Experimental feature
// 2. If setted to true, the app will have a little startup delay
// 3. If you as developer edited the $GOPATH/src/github/kataras or any other Iris' Go dependencies at the past
//    then the update process will fail.
//
// Usage: iris.Set(iris.OptionCheckForUpdates(true)) or
//        iris.Config.CheckForUpdates = true or
//        app := iris.New(iris.OptionCheckForUpdates(true))
// Default is false
CheckForUpdates bool
```
- [Add IsAjax() convenience method](https://github.com/kataras/iris/issues/423)
- Fix [sessiondb issue 416](https://github.com/kataras/iris/issues/416)
- **CHANGE**: No front-end changes if you used the default response engines before. Response Engines to Serializers, `iris.ResponseEngine` `serializer.Serializer`, comes from `kataras/go-serializer` which is installed automatically when you upgrade iris with `-u` flag.
  - the repo ""github.com/iris-contrib/response"" is a clone of ""github.com/kataras/go-serializer"", to keep compatibility state. examples and gitbook updated to work with the last.
  - `iris.UseResponse(iris.ResponseEngine, ...string)func (string)` was used to register custom response engines, now you use: `iris.UseSerializer(key string, s serializer.Serializer)`.
  - `iris.ResponseString` same defintion but differnet name now: `iris.SerializeToString`

[Serializer examples](https://github.com/iris-contrib/examples/tree/master/serialize_engines) and [Book section](https://kataras.gitbooks.io/iris/content/serialize-engines.html) updated.
- **ADDED**: `iris.TemplateSourceString(src string, binding interface{}) string` this will parse the src raw contents to the template engine and return the string result & `context.RenderTemplateSource(status int, src string, binding interface{}, options ...map[string]interface{}) error` this will parse the src raw contents to the template engine and render the result to the client, as requseted [here](https://github.com/kataras/iris/issues/409).

This version has 'breaking' changes if you were, directly, passing custom configuration to a custom iris instance before.
As the TODO2 I had to think and implement a way to make configuration even easier and more simple to use.

With last changes in place, Iris is using new, cross-framework, and more stable packages made by me(so don't worry things are working and will as you expect) to render [templates](https://github.com/kataras/go-template), manage [sessions](https://github.com/kataras/go-sesions) and [websockets](https://github.com/kataras/go-websocket). So the `/kataras/iris/config` is no longer need to be there, we don't have core packages inside iris which need these configuration to other package-folder than the main anymore(in order to avoid the import-cycle), new file `/kataras/iris/configuration.go` is created for the configuration, which lives inside the main package, means that now:
- **if you want to pass directly configuration to a new custom iris instance, you don't have to import the github.com/kataras/iris/config package**

Naming changes:
- `config.Iris` -> `iris.Configuration`, which is the parent/main configuration. Added: `TimeFormat` and `Other` (pass any dynamic custom, other options there)
- `config.Sessions` -> `iris.SessionsConfiguration`
- `config.Websocket` -> `iris.WebscoketConfiguration`
- `config.Server` -> `iris.ServerConfiguration`
- `config.Tester` -> `iris.TesterConfiguration`

All these changes wasn't made only to remove the `./config` folder but to make easier for you to pass the exact configuration field/option you need to edit at the top of the default configuration, without need to pass the whole Configuration object. **Attention**: old way, pass `iris.Configuration` directly, is still valid object to pass to the  `iris.New`, so don't be afraid for breaking change, the only thing you will need to edit is the names of the configuration you saw on the previous paragraph.

**Configuration Declaration**:

instead of old, but still valid to pass to the `iris.New`:
- `iris.New(iris.Configuration{Charset: ""UTF-8"", Sessions: iris.SessionsConfiguration{Cookie: ""cookienameid""}})`
  now you can just write this:
- `iris.New(iris.OptionCharset(""UTF-8""), iris.OptionSessionsCookie(""cookienameid""))`

`.New` **by configuration**

``` go
import ""github.com/kataras/iris""
//...
myConfig := iris.Configuration{Charset: ""UTF-8"", IsDevelopment:true, Sessions: iris.SessionsConfiguration{Cookie:""mycookie""}, Websocket: iris.WebsocketConfiguration{Endpoint: ""/my_endpoint""}}
iris.New(myConfig)
```

`.New` **by options**

``` go
import ""github.com/kataras/iris""
//...
iris.New(iris.OptionCharset(""UTF-8""), iris.OptionIsDevelopment(true), iris.OptionSessionsCookie(""mycookie""), iris.OptionWebsocketEndpoint(""/my_endpoint""))

// if you want to set configuration after the .New use the .Set:
iris.Set(iris.OptionDisableBanner(true))
```

**List** of all available options:

``` go
// OptionDisablePathCorrection corrects and redirects the requested path to the registed path
// for example, if /home/ path is requested but no handler for this Route found,
// then the Router checks if /home handler exists, if yes,
// (permant)redirects the client to the correct path /home
//
// Default is false
OptionDisablePathCorrection(val bool)

// OptionDisablePathEscape when is false then its escapes the path, the named parameters (if any).
OptionDisablePathEscape(val bool)

// OptionDisableBanner outputs the iris banner at startup
//
// Default is false
OptionDisableBanner(val bool)

// OptionLoggerOut is the destination for output
//
// Default is os.Stdout
OptionLoggerOut(val io.Writer)

// OptionLoggerPreffix is the logger's prefix to write at beginning of each line
//
// Default is [IRIS]
OptionLoggerPreffix(val string)

// OptionProfilePath a the route path, set it to enable http pprof tool
// Default is empty, if you set it to a $path, these routes will handled:
OptionProfilePath(val string)

// OptionDisableTemplateEngines set to true to disable loading the default template engine (html/template) and disallow the use of iris.UseEngine
// Default is false
OptionDisableTemplateEngines(val bool)

// OptionIsDevelopment iris will act like a developer, for example
// If true then re-builds the templates on each request
// Default is false
OptionIsDevelopment(val bool)

// OptionTimeFormat time format for any kind of datetime parsing
OptionTimeFormat(val string)

// OptionCharset character encoding for various rendering
// used for templates and the rest of the responses
// Default is ""UTF-8""
OptionCharset(val string)

// OptionGzip enables gzip compression on your Render actions, this includes any type of render, templates and pure/raw content
// If you don't want to enable it globaly, you could just use the third parameter on context.Render(""myfileOrResponse"", structBinding{}, iris.RenderOptions{""gzip"": true})
// Default is false
OptionGzip(val bool)

// OptionOther are the custom, dynamic options, can be empty
// this fill used only by you to set any app's options you want
// for each of an Iris instance
OptionOther(val ...options.Options) //map[string]interface{}, options is github.com/kataras/go-options

// OptionSessionsCookie string, the session's client cookie name, for example: ""qsessionid""
OptionSessionsCookie(val string)

// OptionSessionsDecodeCookie set it to true to decode the cookie key with base64 URLEncoding
// Defaults to false
OptionSessionsDecodeCookie(val bool)

// OptionSessionsExpires the duration of which the cookie must expires (created_time.Add(Expires)).
// If you want to delete the cookie when the browser closes, set it to -1 but in this case, the server side's session duration is up to GcDuration
//
// Default infinitive/unlimited life duration(0)
OptionSessionsExpires(val time.Duration)

// OptionSessionsCookieLength the length of the sessionid's cookie's value, let it to 0 if you don't want to change it
// Defaults to 32
OptionSessionsCookieLength(val int)

// OptionSessionsGcDuration every how much duration(GcDuration) the memory should be clear for unused cookies (GcDuration)
// for example: time.Duration(2)*time.Hour. it will check every 2 hours if cookie hasn't be used for 2 hours,
// deletes it from backend memory until the user comes back, then the session continue to work as it was
//
// Default 2 hours
OptionSessionsGcDuration(val time.Duration)

// OptionSessionsDisableSubdomainPersistence set it to true in order dissallow your q subdomains to have access to the session cookie
// defaults to false
OptionSessionsDisableSubdomainPersistence(val bool)

// OptionWebsocketWriteTimeout time allowed to write a message to the connection.
// Default value is 15 * time.Second
OptionWebsocketWriteTimeout(val time.Duration)

// OptionWebsocketPongTimeout allowed to read the next pong message from the connection
// Default value is 60 * time.Second
OptionWebsocketPongTimeout(val time.Duration)

// OptionWebsocketPingPeriod send ping messages to the connection with this period. Must be less than PongTimeout
// Default value is (PongTimeout * 9) / 10
OptionWebsocketPingPeriod(val time.Duration)

// OptionWebsocketMaxMessageSize max message size allowed from connection
// Default value is 1024
OptionWebsocketMaxMessageSize(val int64)

// OptionWebsocketBinaryMessages set it to true in order to denotes binary data messages instead of utf-8 text
// see https://github.com/kataras/iris/issues/387#issuecomment-243006022 for more
// defaults to false
OptionWebsocketBinaryMessages(val bool)

// OptionWebsocketEndpoint is the path which the websocket server will listen for clients/connections
// Default value is empty string, if you don't set it the Websocket server is disabled.
OptionWebsocketEndpoint(val string)

// OptionWebsocketReadBufferSize is the buffer size for the underline reader
OptionWebsocketReadBufferSize(val int)

// OptionWebsocketWriteBufferSize is the buffer size for the underline writer
OptionWebsocketWriteBufferSize(val int)

// OptionTesterListeningAddr is the virtual server's listening addr (host)
// Default is ""iris-go.com:1993""
OptionTesterListeningAddr(val string)

// OptionTesterExplicitURL If true then the url (should) be prepended manually, useful when want to test subdomains
// Default is false
OptionTesterExplicitURL(val bool)

// OptionTesterDebug if true then debug messages from the httpexpect will be shown when a test runs
// Default is false
OptionTesterDebug(val bool)


```

Now, some of you maybe use more than one server inside their iris instance/app, so you used the `iris.AddServer(config.Server{})`, which now becomes `iris.AddServer(iris.ServerConfiguration{})`, ServerConfiguration has also (optional) options to pass there and to `iris.ListenTo(OptionServerListeningAddr(""mydomain.com""))`:

``` go
// examples:
iris.AddServer(iris.OptionServerCertFile(""file.cert""),iris.OptionServerKeyFile(""file.key""))
iris.ListenTo(iris.OptionServerReadBufferSize(42000))

// or, old way but still valid:
iris.AddServer(iris.ServerConfiguration{ListeningAddr: ""mydomain.com"", CertFile: ""file.cert"", KeyFile: ""file.key""})
iris.ListenTo(iris.ServerConfiguration{ReadBufferSize:42000, ListeningAddr: ""mydomain.com""})
```

**List** of all Server's options:

``` go
OptionServerListeningAddr(val string)

OptionServerCertFile(val string)

OptionServerKeyFile(val string)

// AutoTLS enable to get certifications from the Letsencrypt
// when this configuration field is true, the CertFile & KeyFile are empty, no need to provide a key.
//
// example: https://github.com/iris-contrib/examples/blob/master/letsencyrpt/main.go
OptionServerAutoTLS(val bool)

// Mode this is for unix only
OptionServerMode(val os.FileMode)
// OptionServerMaxRequestBodySize Maximum request body size.
//
// The server rejects requests with bodies exceeding this limit.
//
// By default request body size is 8MB.
OptionServerMaxRequestBodySize(val int)

// Per-connection buffer size for requests' reading.
// This also limits the maximum header size.
//
// Increase this buffer if your clients send multi-KB RequestURIs
// and/or multi-KB headers (for example, BIG cookies).
//
// Default buffer size is used if not set.
OptionServerReadBufferSize(val int)

// Per-connection buffer size for responses' writing.
//
// Default buffer size is used if not set.
OptionServerWriteBufferSize(val int)

// Maximum duration for reading the full request (including body).
//
// This also limits the maximum duration for idle keep-alive
// connections.
//
// By default request read timeout is unlimited.
OptionServerReadTimeout(val time.Duration)

// Maximum duration for writing the full response (including body).
//
// By default response write timeout is unlimited.
OptionServerWriteTimeout(val time.Duration)

// RedirectTo, defaults to empty, set it in order to override the station's handler and redirect all requests to this address which is of form(HOST:PORT or :PORT)
//
// NOTE: the http status is 'StatusMovedPermanently', means one-time-redirect(the browser remembers the new addr and goes to the new address without need to request something from this server
// which means that if you want to change this address you have to clear your browser's cache in order this to be able to change to the new addr.
//
// example: https://github.com/iris-contrib/examples/tree/master/multiserver_listening2
OptionServerRedirectTo(val string)

// OptionServerVirtual If this server is not really listens to a real host, it mostly used in order to achieve testing without system modifications
OptionServerVirtual(val bool)

// OptionServerVListeningAddr, can be used for both virtual = true or false,
// if it's setted to not empty, then the server's Host() will return this addr instead of the ListeningAddr.
// server's Host() is used inside global template helper funcs
// set it when you are sure you know what it does.
//
// Default is empty """"
OptionServerVListeningAddr(val string)

// OptionServerVScheme if setted to not empty value then all template's helper funcs prepends that as the url scheme instead of the real scheme
// server's .Scheme returns VScheme if  not empty && differs from real scheme
//
// Default is empty """"
OptionServerVScheme(val string)

// OptionServerName the server's name, defaults to ""iris"".
// You're free to change it, but I will trust you to don't, this is the only setting whose somebody, like me, can see if iris web framework is used
OptionServerName(val string)

```

View all configuration fields and options by navigating to the [kataras/iris/configuration.go source file](https://github.com/kataras/iris/blob/master/configuration.go)

[Book](https://kataras.gitbooks.io/iris/content/configuration.html) & [Examples](https://github.com/iris-contrib/examples) are updated (website docs will be updated soon).
- **CHANGED**: Use of the standard `log.Logger` instead of the `iris-contrib/logger`(colorful logger), these changes are reflects some middleware, examples and plugins, I updated all of them, so don't worry.

So, [iris-contrib/middleware/logger](https://github.com/iris-contrib/middleware/tree/master/logger) will now NO need to pass other Logger instead, instead of: `iris.Use(logger.New(iris.Logger))` use -> `iris.Use(logger.New())` which will use the iris/instance's Logger.
- **ADDED**: `context.Framework()` which returns your Iris instance (typeof `*iris.Framework`), useful for the future(Iris will give you, soon, the ability to pass custom options inside an iris instance).
- Align with [go-sessions](https://github.com/kataras/go-sessions), no front-end changes, however I think that the best time to make an upgrade to your local Iris is right now.
- Remove unused Plugin's custom callbacks, if you still need them in your project use this instead: https://github.com/kataras/go-events

Zero front-end changes. No real improvements, developers can ignore this update.
- Replace the iris sessions with a new cross-framework package, [go-sessions](https://github.com/kataras/go-sessions). Same front-end API, sessions examples are compatible, configuration of `kataras/iris/config/sessions.go` is compatible. `kataras/context.SessionStore` is now `kataras/go-sessions.Session` (normally you, as user, never used it before, because of automatically session getting by `context.Session()`)
- `GzipWriter` is taken, now, from the `kataras/go-fs` package which has improvements versus the previous implementation.

Zero front-end changes. No real improvements, developers can ignore this update.
- Replace the template engines with a new cross-framework package, [go-template](https://github.com/kataras/go-websocket). Same front-end API, examples and iris-contrib/template are compatible.

Zero front-end changes. No real improvements, developers can ignore this update.
- Replace the main and underline websocket implementation with [go-websocket](https://github.com/kataras/go-websocket). Note that we still need the [ris-contrib/websocket](https://github.com/iris-contrib/websocket) package.
- Replace the use of iris-contrib/errors with [go-errors](https://github.com/kataras/go-errors), which has more features
- **NEW FEATURE**: Optionally `OnError` foreach Party (by prefix, use it with your own risk), example [here](https://github.com/iris-contrib/examples/blob/master/httperrors/main.go#L37)
- **NEW**: `iris.Config.Sessions.CookieLength`, You're able to customize the length of each sessionid's cookie's value. Default (and previous' implementation) is 32.
- **FIX**: Websocket panic on non-websocket connection[*](https://github.com/kataras/iris/issues/367)
- **FIX**: Multi websocket servers client-side source route panic[*](https://github.com/kataras/iris/issues/365)
- Better gzip response managment
- **Feature request has been implemented**: Add layout support for Pug/Jade, example [here](https://github.com/iris-contrib/examples/tree/master/template_engines/template_pug_2).
- **Feature request has been implemented**: Forcefully closing a Websocket connection, `WebsocketConnection.Disconnect() error`.
- **FIX**: WebsocketConnection.Leave() will hang websocket server if .Leave was called manually when the websocket connection has been closed.
- **FIX**: StaticWeb not serving index.html correctly, align the func with the rest of Static funcs also, [example](https://github.com/iris-contrib/examples/tree/master/static_web) added.

Notes: if you compare it with previous releases (13+ versions before v3 stable), the v4 stable release was fast, now we had only 6 versions before stable, that was happened because many of bugs have been already fixed and we hadn't new bug reports and secondly, and most important for me, some third-party features are implemented mostly by third-party packages via other developers!
- **NEW FEATURE**: Letsencrypt.org integration[*](https://github.com/kataras/iris/issues/220)
  - example [here](https://github.com/iris-contrib/examples/blob/master/letsencrypt/main.go)
- **FIX**: (ListenUNIX adds :80 to filename)[https://github.com/kataras/iris/issues/321]
- **FIX**: (Go-Bindata + ctx.Render)[https://github.com/kataras/iris/issues/315]
- **FIX** (auto-gzip doesn't really compress data in latest code)[https://github.com/kataras/iris/issues/312]

**The important** , is that the [book](https://kataras.gitbooks.io/iris/content/) is finally updated!

If you're **willing to donate** click [here](DONATIONS.md)!
- `iris.Config.Gzip`, enables gzip compression on your Render actions, this includes any type of render, templates and pure/raw content. If you don't want to enable it globaly, you could just use the third parameter on context.Render(""myfileOrResponse"", structBinding{}, iris.RenderOptions{""gzip"": true}). It defaults to false
-  **Added** `config.Server.Name` as requested

**Fix**
- https://github.com/kataras/iris/issues/301

*_Sessions changes *_
- `iris.Config.Sessions.Expires` it was time.Time, changed to time.Duration, which defaults to 0, means unlimited session life duration, if you change it then the correct date is setted on client's cookie but also server destroys the session automatically when the duration passed, this is better approach, see [here](https://github.com/kataras/iris/issues/301)

**New**

A **Response Engine** gives you the freedom to create/change the render/response writer for
- `context.JSON`
- `context.JSONP`
- `context.XML`
- `context.Text`
- `context.Markdown`
- `context.Data`
- `context.Render(""my_custom_type"",mystructOrData{}, iris.RenderOptions{""gzip"":false,""charset"":""UTF-8""})`
- `context.MarkdownString`
- `iris.ResponseString(...)`

**Fix**
- https://github.com/kataras/iris/issues/294
- https://github.com/kataras/iris/issues/303

**Small changes**
- `iris.Config.Charset`, before alpha.3 was `iris.Config.Rest.Charset` & `iris.Config.Render.Template.Charset`, but you can override it at runtime by passinth a map `iris.RenderOptions` on the `context.Render` call .
- `iris.Config.IsDevelopment`, before alpha.1 was `iris.Config.Render.Template.IsDevelopment`

**Websockets changes**

No need to import the `github.com/kataras/iris/websocket` to use the `Connection` iteral, the websocket moved inside `kataras/iris` , now all exported variables' names have the prefix of `Websocket`, so the old `websocket.Connection` is now `iris.WebsocketConnection`.

Generally, no other changes on the 'frontend API', for response engines examples and how you can register your own to add more features on existing response engines or replace them, look [here](https://github.com/iris-contrib/response).

**BAD SIDE**: E-Book is still pointing on the v3 release, but will be updated soon.

*_Sessions were re-written *_
- Developers can use more than one 'session database', at the same time, to store the sessions
- Easy to develop a custom session database (only two functions are required (Load & Update)), [learn more](https://github.com/iris-contrib/sessiondb/blob/master/redis/database.go)
- Session databases are located [here](https://github.com/iris-contrib/sessiondb), contributions are welcome
- The only frontend deleted 'thing' is the: **config.Sessions.Provider**
- No need to register a database, the sessions works out-of-the-box
- No frontend/API changes except the `context.Session().Set/Delete/Clear`, they doesn't return errors anymore, btw they (errors) were always nil :)
- Examples (master branch) were updated.

``` sh
$ go get github.com/kataras/go-sessions/sessiondb/$DATABASE
```

``` go
db := $DATABASE.New(configurationHere{})
iris.UseSessionDB(db)
```

## 3.0.0 -> 4.0.0-alpha.1

[logger](https://github.com/iris-contrib/logger), [rest](https://github.com/iris-contrib/rest) and all [template engines](https://github.com/iris-contrib/template) **moved** to the [iris-contrib](https://github.com/iris-contrib).
- `config.Logger` -> `iris.Logger.Config`
- `config.Render/config.Render.Rest/config.Render.Template` -> **Removed**
- `config.Render.Rest` -> `rest.Config`
- `config.Render.Template` -> `$TEMPLATE_ENGINE.Config` except Directory,Extensions, Assets, AssetNames,
- `config.Render.Template.Directory` -> `iris.UseTemplate($TEMPLAET_ENGINE.New()).Directory(""./templates"", "".html"")`
- `config.Render.Template.Assets` -> `iris.UseTemplate($TEMPLAET_ENGINE.New()).Directory(""./templates"","".html"").Binary(assetFn func(name string) ([]byte, error), namesFn func() []string)`
- `context.ExecuteTemplate` -> **Removed**, you can use the `context.Response.BodyWriter()` to get its writer and execute html/template engine manually, but this is useless because we support the best support for template engines among all other (golang) web frameworks
- **Added** `config.Server.ReadBufferSize & config.Server.WriteBufferSize` which can be passed as configuration fields inside `iris.ListenTo(config.Server{...})`, which does the same job as `iris.Listen`
- **Added** `iris.UseTemplate($TEMPLAET_ENGINE.New()).Directory(""./templates"", "".html"")` to register a template engine, now iris supports multi template engines, each template engine has its own file extension, no big changes on context.Render except the last parameter:
- `context.Render(filename string, binding interface{}, layout string{})` -> `context.Render(filename string, binding interface{}, options ...map[string]interface{})  | context.Render(""myfile.html"", myPage{}, iris.Map{""gzip"":true,""layout"":""layouts/MyLayout.html""}) |`

E-book and examples are not yet updated, no big changes.

## 3.0.0-rc.4 -> 3.0.0-pre.release
- `context.PostFormValue` -> `context.FormValueString`, old func stays until the next revision
- `context.PostFormMulti` -> `context.FormValues` , old func stays until the next revision
- Added `context.VisitAllCookies(func(key,value string))` to visit all your cookies (because `context.Request.Header.VisitAllCookie` has a bug(I can't fix/pr it because the author is away atm))
- Added `context.GetFlashes` to get all available flash messages for a particular request
- Fix flash message removed after the first `GetFlash` call in the same request

**NEW FEATURE**: Built'n support for multi listening servers per iris station, secondary and virtual servers with one-line using the `iris.AddServer` & `iris.Go` to start all servers.
- `iris.SecondaryListen` -> `iris.AddServer`, old func stays until the next revision
- Added `iris.Servers` with this field you can manage your servers very easy
- Added `iris.AddServer/iris.ListenTo/iris.Go`, but funcs like `Listen/ListenTLS/ListenUNIX` will stay forever
- Added `config.Server.Virtual(bool), config.Server.RedirectTo(string) and config.Server.MaxRequestBodySize(int64)`
- Added `iris.Available (channel bool)`
- `iris.HTTPServer` -> `iris.Servers.Main()` to get the main server, which is always the last registered server (if more than one used), old field removed
- `iris.Config.MaxRequestBodySize` -> `config.Server.MaxRequestBodySize`, old field removed

**NEW FEATURE**: Build'n support for your API's end-to-end tests
- Added `tester := iris.Tester(*testing.T)` , look inside: [http_test.go](https://github.com/kataras/iris/blob/master/http_test.go) & [./context_test.go](https://github.com/kataras/iris/blob/master/context_test.go) for `Tester` usage, you can also look inside the [httpexpect's repo](https://github.com/gavv/httpexpect/blob/master/example/iris_test.go) for extended examples with Iris.

## 3.0.0-rc.3 -> 3.0.0-rc.4

**NEW FEATURE**: **Handlebars** template engine support with all Iris' view engine's functions/helpers support, as requested [here](https://github.com/kataras/iris/issues/239):
- `iris.Config.Render.Template.Layout = ""layouts/layout.html""`
- `config.NoLayout`
- **dynamic** optional layout on `context.Render`
- **Party specific** layout
- `iris.Config.Render.Template.Handlebars.Helpers[""myhelper""] = func()...`
- `{{ yield }}`
- `{{ render }}`
- `{{ url ""myroute"" myparams}}`
- `{{ urlpath ""myroute"" myparams}}`

For a complete example please, click [here](https://github.com/iris-contrib/examples/tree/master/templates_handlebars).

**NEW:** Iris **can listen to more than one server per station** now, as requested [here](https://github.com/kataras/iris/issues/235).
For example you can have https with SSL/TLS and one more server http which navigates to the secure location.
Take a look [here](https://github.com/kataras/iris/issues/235#issuecomment-229399829) for an example of this.

**FIXES**
- Fix  `sessions destroy`
- Fix  `sessions persistence on subdomains` (as RFC2109 commands but you can disable it with `iris.Config.Sessions.DisableSubdomainPersistence = true`)

**IMPROVEMENTS**
- Improvements on `iris run` && `iris create`, note that the underline code for hot-reloading moved to [rizla](https://github.com/kataras/rizla).

## 3.0.0-rc.2 -> 3.0.0-rc.3

**Breaking changes**
- Move middleware & their configs to the  [iris-contrib/middleware](https://github.com/iris-contrib/middleware) repository
- Move all plugins & their configs to the [iris-contrib/plugin](https://github.com/iris-contrib/plugin) repository
- Move the graceful package to the [iris-contrib/graceful](https://github.com/iris-contrib/graceful) repository
- Move the mail package & its configs to the [iris-contrib/mail](https://github.com/iris-contrib/mail) repository

Note 1: iris.Config.Mail doesn't not logger exists, use `mail.Config` from the `iris-contrib/mail`, and `service:= mail.New(configs); service.Send(....)`.

Note 2: basicauth middleware's context key changed from `context.GetString(""auth"")` to `context.GetString(""user"")`.

Underline changes, libraries used by iris' base code:
- Move the errors package to the [iris-contrib/errors](https://github.com/iris-contrib/errors) repository
- Move the tests package to the [iris-contrib/tests](https://github.com/iris-contrib/tests) repository (Yes, you should make PRs now with no fear about breaking the Iris).

**NEW**:
- OAuth, OAuth2 support via plugin (facebook,gplus,twitter and 25 more), gitbook section [here](https://kataras.gitbooks.io/iris/content/plugin-oauth.html), plugin [example](https://github.com/iris-contrib/examples/blob/master/plugin_oauth_oauth2/main.go), low-level package example [here](https://github.com/iris-contrib/examples/tree/master/oauth_oauth2) (no performance differences, it's just a working version of [goth](https://github.com/markbates/goth) which is converted to work with Iris)
- JSON Web Tokens support via [this middleware](https://github.com/iris-contrib/middleware/tree/master/jwt), book section [here](https://kataras.gitbooks.io/iris/content/jwt.html), as requested [here](https://github.com/kataras/iris/issues/187).

**Fixes**:
- [Iris run fails when not running from ./](https://github.com/kataras/iris/issues/215)
- [Fix or disable colors in iris run](https://github.com/kataras/iris/issues/217).

Improvements to the `iris run` **command**, as requested [here](https://github.com/kataras/iris/issues/192).

[Book](https://kataras.gitbooks.io/iris/content/) and [examples](https://github.com/iris-contrib/examples) are **updated** also.

## 3.0.0-rc.1 -> 3.0.0-rc.2

New:
- `iris.MustUse/MustUseFunc`  - registers middleware for all route parties, all subdomains and all routes.
- iris control plugin re-written, added real time browser request logger
- `websocket.OnError` - Add OnError to be able to catch internal errors from the connection
- [command line tool](https://github.com/kataras/iris/tree/master/iris) - `iris run main.go` runs, watch and reload on source code changes. As requested [here](https://github.com/kataras/iris/issues/192)

Fixes: https://github.com/kataras/iris/issues/184 , https://github.com/kataras/iris/issues/175 .

## 3.0.0-beta.3, 3.0.0-beta.4 -> 3.0.0-rc.1

This version took me many days because the whole framework's underline code is rewritten after many many many 'yoga'. Iris is not so small anymore, so I (tried) to organized it a little better. Note that, today, you can just go to [iris.go](https://github.com/kataras/iris/tree/master/iris.go) and [context.go](https://github.com/kataras/iris/tree/master/context/context.go) and look what functions you can use. You had some 'bugs' to subdomains, mail service, basic authentication and logger, these are fixed also, see below...

All [examples](https://github.com/iris-contrib/examples) are updated, and I tested them one by one.

Many underline changes but the public API didn't changed much, of course this is relative to the way you use this framework, because that:
- Configuration changes: **0**
- iris.Iris pointer -> **iris.Framework** pointer
- iris.DefaultIris -> **iris.Default**
- iris.Config() -> **iris.Config** is field now
- iris.Websocket() -> **iris.Websocket** is field now
- iris.Logger() -> **iris.Logger** is field now
- iris.Plugins() -> **iris.Plugins** is field now
- iris.Server() -> **iris.HTTPServer** is field now
- iris.Rest() -> **REMOVED**
- iris.Mail() -> **REMOVED**
- iris.Mail().Send() -> **iris.SendMail()**
- iris.Templates() -> **REMOVED**
- iris.Templates().RenderString() -> **iris.TemplateString()**
- iris.StaticHandlerFunc -> **iris.StaticHandler**
- iris.URIOf() -> **iris.URL()**
- iris.PathOf() -> **iris.Path()**
- context.RenderString() returned string,error -> **context.TemplateString() returns only string, which is empty on any parse error**
- context.WriteHTML() -> **context.HTML()**
- context.HTML() -> **context.RenderWithStatus()**

Entirely new
-  -> **iris.ListenUNIX(addr string, socket os.Mode)**
-  -> **context.MustRender, same as Render but send response 500 and logs the error on parse error**
-  -> **context.Log(format string, a...interface{})**
-  -> **context.PostFormMulti(name string) []string**
-  -> **iris.Lookups() []Route**
-  -> **iris.Lookup(routeName string) Route**
-  -> **iris.Plugins.On(eventName string, ...func())** and fire all by **iris.Plugins.Call(eventName)**
- iris.Wildcard() **REMOVED**, subdomains and dynamic(wildcard) subdomains can only be registered with **iris.Party(""mysubdomain."") && iris.Party(""*."")**

Semantic change for static subdomains

**1**

**BEFORE** :

``` go
apiSubdomain := iris.Party(""api.mydomain.com"")
{
//....
}
iris.Listen(""mydomain.com:80"")
```

**NOW** just subdomain part, no need to duplicate ourselves:

``` go
apiSubdomain := iris.Party(""api."")
{
//....
}
iris.Listen(""mydomain.com:80"")
```

**2**

Before you couldn't set dynamic subdomains and normal subdomains at the same iris station, now you can.
**NOW, this is possible**

``` go
/* admin.mydomain.com,  and for other subdomains the Party(*.) */

admin := iris.Party(""admin."")
{
    // admin.mydomain.com
    admin.Get(""/"", func(c *iris.Context) {
        c.Write(""INDEX FROM admin.mydomain.com"")
    })
    // admin.mydomain.com/hey
    admin.Get(""/hey"", func(c *iris.Context) {
        c.Write(""HEY FROM admin.mydomain.com/hey"")
    })
    // admin.mydomain.com/hey2
    admin.Get(""/hey2"", func(c *iris.Context) {
        c.Write(""HEY SECOND FROM admin.mydomain.com/hey"")
    })
}

// other.mydomain.com, otadsadsadsa.mydomain.com  and so on....
dynamicSubdomains := iris.Party(""*."")
{
    dynamicSubdomains.Get(""/"", dynamicSubdomainHandler)

    dynamicSubdomains.Get(""/something"", dynamicSubdomainHandler)

    dynamicSubdomains.Get(""/something/:param1"", dynamicSubdomainHandlerWithParam)
}
```

Minor change for listen

**BEFORE you could just listen to a port**

``` go
iris.Listen(""8080"")
```

**NOW you have set a HOSTNAME:PORT**

``` go
iris.Listen("":8080"")
```

Relative issues/features:  https://github.com/kataras/iris/issues/166 , https://github.com/kataras/iris/issues/176, https://github.com/kataras/iris/issues/183,  https://github.com/kataras/iris/issues/184

**Plugins**

PreHandle and PostHandle are removed, no need to use them anymore you can take routes by **iris.Lookups()**, but add support for custom event listeners by **iris.Plugins.On(""event"",func(){})** and fire all callbacks by **iris.Plugins.Call(""event"")** .

**FOR TESTERS**

**BEFORE** :

``` go
api := iris.New()
//...

api.PreListen(config.Server{ListeningAddr: """"})

e := httpexpect.WithConfig(httpexpect.Config{
    Reporter: httpexpect.NewAssertReporter(t),
    Client:   fasthttpexpect.NewBinder(api.ServeRequest),
})

```

**NOW**:

``` go
api := iris.New()
//...

e := httpexpect.WithConfig(httpexpect.Config{
    Reporter: httpexpect.NewAssertReporter(t),
    Client:   fasthttpexpect.NewBinder(api.NoListen().Handler),
})


```

## 3.0.0-beta.2 -> 3.0.0-beta.3
- Complete the Jade Template Engine support, {{ render }} and {{ url }} done also.
- Fix Mail().Send
- Iriscontrol plugin: Replace login using session to basic authentication

And other not-too-important fixes

## 3.0.0-beta -> 3.0.0-beta.2
- NEW: Wildcard(dynamic) subdomains, read [here](https://kataras.gitbooks.io/iris/content/subdomains.html)
- NEW: Implement feature request [#165](https://github.com/kataras/iris/issues/165). Routes can now be selected by `a custom name`, and this allows us to use the {{ url ""custom-name"" ""any"" ""named"" ""parameters""}}``: For HTML & Amber engines, example [here](https://github.com/iris-contrib/examples/tree/master/templates_9). For PongoEngine, example [here](https://github.com/iris-contrib/examples/tree/master/templates_10_pongo)
- Remove the [x/net/context](https://godoc.org/golang.org/x/net/context), it has been useless after v2.

## 3.0.0-alpha.beta -> 3.0.0-beta
- New iris.API for easy API declaration, read more [here](https://kataras.gitbooks.io/iris/content/using-handlerapi.html), example [there](https://github.com/iris-contrib/examples/tree/master/api_handler_2).
- Add [example](https://github.com/iris-contrib/examples/tree/master/middleware_basicauth_2) and fix the Basic Authentication middleware

## 3.0.0-alpha.6 -> 3.0.0-alpha.beta
- [Implement feature request to add Globals on the pongo2](https://github.com/kataras/iris/issues/145)
- [Implement feature request for static Favicon ](https://github.com/kataras/iris/issues/141)
- Implement a unique easy only-websocket support:

``` go
OnConnection(func(c websocket.Connection){})
```

websocket.Connection

``` go

// Receive from the client
On(""anyCustomEvent"", func(message string) {})
On(""anyCustomEvent"", func(message int){})
On(""anyCustomEvent"", func(message bool){})
On(""anyCustomEvent"", func(message anyCustomType){})
On(""anyCustomEvent"", func(){})

// Receive a native websocket message from the client
// compatible without need of import the iris-ws.js to the .html
OnMessage(func(message []byte){})

// Send to the client
Emit(""anyCustomEvent"", string)
Emit(""anyCustomEvent"", int)
Emit(""anyCustomEvent"", bool)
Emit(""anyCustomEvent"", anyCustomType)

// Send via native websocket way, compatible without need of import the iris-ws.js to the .html
EmitMessage([]byte(""anyMessage""))

// Send to specific client(s)
To(""otherConnectionId"").Emit/EmitMessage...
To(""anyCustomRoom"").Emit/EmitMessage...

// Send to all opened connections/clients
To(websocket.All).Emit/EmitMessage...

// Send to all opened connections/clients EXCEPT this client(c)
To(websocket.NotMe).Emit/EmitMessage...

// Rooms, group of connections/clients
Join(""anyCustomRoom"")
Leave(""anyCustomRoom"")


// Fired when the connection is closed
OnDisconnect(func(){})

```
- [Example](https://github.com/iris-contrib/examples/tree/master/websocket)
- [E-book section](https://kataras.gitbooks.io/iris/content/package-websocket.html)

We have some base-config's changed, these configs which are defaulted to true renamed to 'Disable+$oldName'

``` go

        // DisablePathCorrection corrects and redirects the requested path to the registed path
        // for example, if /home/ path is requested but no handler for this Route found,
        // then the Router checks if /home handler exists, if yes,
        // (permant)redirects the client to the correct path /home
        //
        // Default is false
        DisablePathCorrection bool

        // DisablePathEscape when is false then its escapes the path, the named parameters (if any).
        // Change to true it if you want something like this https://github.com/kataras/iris/issues/135 to work
        //
        // When do you need to Disable(true) it:
        // accepts parameters with slash '/'
        // Request: http://localhost:8080/details/Project%2FDelta
        // ctx.Param(""project"") returns the raw named parameter: Project%2FDelta
        // which you can escape it manually with net/url:
        // projectName, _ := url.QueryUnescape(c.Param(""project"").
        // Look here: https://github.com/kataras/iris/issues/135 for more
        //
        // Default is false
        DisablePathEscape bool

        // DisableLog turn it to true if you want to disable logger,
        // Iris prints/logs ONLY errors, so be careful when you enable it
        DisableLog bool

        // DisableBanner outputs the iris banner at startup
        //
        // Default is false
        DisableBanner bool

```

## 3.0.0-alpha.5 -> 3.0.0-alpha.6

Changes:
    - config/iris.Config().Render.Template.HTMLTemplate.Funcs typeof `[]template.FuncMap` -> `template.FuncMap`

Added:
    - iris.AmberEngine [Amber](https://github.com/eknkc/amber). [View an example](https://github.com/iris-contrib/examples/tree/master/templates_7_html_amber)
    - iris.JadeEngine [Jade](https://github.com/Joker/jade). [View an example](https://github.com/iris-contrib/examples/tree/master/templates_6_html_jade)

Book section [Render/Templates updated](https://kataras.gitbooks.io/iris/content/render_templates.html)

## 3.0.0-alpha.4 -> 3.0.0-alpha.5
- [NoLayout support for particular templates](https://github.com/kataras/iris/issues/130#issuecomment-219754335)
- [Raw Markdown Template Engine](https://kataras.gitbooks.io/iris/content/render_templates.html)
- [Markdown to HTML](https://kataras.gitbooks.io/iris/content/render_rest.html) > `context.Markdown(statusCode int, markdown string)` , `context.MarkdownString(markdown string) (htmlReturn string)`
- [Simplify the plugin registration](https://github.com/kataras/iris/issues/126#issuecomment-219622481)

## 3.0.0-alpha.3 -> 3.0.0-alpha.4

Community suggestions implemented:
- [Request: Rendering html template to string](https://github.com/kataras/iris/issues/130)
  > New RenderString(name string, binding interface{}, layout ...string) added to the Context & the Iris' station (iris.Templates().RenderString)
- [Minify Templates](https://github.com/kataras/iris/issues/129)
  > New config field for minify, defaulted to true: iris.Config().Render.Template.Minify  = true
  > 3.0.0-alpha5+ this has been removed because the minify package has bugs, one of them is this: https://github.com/tdewolff/minify/issues/35.

Bugfixes and enhancements:
- [Static not allowing configuration of `IndexNames`](https://github.com/kataras/iris/issues/128)
- [Processing access error](https://github.com/kataras/iris/issues/125)
- [Invalid header](https://github.com/kataras/iris/issues/123)

## 3.0.0-alpha.2 -> 3.0.0-alpha.3

The only change here is a panic-fix on form bindings. Now **no need to make([]string,0)** before form binding, new example:

``` go
 //./main.go

package main

import (
    ""fmt""

    ""github.com/kataras/iris""
)

type Visitor struct {
    Username string
    Mail     string
    Data     []string `form:""mydata""`
}

func main() {

    iris.Get(""/"", func(ctx *iris.Context) {
        ctx.Render(""form.html"", nil)
    })

    iris.Post(""/form_action"", func(ctx *iris.Context) {
        visitor := Visitor{}
        err := ctx.ReadForm(&visitor)
        if err != nil {
            fmt.Println(""Error when reading form: "" + err.Error())
        }
        fmt.Printf(""\n Visitor: %v"", visitor)
    })

    fmt.Println(""Server is running at :8080"")
    iris.Listen("":8080"")
}

```

``` html

<!-- ./templates/form.html -->
<!DOCTYPE html>
<head>
<meta charset=""utf-8"">
</head>
<body>
<form action=""/form_action"" method=""post"">
<input type=""text"" name=""Username"" />
<br/>
<input type=""text"" name=""Mail"" /><br/>
<select multiple=""multiple"" name=""mydata"">
<option value='one'>One</option>
<option value='two'>Two</option>
<option value='three'>Three</option>
<option value='four'>Four</option>
</select>
<hr/>
<input type=""submit"" value=""Send data"" />

</form>
</body>
</html>

```

## 3.0.0-alpha.1 -> 3.0.0-alpha.2

_The e-book was updated, take a closer look [here](https://www.gitbook.com/book/kataras/iris/details)_

**Breaking changes**

**First**. Configuration owns a package now `github.com/kataras/iris/config` . I took this decision after a lot of thought and I ensure you that this is the best
architecture to easy:
- change the configs without need to re-write all of their fields.
  
  ``` go
  irisConfig := config.Iris { Profile: true, PathCorrection: false }
  api := iris.New(irisConfig)
  ```
- easy to remember: `iris` type takes config.Iris, sessions takes config.Sessions`,`iris.Config().Render`is`config.Render`,`iris.Config().Render.Template`is`config.Template`,`Logger`takes`config.Logger` and so on...
- easy to find what features are exists and what you can change: just navigate to the config folder and open the type you want to learn about, for example `/iris.go` Iris' type configuration is on `/config/iris.go`
- default setted fields which you can use. They are already setted by iris, so don't worry too much, but if you ever need them you can find their default configs by this pattern: for example `config.Template` has `config.DefaultTemplate()`, `config.Rest` has `config.DefaultRest()`, `config.Typescript()` has `config.DefaultTypescript()`, note that only `config.Iris` has `config.Default()`. I wrote that all structs even the plugins have their default configs now, to make it easier for you, so you can do this without set a config by yourself: `iris.Config().Render.Template.Engine = config.PongoEngine` or `iris.Config().Render.Template.Pongo.Extensions = []string{"".xhtml"", "".html""}`.

**Second**. Template & rest package moved to the `render`, so

```
    *  a new config field named `render` of type `config.Render` which nests the `config.Template` & `config.Rest`
    -  `iris.Config().Templates` -> `iris.Config().Render.Template` of type `config.Template`
    - `iris.Config().Rest` -> `iris.Config().Render.Rest` of type `config.Rest`
```

**Third, sessions**.

Configuration instead of parameters. Before `sessions.New(""memory"",""sessionid"",time.Duration(42) * time.Minute)` -> Now:  `sessions.New(config.DefaultSessions())` of type `config.Sessions`
- Before this change the cookie's life was the same as the manager's Gc duration. Now added an Expires option for the cookie's life time which defaults to infinitive, as you (correctly) suggests me in the chat community.-
- Default Cookie's expiration date: from 42 minutes -> to  `infinitive/forever`
- Manager's Gc duration: from 42 minutes -> to '2 hours'
- Redis store's MaxAgeSeconds: from 42 minutes -> to '1 year`

**Four**. Typescript, Editor & IrisControl plugins now accept a config.Typescript/ config.Editor/ config.IrisControl as parameter

Bugfixes
- [can't open /xxx/ path when PathCorrection = false ](https://github.com/kataras/iris/issues/120)
- [Invalid content on links on debug page when custom ProfilePath is set](https://github.com/kataras/iris/issues/118)
- [Example with custom config not working ](https://github.com/kataras/iris/issues/115)
- [Debug Profiler writing escaped HTML?](https://github.com/kataras/iris/issues/107)
- [CORS middleware doesn't work](https://github.com/kataras/iris/issues/108)

## 2.3.2 -> 3.0.0-alpha.1

**Changed**
- `&render.Config` -> `&iris.RestConfig` . All related to the html/template are removed from there.
- `ctx.Render(""index"",...)` -> `ctx.Render(""index.html"",...)` or any extension you have defined in iris.Config().Templates.Extensions
- `iris.Config().Render.Layout = ""layouts/layout""` -> `iris.Config().Templates.Layout = ""layouts/layout.html""`
- `License BSD-3 Clause Open source` -> `MIT License`
  **Added**
- Switch template engines via `IrisConfig`. Currently, HTMLTemplate is 'html/template'. Pongo is 'flosch/pongo2`. Refer to the Book, which is updated too, [read here](https://kataras.gitbooks.io/iris/content/render.html).
",,,,https://api.github.com/repos/kataras/iris/releases/5520652/assets,https://api.github.com/repos/kataras/iris/releases/5520652,5.0.0,https://api.github.com/repos/kataras/iris/tarball/v5,https://github.com/kataras/iris/releases/tag/v5,https://api.github.com/repos/kataras/iris/zipball/v5,v5,False,False
4523635,2016-10-31T06:41:49Z,2016-10-31T06:51:17Z,v4,"## v3 -> v4 (fasthttp-based) long term support
- **NEW FEATURE**: `CacheService` simple, cache service for your app's static body content(can work as external service if you are doing horizontal scaling, the `Cache` is just a `Handler` :) )

Cache any content, templates, static files, even the error handlers, anything.

> Bombardier: 5 million requests and 100k clients per second to this markdown  static content(look below) with cache(3 seconds) can be served up to ~x12 times faster. Imagine what happens with bigger content like full page and templates!

**OUTLINE**

``` go

// Cache is just a wrapper for a route's handler which you want to enable body caching
// Usage: iris.Get(""/"", iris.Cache(func(ctx *iris.Context){
//    ctx.WriteString(""Hello, world!"") // or a template or anything else
// }, time.Duration(10*time.Second))) // duration of expiration
// if <=time.Second then it tries to find it though request header's ""cache-control"" maxage value
//
// Note that it depends on a station instance's cache service.
// Do not try to call it from default' station if you use the form of app := iris.New(),
// use the app.Cache instead of iris.Cache
Cache(bodyHandler HandlerFunc, expiration time.Duration) HandlerFunc

// InvalidateCache clears the cache body for a specific context's url path(cache unique key)
//
// Note that it depends on a station instance's cache service.
// Do not try to call it from default' station if you use the form of app := iris.New(),
// use the app.InvalidateCache instead of iris.InvalidateCache
InvalidateCache(ctx *Context)


```

**OVERVIEW**

``` go
iris.Get(""/hi"", iris.Cache(func(c *iris.Context) {
    c.WriteString(""Hi this is a big content, do not try cache on small content it will not make any significant difference!"")
}, time.Duration(10)*time.Second))

```

[EXAMPLE](https://github.com/iris-contrib/examples/tree/master/cache_body):

``` go
package main

import (
    ""github.com/kataras/iris""
    ""time""
)

var testMarkdownContents = `## Hello Markdown from Iris

This is an example of Markdown with Iris



Features
--------

All features of Sundown are supported, including:

*   **Compatibility**. The Markdown v1.0.3 test suite passes with
    the --tidy option.  Without --tidy, the differences are
    mostly in whitespace and entity escaping, where blackfriday is
    more consistent and cleaner.

*   **Common extensions**, including table support, fenced code
    blocks, autolinks, strikethroughs, non-strict emphasis, etc.

*   **Safety**. Blackfriday is paranoid when parsing, making it safe
    to feed untrusted user input without fear of bad things
    happening. The test suite stress tests this and there are no
    known inputs that make it crash.  If you find one, please let me
    know and send me the input that does it.

    NOTE: ""safety"" in this context means *runtime safety only*. In order to
    protect yourself against JavaScript injection in untrusted content, see
    [this example](https://github.com/russross/blackfriday#sanitize-untrusted-content).

*   **Fast processing**. It is fast enough to render on-demand in
    most web applications without having to cache the output.

*   **Thread safety**. You can run multiple parsers in different
    goroutines without ill effect. There is no dependence on global
    shared state.

*   **Minimal dependencies**. Blackfriday only depends on standard
    library packages in Go. The source code is pretty
    self-contained, so it is easy to add to any project, including
    Google App Engine projects.

*   **Standards compliant**. Output successfully validates using the
    W3C validation tool for HTML 4.01 and XHTML 1.0 Transitional.

    [this is a link](https://github.com/kataras/iris) `

func main() {
    // if this is not setted then iris set this duration to the lowest expiration entry from the cache + 5 seconds
    // recommentation is to left as it's or
    // iris.Config.CacheGCDuration = time.Duration(5) * time.Minute

    bodyHandler := func(ctx *iris.Context) {
        ctx.Markdown(iris.StatusOK, testMarkdownContents)
    }

    expiration := time.Duration(5 * time.Second)

    iris.Get(""/"", iris.Cache(bodyHandler, expiration))

    // if expiration is <=time.Second then the cache tries to set the expiration from the ""cache-control"" maxage header's value(in seconds)
    // // if this header doesn't founds then the default is 5 minutes
    iris.Get(""/cache_control"", iris.Cache(func(ctx *iris.Context) {
        ctx.HTML(iris.StatusOK, ""<h1>Hello!</h1>"")
    }, -1))

    iris.Listen("":8080"")
}

```
- **IMPROVE**: [Iris command line tool](https://github.com/kataras/iris/tree/master/iris) introduces a **new** `get` command (replacement for the old `create`)

**The get command** downloads, installs and runs a project based on a `prototype`, such as `basic`, `static` and `mongo` .

> These projects are located [online](https://github.com/iris-contrib/examples/tree/master/AIO_examples)

``` sh
iris get basic
```

Downloads the  [basic](https://github.com/iris-contrib/examples/tree/master/AIO_examples/basic) sample protoype project to the `$GOPATH/src/github.com/iris-contrib/examples` directory(the iris cmd will open this folder to you, automatically) builds, runs and watch for source code changes (hot-reload)

[![Iris get command preview](https://raw.githubusercontent.com/iris-contrib/website/gh-pages/assets/iriscmd.gif)](https://raw.githubusercontent.com/iris-contrib/website/gh-pages/assets/iriscmd.gif)
- **CHANGE**: The `Path parameters` are now **immutable**. Now you don't have to copy a `path parameter` before passing to another function which maybe modifies it, this has a side-affect of `context.GetString(""key"") = context.Param(""key"")`  so you have to be careful to not override a path parameter via other custom (per-context) user value.
- **NEW**: `iris.StaticEmbedded`/`app := iris.New(); app.StaticEmbedded` - Embed static assets into your executable with [go-bindata](https://github.com/jteeuwen/go-bindata) and serve them.

> Note: This was already buitl'n feature for templates using `iris.UseTemplate(html.New()).Directory(""./templates"","".html"").Binary(Asset,AssetNames)`, after v4.6.1 you can do that for other static files too, with the `StaticEmbedded` function

**outline**

``` go

// StaticEmbedded  used when files are distrubuted inside the app executable, using go-bindata mostly
// First parameter is the request path, the path which the files in the vdir(second parameter) will be served to, for example ""/static""
// Second parameter is the (virtual) directory path, for example ""./assets""
// Third parameter is the Asset function
// Forth parameter is the AssetNames function
//
// For more take a look at the
// example: https://github.com/iris-contrib/examples/tree/master/static_files_embedded
StaticEmbedded(requestPath string, vdir string, assetFn func(name string) ([]byte, error), namesFn func() []string) RouteNameFunc

```

**example**

You can view and run it from [here](https://github.com/iris-contrib/examples/tree/master/static_files_embedded) *

``` go
package main

// First of all, execute: $ go get https://github.com/jteeuwen/go-bindata
// Secondly, execute the command: cd $GOPATH/src/github.com/iris-contrib/examples/static_files_embedded && go-bindata ./assets/...

import (
    ""github.com/kataras/iris""
)

func main() {

    // executing this go-bindata command creates a source file named 'bindata.go' which
    // gives you the Asset and AssetNames funcs which we will pass into .StaticAssets
    // for more viist: https://github.com/jteeuwen/go-bindata
    // Iris gives you a way to integrade these functions to your web app

    // For the reason that you may use go-bindata to embed more than your assets, you should pass the 'virtual directory path', for example here is the : ""./assets""
    // and the request path, which these files will be served to, you can set as ""/assets"" or ""/static"" which resulting on http://localhost:8080/static/*anyfile.*extension
    iris.StaticEmbedded(""/static"", ""./assets"", Asset, AssetNames)


    // that's all
    // this will serve the ./assets (embedded) files to the /static request path for example the favicon.ico will be served as :
    // http://localhost:8080/static/favicon.ico
    // Methods: GET and HEAD



    iris.Get(""/"", func(ctx *iris.Context) {
        ctx.HTML(iris.StatusOK, ""<b> Hi from index</b>"")
    })

    iris.Listen("":8080"")
}

// Navigate to:
// http://localhost:8080/static/favicon.ico
// http://localhost:8080/static/js/jquery-2.1.1.js
// http://localhost:8080/static/css/bootstrap.min.css

// Now, these files are stored inside into your executable program, no need to keep it in the same location with your assets folder.


```
- **FIX**: httptest flags caused by httpexpect which used to help you with tests inside **old** func `iris.Tester` as reported [here](https://github.com/kataras/iris/issues/337#issuecomment-253429976)
- **NEW**: `iris.ResetDefault()` func which resets the default iris instance which is the station for the most part of the public/package API
- **NEW**: package `httptest` with configuration which can be passed per 'tester' instead of iris instance( this is very helpful for testers)
- **CHANGED**: All tests are now converted for 'white-box' testing, means that tests now have package named: `iris_test` instead of `iris` in the same main directory.
- **CHANGED**: `iris.Tester` moved to `httptest.New` which lives inside the new `/kataras/iris/httptest` package, so:

**old**

``` go
import (
    ""github.com/kataras/iris""
    ""testing""
)

func MyTest(t *testing.T) {
    iris.Get(""/mypath"", func(ctx *iris.Context){
        ctx.Write(""my body"")
    })
    // with configs: iris.Config.Tester.ExplicitURL/Debug = true
    e:= iris.Tester(t)
    e.GET(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""my body"")
}
```

**used that instead/new**

``` go
import (
    ""github.com/kataras/iris/httptest""
    ""github.com/kataras/iris""
    ""testing""
)

func MyTest(t *testing.T) {
    // make sure that you reset your default station if you don't use the form of app := iris.New()
    iris.ResetDefault()

    iris.Get(""/mypath"", func(ctx *iris.Context){
        ctx.Write(""my body"")
    })

    e:= httptest.New(iris.Default, t)
    // with configs: e:= httptest.New(iris.Default, t, httptest.ExplicitURL(true), httptest.Debug(true))
    e.GET(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""my body"")
}
```

Finally, some plugins container's additions:
- **NEW**: `iris.Plugins.Len()` func which returns the length of the current activated plugins in the default station
- **NEW**: `iris.Plugins.Fired(""event"") int` func which returns how much times and from how many plugins a particular event type is fired, event types are: `""prelookup"", ""prebuild"", ""prelisten"", ""postlisten"", ""preclose"", ""predownload""`
- **NEW**: `iris.Plugins.PreLookupFired() bool` func which returns true if `PreLookup` fired at least one time
- **NEW**: `iris.Plugins.PreBuildFired() bool` func which returns true if `PreBuild` fired at least one time
- **NEW**: `iris.Plugins.PreListenFired() bool` func which returns true if `PreListen/PreListenParallel` fired at least one time
- **NEW**: `iris.Plugins.PostListenFired() bool` func which returns true if `PostListen` fired at least one time
- **NEW**: `iris.Plugins.PreCloseFired() bool` func which returns true if `PreClose` fired at least one time
- **NEW**: `iris.Plugins.PreDownloadFired() bool` func which returns true if `PreDownload` fired at least one time
- **Feature request**: I never though that it will be easier for users to catch 405 instead of simple 404, I though that will make your life harder, but it's requested by the Community [here](https://github.com/kataras/iris/issues/469), so I did my duty. Enable firing Status Method Not Allowed (405) with a simple configuration field: `iris.Config.FireMethodNotAllowed=true` or `iris.Set(iris.OptionFireMethodNotAllowed(true))` or `app := iris.New(iris.Configuration{FireMethodNotAllowed:true})`. A trivial, test example can be shown here:

``` go
func TestMuxFireMethodNotAllowed(t *testing.T) {

    iris.Config.FireMethodNotAllowed = true // enable catching 405 errors

    h := func(ctx *iris.Context) {
        ctx.Write(""%s"", ctx.MethodString())
    }

    iris.OnError(iris.StatusMethodNotAllowed, func(ctx *iris.Context) {
        ctx.Write(""Hello from my custom 405 page"")
    })

    iris.Get(""/mypath"", h)
    iris.Put(""/mypath"", h)

    e := iris.Tester(t)

    e.GET(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""GET"")
    e.PUT(""/mypath"").Expect().Status(iris.StatusOK).Body().Equal(""PUT"")
    // this should fail with 405 and catch by the custom http error

    e.POST(""/mypath"").Expect().Status(iris.StatusMethodNotAllowed).Body().Equal(""Hello from my custom 405 page"")
    iris.Close()
}
```
- **NEW**: `PreBuild` plugin type, raises before `.Build`. Used by third-party plugins to register any runtime routes or make any changes to the iris main configuration, example of this usage is the [OAuth/OAuth2 Plugin](https://github.com/iris-contrib/plugin/tree/master/oauth).
- **FIX**: The [OAuth example](https://github.com/iris-contrib/examples/tree/master/plugin_oauth_oauth2).
- **NEW**: Websocket configuration fields:
  - `Error func(ctx *Context, status int, reason string)`. Manually catch  any handshake errors. Default calls the `ctx.EmitError(status)` with a stored error message in the `WsError` key(`ctx.Set(""WsError"", reason)`), as before.
  - `CheckOrigin func(ctx *Context)`. Manually allow or dissalow client's websocket access, ex: via header **Origin**. Default allow all origins(CORS-like) as before.
  - `Headers bool`. Allow websocket handler to copy request's headers on the handshake. Default is true
    With these in-mind the `WebsocketConfiguration` seems like this now :

``` go
type WebsocketConfiguration struct {
    // WriteTimeout time allowed to write a message to the connection.
    // Default value is 15 * time.Second
    WriteTimeout time.Duration
    // PongTimeout allowed to read the next pong message from the connection
    // Default value is 60 * time.Second
    PongTimeout time.Duration
    // PingPeriod send ping messages to the connection with this period. Must be less than PongTimeout
    // Default value is (PongTimeout * 9) / 10
    PingPeriod time.Duration
    // MaxMessageSize max message size allowed from connection
    // Default value is 1024
    MaxMessageSize int64
    // BinaryMessages set it to true in order to denotes binary data messages instead of utf-8 text
    // see https://github.com/kataras/iris/issues/387#issuecomment-243006022 for more
    // defaults to false
    BinaryMessages bool
    // Endpoint is the path which the websocket server will listen for clients/connections
    // Default value is empty string, if you don't set it the Websocket server is disabled.
    Endpoint string
    // ReadBufferSize is the buffer size for the underline reader
    ReadBufferSize int
    // WriteBufferSize is the buffer size for the underline writer
    WriteBufferSize int
    // Headers  if true then the client's headers are copy to the websocket connection
    //
    // Default is true
    Headers bool
    // Error specifies the function for generating HTTP error responses.
    //
    // The default behavior is to store the reason in the context (ctx.Set(reason)) and fire any custom error (ctx.EmitError(status))
    Error func(ctx *Context, status int, reason string)
    // CheckOrigin returns true if the request Origin header is acceptable. If
    // CheckOrigin is nil, the host in the Origin header must not be set or
    // must match the host of the request.
    //
    // The default behavior is to allow all origins
    // you can change this behavior by setting the iris.Config.Websocket.CheckOrigin = iris.WebsocketCheckSameOrigin
    CheckOrigin func(ctx *Context) bool
}

```
- **REMOVE**: `github.com/kataras/iris/context/context.go` , this is no needed anymore. Its only usage was inside `sessions` and `websockets`, a month ago I did improvements to the sessions as a standalone package, the IContext interface is not being used there. With the today's changes, the iris-contrib/websocket doesn't needs the IContext interface too, so the whole folder `./context` is useless and removed now. Users developers don't have any side-affects from this change.  

[Examples](https://github.com/iris-contrib/examples), [Book](https://github.com/iris-contrib/gitbook) are up-to-date, just new configuration fields.
- **FIX**: Previous CORS fix wasn't enough and produces error before server's startup[*](https://github.com/kataras/iris/issues/461) if many paths were trying to auto-register an `.OPTIONS` route, now this is fixed in combined with some improvements on the [cors middleware](https://github.com/iris-contrib/middleware/tree/master/cors) too.
- **NEW**: `BodyDecoder` gives the ability to set a custom decoder **per passed object** when `context.ReadJSON` and `context.ReadXML`

``` go
// BodyDecoder is an interface which any struct can implement in order to customize the decode action
// from ReadJSON and ReadXML
//
// Trivial example of this could be:
// type User struct { Username string }
//
// func (u *User) Decode(data []byte) error {
//    return json.Unmarshal(data, u)
// }
//
// the 'context.ReadJSON/ReadXML(&User{})' will call the User's
// Decode option to decode the request body
//
// Note: This is totally optionally, the default decoders
// for ReadJSON is the encoding/json and for ReadXML is the encoding/xml
type BodyDecoder interface {
    Decode(data []byte) error
}

```

> for a usage example go to https://github.com/kataras/iris/blob/master/context_test.go#L262
- **small fix**: websocket server is nil when more than the default websocket station tries to be registered before `OnConnection` called[*](https://github.com/kataras/iris/issues/460)
- **FIX**: CORS not worked for all http methods
- **FIX**: Unexpected Party root's route slash  when `DisablePathCorrection` is false(default), as reported [here](https://github.com/kataras/iris/issues/453)
- **small fix**: DisablePathEscape not affects the uri string
- **small fix**: when Path Correction on POST redirect to the GET instead of POST
- **NEW**: Template PreRenders, as requested [here](https://github.com/kataras/iris/issues/412).

``` go
// ...
iris.UsePreRender(func(ctx *iris.Context, filename string, binding interface{}, options ...map[string]interface{}) bool {
    // put the 'Error' binding here, for the shake of the test
    if b, isMap := binding.(map[string]interface{}); isMap {
        b[""Error""] = ""error!""
    }
    // true= continue to the next PreRender
  // false= do not continue to the next PreRender
  // * but the actual Render will be called at any case *
  return true
})

iris.Get(""/"", func(ctx *Context) {
    ctx.Render(""hi.html"", map[string]interface{}{""Username"": ""anybody""})
    // hi.html: <h1>HI {{.Username}}. Error: {{.Error}}</h1>
})

// ...
```

**NOTE**: For normal users this update offers nothing, read that only if you run Iris behind a proxy or balancer like `nginx` or you need to serve using a custom `net.Listener`.

This update implements the [support of using native servers and net.Listener instead of Iris' defined](https://github.com/kataras/iris/issues/438).

### Breaking changes
- `iris.Config.Profile` field removed and the whole pprof transfered to the [iris-contrib/middleware/pprof](https://github.com/iris-contrib/middleware/tree/master/pprof).
- `iris.ListenTLSAuto` renamed to `iris.ListenLETSENCRYPT`
- `iris.Default.Handler` is `iris.Router` which is the Handler you can use to setup a custom router or bind Iris' router, after `iris.Build` call, to an external custom server.
- `iris.ServerConfiguration`, `iris.ListenVirtual`, `iris.AddServer`, `iris.Go` & `iris.TesterConfiguration.ListeningAddr` removed, read below the reason and their alternatives

### New features
- Boost Performance on server's startup
- **NEW**: `iris.Reserve()` re-starts the server if `iris.Close()` called previously.
- **NEW**: `iris.Config.VHost` and `iris.Config.VScheme` replaces the previous `ListenVirtual`, `iris.TesterConfiguration.ListeningAddr`, `iris.ServerConfiguration.VListeningAddr`, `iris.ServerConfiguration.VScheme`.
- **NEW**: `iris.Build` it's called automatically on Listen functions or Serve function. **CALL IT, MANUALLY, ONLY** WHEN YOU WANT TO BE ABLE TO GET THE IRIS ROUTER(`iris.Router`) AND PASS THAT, HANDLER, TO ANOTHER EXTERNAL FASTHTTP SERVER.
- **NEW**: `iris.Serve(net.Listener)`. Starts the server using a custom net.Listener, look below for example link
- **NEW**: now that iris supports custom net.Listener bind, I had to provide to you some net.Listeners too, such as `iris.TCP4`, `iris.UNIX`, `iris.TLS` , `iris.LETSENCRPYPT` & `iris.CERT` , all of these are optionals because you can just use the `iris.Listen`, `iris.ListenUNIX`, `iris.ListenTLS` & `iris.ListenLETSENCRYPT`, but if you want, for example, to pass your own `tls.Config` then you will have to create a custom net.Listener and pass that to the `iris.Serve(net.Listener)`.

With these in mind, developers are now able to fill their advanced needs without use the `iris.AddServer, ServerConfiguration and V fields`, so it's easier to:
- use any external (fasthttp compatible) server or router. Examples: [server](https://github.com/iris-contrib/tree/master/custom_fasthtthttp_server) and [router]((https://github.com/iris-contrib/tree/master/custom_fasthtthttp_router)
- bind any `net.Listener` which will be used to run the Iris' HTTP server, as requested [here](https://github.com/kataras/iris/issues/395). Example [here](https://github.com/iris-contrib/tree/master/custom_net_listener)
- setup virtual host and scheme, useful when you run Iris behind `nginx` (etc) and want template function `{{url }}` and subdomains to work as you expected. Usage:

``` go
iris.Config.VHost = ""mydomain.com""
iris.Config.VScheme = ""https://""

iris.Listen("":8080"")

// this will run on localhost:8080 but templates, subdomains and all that will act like https://mydomain.com,
// before this update you used the iris.AddServer and iris.Go and pass some strange fields into

```

Last, for testers:

Who used the `iris.ListenVirtual(...).Handler`:
If closed server, then `iris.Build()` and `iris.Router`, otherwise just `iris.Router`.

To test subdomains or a custom domain just set the `iris.Config.VHost` and `iris.Config.VScheme` fields, instead of the old `subdomain_test_handler := iris.AddServer(iris.ServerConfiguration{VListeningAddr:""..."", Virtual: true, VScheme:false}).Handler`. Usage [here](https://github.com/kataras/blob/master/http_test.go).

**Finally**, I have to notify you that [examples](https://github.com/iris-contrib/examples), [plugins](https://github.com/iris-contrib/plugin), [middleware](https://github.com/iris-contrib/middleware) and [book](https://github.com/iris-contrib/gitbook) have been updated.
- Align with the latest version of [go-websocket](https://github.com/kataras/go-websocket), remove vendoring for compression on [go-fs](https://github.com/kataras/go-fs) which produced errors on sqllite and gorm(mysql and mongo worked fine before too) as reported [here](https://github.com/kataras/go-fs/issues/1).
- **External FIX**: [template syntax error causes a ""template doesn't exist""](https://github.com/kataras/iris/issues/415)
- **ADDED**: You are now able to use a raw fasthttp handler as the router instead of the default Iris' one. Example [here](https://github.com/iris-contrib/examples/blob/master/custom_fasthttp_router/main.go). But remember that I'm always recommending to use the Iris' default which supports subdomains, group of routes(parties), auto path correction and many other built'n features. This exists for specific users who told me that they need a feature like that inside Iris, we have no performance cost at all so that's ok to exists.
- **CHANGE**: Updater (See 4.2.4 and 4.2.3) runs in its own goroutine now, unless the `iris.Config.CheckForUpdatesSync` is true.
- **ADDED**: To align with fasthttp server's configuration, iris has these new Server Configuration's fields, which allows you to set a type of rate limit:

``` go
// Maximum number of concurrent client connections allowed per IP.
//
// By default unlimited number of concurrent connections
// may be established to the server from a single IP address.
MaxConnsPerIP int

// Maximum number of requests served per connection.
//
// The server closes connection after the last request.
// 'Connection: close' header is added to the last response.
//
// By default unlimited number of requests may be served per connection.
MaxRequestsPerConn int

// Usage: iris.ListenTo{iris.OptionServerListeningAddr("":8080""), iris.OptionServerMaxConnsPerIP(300)}
//    or: iris.ListenTo(iris.ServerConfiguration{ListeningAddr: "":8080"", MaxConnsPerIP: 300, MaxRequestsPerConn:100})
// for an optional second server with a different port you can always use:
//        iris.AddServer(iris.ServerConfiguration{ListeningAddr: "":9090"", MaxConnsPerIP: 300, MaxRequestsPerConn:100})
```
- **ADDED**: `iris.CheckForUpdates(force bool)` which can run the updater(look 4.2.4) at runtime too, updater is tested and worked at dev machine.
- **NEW Experimental feature**: Updater with a `CheckForUpdates` [configuration](https://github.com/kataras/iris/blob/master/configuration.go) field, as requested [here](https://github.com/kataras/iris/issues/401)

``` go
// CheckForUpdates will try to search for newer version of Iris based on the https://github.com/kataras/iris/releases
// If a newer version found then the app will ask the he dev/user if want to update the 'x' version
// if 'y' is pressed then the updater will try to install the latest version
// the updater, will notify the dev/user that the update is finished and should restart the App manually.
// Notes:
// 1. Experimental feature
// 2. If setted to true, the app will have a little startup delay
// 3. If you as developer edited the $GOPATH/src/github/kataras or any other Iris' Go dependencies at the past
//    then the update process will fail.
//
// Usage: iris.Set(iris.OptionCheckForUpdates(true)) or
//        iris.Config.CheckForUpdates = true or
//        app := iris.New(iris.OptionCheckForUpdates(true))
// Default is false
CheckForUpdates bool
```
- [Add IsAjax() convenience method](https://github.com/kataras/iris/issues/423)
- Fix [sessiondb issue 416](https://github.com/kataras/iris/issues/416)
- **CHANGE**: No front-end changes if you used the default response engines before. Response Engines to Serializers, `iris.ResponseEngine` `serializer.Serializer`, comes from `kataras/go-serializer` which is installed automatically when you upgrade iris with `-u` flag.
  - the repo ""github.com/iris-contrib/response"" is a clone of ""github.com/kataras/go-serializer"", to keep compatibility state. examples and gitbook updated to work with the last.
  - `iris.UseResponse(iris.ResponseEngine, ...string)func (string)` was used to register custom response engines, now you use: `iris.UseSerializer(key string, s serializer.Serializer)`.
  - `iris.ResponseString` same defintion but differnet name now: `iris.SerializeToString`

[Serializer examples](https://github.com/iris-contrib/examples/tree/master/serialize_engines) and [Book section](https://kataras.gitbooks.io/iris/content/serialize-engines.html) updated.
- **ADDED**: `iris.TemplateSourceString(src string, binding interface{}) string` this will parse the src raw contents to the template engine and return the string result & `context.RenderTemplateSource(status int, src string, binding interface{}, options ...map[string]interface{}) error` this will parse the src raw contents to the template engine and render the result to the client, as requseted [here](https://github.com/kataras/iris/issues/409).

This version has 'breaking' changes if you were, directly, passing custom configuration to a custom iris instance before.
As the TODO2 I had to think and implement a way to make configuration even easier and more simple to use.

With last changes in place, Iris is using new, cross-framework, and more stable packages made by me(so don't worry things are working and will as you expect) to render [templates](https://github.com/kataras/go-template), manage [sessions](https://github.com/kataras/go-sesions) and [websockets](https://github.com/kataras/go-websocket). So the `/kataras/iris/config` is no longer need to be there, we don't have core packages inside iris which need these configuration to other package-folder than the main anymore(in order to avoid the import-cycle), new file `/kataras/iris/configuration.go` is created for the configuration, which lives inside the main package, means that now:
- **if you want to pass directly configuration to a new custom iris instance, you don't have to import the github.com/kataras/iris/config package**

Naming changes:
- `config.Iris` -> `iris.Configuration`, which is the parent/main configuration. Added: `TimeFormat` and `Other` (pass any dynamic custom, other options there)
- `config.Sessions` -> `iris.SessionsConfiguration`
- `config.Websocket` -> `iris.WebscoketConfiguration`
- `config.Server` -> `iris.ServerConfiguration`
- `config.Tester` -> `iris.TesterConfiguration`

All these changes wasn't made only to remove the `./config` folder but to make easier for you to pass the exact configuration field/option you need to edit at the top of the default configuration, without need to pass the whole Configuration object. **Attention**: old way, pass `iris.Configuration` directly, is still valid object to pass to the  `iris.New`, so don't be afraid for breaking change, the only thing you will need to edit is the names of the configuration you saw on the previous paragraph.

**Configuration Declaration**:

instead of old, but still valid to pass to the `iris.New`:
- `iris.New(iris.Configuration{Charset: ""UTF-8"", Sessions: iris.SessionsConfiguration{Cookie: ""cookienameid""}})`
  now you can just write this:
- `iris.New(iris.OptionCharset(""UTF-8""), iris.OptionSessionsCookie(""cookienameid""))`

`.New` **by configuration**

``` go
import ""github.com/kataras/iris""
//...
myConfig := iris.Configuration{Charset: ""UTF-8"", IsDevelopment:true, Sessions: iris.SessionsConfiguration{Cookie:""mycookie""}, Websocket: iris.WebsocketConfiguration{Endpoint: ""/my_endpoint""}}
iris.New(myConfig)
```

`.New` **by options**

``` go
import ""github.com/kataras/iris""
//...
iris.New(iris.OptionCharset(""UTF-8""), iris.OptionIsDevelopment(true), iris.OptionSessionsCookie(""mycookie""), iris.OptionWebsocketEndpoint(""/my_endpoint""))

// if you want to set configuration after the .New use the .Set:
iris.Set(iris.OptionDisableBanner(true))
```

**List** of all available options:

``` go
// OptionDisablePathCorrection corrects and redirects the requested path to the registed path
// for example, if /home/ path is requested but no handler for this Route found,
// then the Router checks if /home handler exists, if yes,
// (permant)redirects the client to the correct path /home
//
// Default is false
OptionDisablePathCorrection(val bool)

// OptionDisablePathEscape when is false then its escapes the path, the named parameters (if any).
OptionDisablePathEscape(val bool)

// OptionDisableBanner outputs the iris banner at startup
//
// Default is false
OptionDisableBanner(val bool)

// OptionLoggerOut is the destination for output
//
// Default is os.Stdout
OptionLoggerOut(val io.Writer)

// OptionLoggerPreffix is the logger's prefix to write at beginning of each line
//
// Default is [IRIS]
OptionLoggerPreffix(val string)

// OptionProfilePath a the route path, set it to enable http pprof tool
// Default is empty, if you set it to a $path, these routes will handled:
OptionProfilePath(val string)

// OptionDisableTemplateEngines set to true to disable loading the default template engine (html/template) and disallow the use of iris.UseEngine
// Default is false
OptionDisableTemplateEngines(val bool)

// OptionIsDevelopment iris will act like a developer, for example
// If true then re-builds the templates on each request
// Default is false
OptionIsDevelopment(val bool)

// OptionTimeFormat time format for any kind of datetime parsing
OptionTimeFormat(val string)

// OptionCharset character encoding for various rendering
// used for templates and the rest of the responses
// Default is ""UTF-8""
OptionCharset(val string)

// OptionGzip enables gzip compression on your Render actions, this includes any type of render, templates and pure/raw content
// If you don't want to enable it globaly, you could just use the third parameter on context.Render(""myfileOrResponse"", structBinding{}, iris.RenderOptions{""gzip"": true})
// Default is false
OptionGzip(val bool)

// OptionOther are the custom, dynamic options, can be empty
// this fill used only by you to set any app's options you want
// for each of an Iris instance
OptionOther(val ...options.Options) //map[string]interface{}, options is github.com/kataras/go-options

// OptionSessionsCookie string, the session's client cookie name, for example: ""qsessionid""
OptionSessionsCookie(val string)

// OptionSessionsDecodeCookie set it to true to decode the cookie key with base64 URLEncoding
// Defaults to false
OptionSessionsDecodeCookie(val bool)

// OptionSessionsExpires the duration of which the cookie must expires (created_time.Add(Expires)).
// If you want to delete the cookie when the browser closes, set it to -1 but in this case, the server side's session duration is up to GcDuration
//
// Default infinitive/unlimited life duration(0)
OptionSessionsExpires(val time.Duration)

// OptionSessionsCookieLength the length of the sessionid's cookie's value, let it to 0 if you don't want to change it
// Defaults to 32
OptionSessionsCookieLength(val int)

// OptionSessionsGcDuration every how much duration(GcDuration) the memory should be clear for unused cookies (GcDuration)
// for example: time.Duration(2)*time.Hour. it will check every 2 hours if cookie hasn't be used for 2 hours,
// deletes it from backend memory until the user comes back, then the session continue to work as it was
//
// Default 2 hours
OptionSessionsGcDuration(val time.Duration)

// OptionSessionsDisableSubdomainPersistence set it to true in order dissallow your q subdomains to have access to the session cookie
// defaults to false
OptionSessionsDisableSubdomainPersistence(val bool)

// OptionWebsocketWriteTimeout time allowed to write a message to the connection.
// Default value is 15 * time.Second
OptionWebsocketWriteTimeout(val time.Duration)

// OptionWebsocketPongTimeout allowed to read the next pong message from the connection
// Default value is 60 * time.Second
OptionWebsocketPongTimeout(val time.Duration)

// OptionWebsocketPingPeriod send ping messages to the connection with this period. Must be less than PongTimeout
// Default value is (PongTimeout * 9) / 10
OptionWebsocketPingPeriod(val time.Duration)

// OptionWebsocketMaxMessageSize max message size allowed from connection
// Default value is 1024
OptionWebsocketMaxMessageSize(val int64)

// OptionWebsocketBinaryMessages set it to true in order to denotes binary data messages instead of utf-8 text
// see https://github.com/kataras/iris/issues/387#issuecomment-243006022 for more
// defaults to false
OptionWebsocketBinaryMessages(val bool)

// OptionWebsocketEndpoint is the path which the websocket server will listen for clients/connections
// Default value is empty string, if you don't set it the Websocket server is disabled.
OptionWebsocketEndpoint(val string)

// OptionWebsocketReadBufferSize is the buffer size for the underline reader
OptionWebsocketReadBufferSize(val int)

// OptionWebsocketWriteBufferSize is the buffer size for the underline writer
OptionWebsocketWriteBufferSize(val int)

// OptionTesterListeningAddr is the virtual server's listening addr (host)
// Default is ""iris-go.com:1993""
OptionTesterListeningAddr(val string)

// OptionTesterExplicitURL If true then the url (should) be prepended manually, useful when want to test subdomains
// Default is false
OptionTesterExplicitURL(val bool)

// OptionTesterDebug if true then debug messages from the httpexpect will be shown when a test runs
// Default is false
OptionTesterDebug(val bool)


```

Now, some of you maybe use more than one server inside their iris instance/app, so you used the `iris.AddServer(config.Server{})`, which now becomes `iris.AddServer(iris.ServerConfiguration{})`, ServerConfiguration has also (optional) options to pass there and to `iris.ListenTo(OptionServerListeningAddr(""mydomain.com""))`:

``` go
// examples:
iris.AddServer(iris.OptionServerCertFile(""file.cert""),iris.OptionServerKeyFile(""file.key""))
iris.ListenTo(iris.OptionServerReadBufferSize(42000))

// or, old way but still valid:
iris.AddServer(iris.ServerConfiguration{ListeningAddr: ""mydomain.com"", CertFile: ""file.cert"", KeyFile: ""file.key""})
iris.ListenTo(iris.ServerConfiguration{ReadBufferSize:42000, ListeningAddr: ""mydomain.com""})
```

**List** of all Server's options:

``` go
OptionServerListeningAddr(val string)

OptionServerCertFile(val string)

OptionServerKeyFile(val string)

// AutoTLS enable to get certifications from the Letsencrypt
// when this configuration field is true, the CertFile & KeyFile are empty, no need to provide a key.
//
// example: https://github.com/iris-contrib/examples/blob/master/letsencyrpt/main.go
OptionServerAutoTLS(val bool)

// Mode this is for unix only
OptionServerMode(val os.FileMode)
// OptionServerMaxRequestBodySize Maximum request body size.
//
// The server rejects requests with bodies exceeding this limit.
//
// By default request body size is 8MB.
OptionServerMaxRequestBodySize(val int)

// Per-connection buffer size for requests' reading.
// This also limits the maximum header size.
//
// Increase this buffer if your clients send multi-KB RequestURIs
// and/or multi-KB headers (for example, BIG cookies).
//
// Default buffer size is used if not set.
OptionServerReadBufferSize(val int)

// Per-connection buffer size for responses' writing.
//
// Default buffer size is used if not set.
OptionServerWriteBufferSize(val int)

// Maximum duration for reading the full request (including body).
//
// This also limits the maximum duration for idle keep-alive
// connections.
//
// By default request read timeout is unlimited.
OptionServerReadTimeout(val time.Duration)

// Maximum duration for writing the full response (including body).
//
// By default response write timeout is unlimited.
OptionServerWriteTimeout(val time.Duration)

// RedirectTo, defaults to empty, set it in order to override the station's handler and redirect all requests to this address which is of form(HOST:PORT or :PORT)
//
// NOTE: the http status is 'StatusMovedPermanently', means one-time-redirect(the browser remembers the new addr and goes to the new address without need to request something from this server
// which means that if you want to change this address you have to clear your browser's cache in order this to be able to change to the new addr.
//
// example: https://github.com/iris-contrib/examples/tree/master/multiserver_listening2
OptionServerRedirectTo(val string)

// OptionServerVirtual If this server is not really listens to a real host, it mostly used in order to achieve testing without system modifications
OptionServerVirtual(val bool)

// OptionServerVListeningAddr, can be used for both virtual = true or false,
// if it's setted to not empty, then the server's Host() will return this addr instead of the ListeningAddr.
// server's Host() is used inside global template helper funcs
// set it when you are sure you know what it does.
//
// Default is empty """"
OptionServerVListeningAddr(val string)

// OptionServerVScheme if setted to not empty value then all template's helper funcs prepends that as the url scheme instead of the real scheme
// server's .Scheme returns VScheme if  not empty && differs from real scheme
//
// Default is empty """"
OptionServerVScheme(val string)

// OptionServerName the server's name, defaults to ""iris"".
// You're free to change it, but I will trust you to don't, this is the only setting whose somebody, like me, can see if iris web framework is used
OptionServerName(val string)

```

View all configuration fields and options by navigating to the [kataras/iris/configuration.go source file](https://github.com/kataras/iris/blob/master/configuration.go)

[Book](https://kataras.gitbooks.io/iris/content/configuration.html) & [Examples](https://github.com/iris-contrib/examples) are updated (website docs will be updated soon).
- **CHANGED**: Use of the standard `log.Logger` instead of the `iris-contrib/logger`(colorful logger), these changes are reflects some middleware, examples and plugins, I updated all of them, so don't worry.

So, [iris-contrib/middleware/logger](https://github.com/iris-contrib/middleware/tree/master/logger) will now NO need to pass other Logger instead, instead of: `iris.Use(logger.New(iris.Logger))` use -> `iris.Use(logger.New())` which will use the iris/instance's Logger.
- **ADDED**: `context.Framework()` which returns your Iris instance (typeof `*iris.Framework`), useful for the future(Iris will give you, soon, the ability to pass custom options inside an iris instance).
- Align with [go-sessions](https://github.com/kataras/go-sessions), no front-end changes, however I think that the best time to make an upgrade to your local Iris is right now.
- Remove unused Plugin's custom callbacks, if you still need them in your project use this instead: https://github.com/kataras/go-events

Zero front-end changes. No real improvements, developers can ignore this update.
- Replace the iris sessions with a new cross-framework package, [go-sessions](https://github.com/kataras/go-sessions). Same front-end API, sessions examples are compatible, configuration of `kataras/iris/config/sessions.go` is compatible. `kataras/context.SessionStore` is now `kataras/go-sessions.Session` (normally you, as user, never used it before, because of automatically session getting by `context.Session()`)
- `GzipWriter` is taken, now, from the `kataras/go-fs` package which has improvements versus the previous implementation.

Zero front-end changes. No real improvements, developers can ignore this update.
- Replace the template engines with a new cross-framework package, [go-template](https://github.com/kataras/go-websocket). Same front-end API, examples and iris-contrib/template are compatible.

Zero front-end changes. No real improvements, developers can ignore this update.
- Replace the main and underline websocket implementation with [go-websocket](https://github.com/kataras/go-websocket). Note that we still need the [ris-contrib/websocket](https://github.com/iris-contrib/websocket) package.
- Replace the use of iris-contrib/errors with [go-errors](https://github.com/kataras/go-errors), which has more features
- **NEW FEATURE**: Optionally `OnError` foreach Party (by prefix, use it with your own risk), example [here](https://github.com/iris-contrib/examples/blob/master/httperrors/main.go#L37)
- **NEW**: `iris.Config.Sessions.CookieLength`, You're able to customize the length of each sessionid's cookie's value. Default (and previous' implementation) is 32.
- **FIX**: Websocket panic on non-websocket connection[*](https://github.com/kataras/iris/issues/367)
- **FIX**: Multi websocket servers client-side source route panic[*](https://github.com/kataras/iris/issues/365)
- Better gzip response managment
- **Feature request has been implemented**: Add layout support for Pug/Jade, example [here](https://github.com/iris-contrib/examples/tree/master/template_engines/template_pug_2).
- **Feature request has been implemented**: Forcefully closing a Websocket connection, `WebsocketConnection.Disconnect() error`.
- **FIX**: WebsocketConnection.Leave() will hang websocket server if .Leave was called manually when the websocket connection has been closed.
- **FIX**: StaticWeb not serving index.html correctly, align the func with the rest of Static funcs also, [example](https://github.com/iris-contrib/examples/tree/master/static_web) added.

Notes: if you compare it with previous releases (13+ versions before v3 stable), the v4 stable release was fast, now we had only 6 versions before stable, that was happened because many of bugs have been already fixed and we hadn't new bug reports and secondly, and most important for me, some third-party features are implemented mostly by third-party packages via other developers!
- **NEW FEATURE**: Letsencrypt.org integration[*](https://github.com/kataras/iris/issues/220)
  - example [here](https://github.com/iris-contrib/examples/blob/master/letsencrypt/main.go)
- **FIX**: (ListenUNIX adds :80 to filename)[https://github.com/kataras/iris/issues/321]
- **FIX**: (Go-Bindata + ctx.Render)[https://github.com/kataras/iris/issues/315]
- **FIX** (auto-gzip doesn't really compress data in latest code)[https://github.com/kataras/iris/issues/312]

**The important** , is that the [book](https://kataras.gitbooks.io/iris/content/) is finally updated!

If you're **willing to donate** click [here](DONATIONS.md)!
- `iris.Config.Gzip`, enables gzip compression on your Render actions, this includes any type of render, templates and pure/raw content. If you don't want to enable it globaly, you could just use the third parameter on context.Render(""myfileOrResponse"", structBinding{}, iris.RenderOptions{""gzip"": true}). It defaults to false
-  **Added** `config.Server.Name` as requested

**Fix**
- https://github.com/kataras/iris/issues/301

*_Sessions changes *_
- `iris.Config.Sessions.Expires` it was time.Time, changed to time.Duration, which defaults to 0, means unlimited session life duration, if you change it then the correct date is setted on client's cookie but also server destroys the session automatically when the duration passed, this is better approach, see [here](https://github.com/kataras/iris/issues/301)

**New**

A **Response Engine** gives you the freedom to create/change the render/response writer for
- `context.JSON`
- `context.JSONP`
- `context.XML`
- `context.Text`
- `context.Markdown`
- `context.Data`
- `context.Render(""my_custom_type"",mystructOrData{}, iris.RenderOptions{""gzip"":false,""charset"":""UTF-8""})`
- `context.MarkdownString`
- `iris.ResponseString(...)`

**Fix**
- https://github.com/kataras/iris/issues/294
- https://github.com/kataras/iris/issues/303

**Small changes**
- `iris.Config.Charset`, before alpha.3 was `iris.Config.Rest.Charset` & `iris.Config.Render.Template.Charset`, but you can override it at runtime by passinth a map `iris.RenderOptions` on the `context.Render` call .
- `iris.Config.IsDevelopment`, before alpha.1 was `iris.Config.Render.Template.IsDevelopment`

**Websockets changes**

No need to import the `github.com/kataras/iris/websocket` to use the `Connection` iteral, the websocket moved inside `kataras/iris` , now all exported variables' names have the prefix of `Websocket`, so the old `websocket.Connection` is now `iris.WebsocketConnection`.

Generally, no other changes on the 'frontend API', for response engines examples and how you can register your own to add more features on existing response engines or replace them, look [here](https://github.com/iris-contrib/response).

**BAD SIDE**: E-Book is still pointing on the v3 release, but will be updated soon.

*_Sessions were re-written *_
- Developers can use more than one 'session database', at the same time, to store the sessions
- Easy to develop a custom session database (only two functions are required (Load & Update)), [learn more](https://github.com/iris-contrib/sessiondb/blob/master/redis/database.go)
- Session databases are located [here](https://github.com/iris-contrib/sessiondb), contributions are welcome
- The only frontend deleted 'thing' is the: **config.Sessions.Provider**
- No need to register a database, the sessions works out-of-the-box
- No frontend/API changes except the `context.Session().Set/Delete/Clear`, they doesn't return errors anymore, btw they (errors) were always nil :)
- Examples (master branch) were updated.

``` sh
$ go get github.com/kataras/go-sessions/sessiondb/$DATABASE
```

``` go
db := $DATABASE.New(configurationHere{})
iris.UseSessionDB(db)
```

## 3.0.0 -> 4.0.0-alpha.1

[logger](https://github.com/iris-contrib/logger), [rest](https://github.com/iris-contrib/rest) and all [template engines](https://github.com/iris-contrib/template) **moved** to the [iris-contrib](https://github.com/iris-contrib).
- `config.Logger` -> `iris.Logger.Config`
- `config.Render/config.Render.Rest/config.Render.Template` -> **Removed**
- `config.Render.Rest` -> `rest.Config`
- `config.Render.Template` -> `$TEMPLATE_ENGINE.Config` except Directory,Extensions, Assets, AssetNames,
- `config.Render.Template.Directory` -> `iris.UseTemplate($TEMPLAET_ENGINE.New()).Directory(""./templates"", "".html"")`
- `config.Render.Template.Assets` -> `iris.UseTemplate($TEMPLAET_ENGINE.New()).Directory(""./templates"","".html"").Binary(assetFn func(name string) ([]byte, error), namesFn func() []string)`
- `context.ExecuteTemplate` -> **Removed**, you can use the `context.Response.BodyWriter()` to get its writer and execute html/template engine manually, but this is useless because we support the best support for template engines among all other (golang) web frameworks
- **Added** `config.Server.ReadBufferSize & config.Server.WriteBufferSize` which can be passed as configuration fields inside `iris.ListenTo(config.Server{...})`, which does the same job as `iris.Listen`
- **Added** `iris.UseTemplate($TEMPLAET_ENGINE.New()).Directory(""./templates"", "".html"")` to register a template engine, now iris supports multi template engines, each template engine has its own file extension, no big changes on context.Render except the last parameter:
- `context.Render(filename string, binding interface{}, layout string{})` -> `context.Render(filename string, binding interface{}, options ...map[string]interface{})  | context.Render(""myfile.html"", myPage{}, iris.Map{""gzip"":true,""layout"":""layouts/MyLayout.html""}) |`

E-book and examples are not yet updated, no big changes.

## 3.0.0-rc.4 -> 3.0.0-pre.release
- `context.PostFormValue` -> `context.FormValueString`, old func stays until the next revision
- `context.PostFormMulti` -> `context.FormValues` , old func stays until the next revision
- Added `context.VisitAllCookies(func(key,value string))` to visit all your cookies (because `context.Request.Header.VisitAllCookie` has a bug(I can't fix/pr it because the author is away atm))
- Added `context.GetFlashes` to get all available flash messages for a particular request
- Fix flash message removed after the first `GetFlash` call in the same request

**NEW FEATURE**: Built'n support for multi listening servers per iris station, secondary and virtual servers with one-line using the `iris.AddServer` & `iris.Go` to start all servers.
- `iris.SecondaryListen` -> `iris.AddServer`, old func stays until the next revision
- Added `iris.Servers` with this field you can manage your servers very easy
- Added `iris.AddServer/iris.ListenTo/iris.Go`, but funcs like `Listen/ListenTLS/ListenUNIX` will stay forever
- Added `config.Server.Virtual(bool), config.Server.RedirectTo(string) and config.Server.MaxRequestBodySize(int64)`
- Added `iris.Available (channel bool)`
- `iris.HTTPServer` -> `iris.Servers.Main()` to get the main server, which is always the last registered server (if more than one used), old field removed
- `iris.Config.MaxRequestBodySize` -> `config.Server.MaxRequestBodySize`, old field removed

**NEW FEATURE**: Build'n support for your API's end-to-end tests
- Added `tester := iris.Tester(*testing.T)` , look inside: [http_test.go](https://github.com/kataras/iris/blob/master/http_test.go) & [./context_test.go](https://github.com/kataras/iris/blob/master/context_test.go) for `Tester` usage, you can also look inside the [httpexpect's repo](https://github.com/gavv/httpexpect/blob/master/example/iris_test.go) for extended examples with Iris.

## 3.0.0-rc.3 -> 3.0.0-rc.4

**NEW FEATURE**: **Handlebars** template engine support with all Iris' view engine's functions/helpers support, as requested [here](https://github.com/kataras/iris/issues/239):
- `iris.Config.Render.Template.Layout = ""layouts/layout.html""`
- `config.NoLayout`
- **dynamic** optional layout on `context.Render`
- **Party specific** layout
- `iris.Config.Render.Template.Handlebars.Helpers[""myhelper""] = func()...`
- `{{ yield }}`
- `{{ render }}`
- `{{ url ""myroute"" myparams}}`
- `{{ urlpath ""myroute"" myparams}}`

For a complete example please, click [here](https://github.com/iris-contrib/examples/tree/master/templates_handlebars).

**NEW:** Iris **can listen to more than one server per station** now, as requested [here](https://github.com/kataras/iris/issues/235).
For example you can have https with SSL/TLS and one more server http which navigates to the secure location.
Take a look [here](https://github.com/kataras/iris/issues/235#issuecomment-229399829) for an example of this.

**FIXES**
- Fix  `sessions destroy`
- Fix  `sessions persistence on subdomains` (as RFC2109 commands but you can disable it with `iris.Config.Sessions.DisableSubdomainPersistence = true`)

**IMPROVEMENTS**
- Improvements on `iris run` && `iris create`, note that the underline code for hot-reloading moved to [rizla](https://github.com/kataras/rizla).

## 3.0.0-rc.2 -> 3.0.0-rc.3

**Breaking changes**
- Move middleware & their configs to the  [iris-contrib/middleware](https://github.com/iris-contrib/middleware) repository
- Move all plugins & their configs to the [iris-contrib/plugin](https://github.com/iris-contrib/plugin) repository
- Move the graceful package to the [iris-contrib/graceful](https://github.com/iris-contrib/graceful) repository
- Move the mail package & its configs to the [iris-contrib/mail](https://github.com/iris-contrib/mail) repository

Note 1: iris.Config.Mail doesn't not logger exists, use `mail.Config` from the `iris-contrib/mail`, and `service:= mail.New(configs); service.Send(....)`.

Note 2: basicauth middleware's context key changed from `context.GetString(""auth"")` to `context.GetString(""user"")`.

Underline changes, libraries used by iris' base code:
- Move the errors package to the [iris-contrib/errors](https://github.com/iris-contrib/errors) repository
- Move the tests package to the [iris-contrib/tests](https://github.com/iris-contrib/tests) repository (Yes, you should make PRs now with no fear about breaking the Iris).

**NEW**:
- OAuth, OAuth2 support via plugin (facebook,gplus,twitter and 25 more), gitbook section [here](https://kataras.gitbooks.io/iris/content/plugin-oauth.html), plugin [example](https://github.com/iris-contrib/examples/blob/master/plugin_oauth_oauth2/main.go), low-level package example [here](https://github.com/iris-contrib/examples/tree/master/oauth_oauth2) (no performance differences, it's just a working version of [goth](https://github.com/markbates/goth) which is converted to work with Iris)
- JSON Web Tokens support via [this middleware](https://github.com/iris-contrib/middleware/tree/master/jwt), book section [here](https://kataras.gitbooks.io/iris/content/jwt.html), as requested [here](https://github.com/kataras/iris/issues/187).

**Fixes**:
- [Iris run fails when not running from ./](https://github.com/kataras/iris/issues/215)
- [Fix or disable colors in iris run](https://github.com/kataras/iris/issues/217).

Improvements to the `iris run` **command**, as requested [here](https://github.com/kataras/iris/issues/192).

[Book](https://kataras.gitbooks.io/iris/content/) and [examples](https://github.com/iris-contrib/examples) are **updated** also.

## 3.0.0-rc.1 -> 3.0.0-rc.2

New:
- `iris.MustUse/MustUseFunc`  - registers middleware for all route parties, all subdomains and all routes.
- iris control plugin re-written, added real time browser request logger
- `websocket.OnError` - Add OnError to be able to catch internal errors from the connection
- [command line tool](https://github.com/kataras/iris/tree/master/iris) - `iris run main.go` runs, watch and reload on source code changes. As requested [here](https://github.com/kataras/iris/issues/192)

Fixes: https://github.com/kataras/iris/issues/184 , https://github.com/kataras/iris/issues/175 .

## 3.0.0-beta.3, 3.0.0-beta.4 -> 3.0.0-rc.1

This version took me many days because the whole framework's underline code is rewritten after many many many 'yoga'. Iris is not so small anymore, so I (tried) to organized it a little better. Note that, today, you can just go to [iris.go](https://github.com/kataras/iris/tree/master/iris.go) and [context.go](https://github.com/kataras/iris/tree/master/context/context.go) and look what functions you can use. You had some 'bugs' to subdomains, mail service, basic authentication and logger, these are fixed also, see below...

All [examples](https://github.com/iris-contrib/examples) are updated, and I tested them one by one.

Many underline changes but the public API didn't changed much, of course this is relative to the way you use this framework, because that:
- Configuration changes: **0**
- iris.Iris pointer -> **iris.Framework** pointer
- iris.DefaultIris -> **iris.Default**
- iris.Config() -> **iris.Config** is field now
- iris.Websocket() -> **iris.Websocket** is field now
- iris.Logger() -> **iris.Logger** is field now
- iris.Plugins() -> **iris.Plugins** is field now
- iris.Server() -> **iris.HTTPServer** is field now
- iris.Rest() -> **REMOVED**
- iris.Mail() -> **REMOVED**
- iris.Mail().Send() -> **iris.SendMail()**
- iris.Templates() -> **REMOVED**
- iris.Templates().RenderString() -> **iris.TemplateString()**
- iris.StaticHandlerFunc -> **iris.StaticHandler**
- iris.URIOf() -> **iris.URL()**
- iris.PathOf() -> **iris.Path()**
- context.RenderString() returned string,error -> **context.TemplateString() returns only string, which is empty on any parse error**
- context.WriteHTML() -> **context.HTML()**
- context.HTML() -> **context.RenderWithStatus()**

Entirely new
-  -> **iris.ListenUNIX(addr string, socket os.Mode)**
-  -> **context.MustRender, same as Render but send response 500 and logs the error on parse error**
-  -> **context.Log(format string, a...interface{})**
-  -> **context.PostFormMulti(name string) []string**
-  -> **iris.Lookups() []Route**
-  -> **iris.Lookup(routeName string) Route**
-  -> **iris.Plugins.On(eventName string, ...func())** and fire all by **iris.Plugins.Call(eventName)**
- iris.Wildcard() **REMOVED**, subdomains and dynamic(wildcard) subdomains can only be registered with **iris.Party(""mysubdomain."") && iris.Party(""*."")**

Semantic change for static subdomains

**1**

**BEFORE** :

``` go
apiSubdomain := iris.Party(""api.mydomain.com"")
{
//....
}
iris.Listen(""mydomain.com:80"")
```

**NOW** just subdomain part, no need to duplicate ourselves:

``` go
apiSubdomain := iris.Party(""api."")
{
//....
}
iris.Listen(""mydomain.com:80"")
```

**2**

Before you couldn't set dynamic subdomains and normal subdomains at the same iris station, now you can.
**NOW, this is possible**

``` go
/* admin.mydomain.com,  and for other subdomains the Party(*.) */

admin := iris.Party(""admin."")
{
    // admin.mydomain.com
    admin.Get(""/"", func(c *iris.Context) {
        c.Write(""INDEX FROM admin.mydomain.com"")
    })
    // admin.mydomain.com/hey
    admin.Get(""/hey"", func(c *iris.Context) {
        c.Write(""HEY FROM admin.mydomain.com/hey"")
    })
    // admin.mydomain.com/hey2
    admin.Get(""/hey2"", func(c *iris.Context) {
        c.Write(""HEY SECOND FROM admin.mydomain.com/hey"")
    })
}

// other.mydomain.com, otadsadsadsa.mydomain.com  and so on....
dynamicSubdomains := iris.Party(""*."")
{
    dynamicSubdomains.Get(""/"", dynamicSubdomainHandler)

    dynamicSubdomains.Get(""/something"", dynamicSubdomainHandler)

    dynamicSubdomains.Get(""/something/:param1"", dynamicSubdomainHandlerWithParam)
}
```

Minor change for listen

**BEFORE you could just listen to a port**

``` go
iris.Listen(""8080"")
```

**NOW you have set a HOSTNAME:PORT**

``` go
iris.Listen("":8080"")
```

Relative issues/features:  https://github.com/kataras/iris/issues/166 , https://github.com/kataras/iris/issues/176, https://github.com/kataras/iris/issues/183,  https://github.com/kataras/iris/issues/184

**Plugins**

PreHandle and PostHandle are removed, no need to use them anymore you can take routes by **iris.Lookups()**, but add support for custom event listeners by **iris.Plugins.On(""event"",func(){})** and fire all callbacks by **iris.Plugins.Call(""event"")** .

**FOR TESTERS**

**BEFORE** :

``` go
api := iris.New()
//...

api.PreListen(config.Server{ListeningAddr: """"})

e := httpexpect.WithConfig(httpexpect.Config{
    Reporter: httpexpect.NewAssertReporter(t),
    Client:   fasthttpexpect.NewBinder(api.ServeRequest),
})

```

**NOW**:

``` go
api := iris.New()
//...

e := httpexpect.WithConfig(httpexpect.Config{
    Reporter: httpexpect.NewAssertReporter(t),
    Client:   fasthttpexpect.NewBinder(api.NoListen().Handler),
})


```

## 3.0.0-beta.2 -> 3.0.0-beta.3
- Complete the Jade Template Engine support, {{ render }} and {{ url }} done also.
- Fix Mail().Send
- Iriscontrol plugin: Replace login using session to basic authentication

And other not-too-important fixes

## 3.0.0-beta -> 3.0.0-beta.2
- NEW: Wildcard(dynamic) subdomains, read [here](https://kataras.gitbooks.io/iris/content/subdomains.html)
- NEW: Implement feature request [#165](https://github.com/kataras/iris/issues/165). Routes can now be selected by `a custom name`, and this allows us to use the {{ url ""custom-name"" ""any"" ""named"" ""parameters""}}``: For HTML & Amber engines, example [here](https://github.com/iris-contrib/examples/tree/master/templates_9). For PongoEngine, example [here](https://github.com/iris-contrib/examples/tree/master/templates_10_pongo)
- Remove the [x/net/context](https://godoc.org/golang.org/x/net/context), it has been useless after v2.

## 3.0.0-alpha.beta -> 3.0.0-beta
- New iris.API for easy API declaration, read more [here](https://kataras.gitbooks.io/iris/content/using-handlerapi.html), example [there](https://github.com/iris-contrib/examples/tree/master/api_handler_2).
- Add [example](https://github.com/iris-contrib/examples/tree/master/middleware_basicauth_2) and fix the Basic Authentication middleware

## 3.0.0-alpha.6 -> 3.0.0-alpha.beta
- [Implement feature request to add Globals on the pongo2](https://github.com/kataras/iris/issues/145)
- [Implement feature request for static Favicon ](https://github.com/kataras/iris/issues/141)
- Implement a unique easy only-websocket support:

``` go
OnConnection(func(c websocket.Connection){})
```

websocket.Connection

``` go

// Receive from the client
On(""anyCustomEvent"", func(message string) {})
On(""anyCustomEvent"", func(message int){})
On(""anyCustomEvent"", func(message bool){})
On(""anyCustomEvent"", func(message anyCustomType){})
On(""anyCustomEvent"", func(){})

// Receive a native websocket message from the client
// compatible without need of import the iris-ws.js to the .html
OnMessage(func(message []byte){})

// Send to the client
Emit(""anyCustomEvent"", string)
Emit(""anyCustomEvent"", int)
Emit(""anyCustomEvent"", bool)
Emit(""anyCustomEvent"", anyCustomType)

// Send via native websocket way, compatible without need of import the iris-ws.js to the .html
EmitMessage([]byte(""anyMessage""))

// Send to specific client(s)
To(""otherConnectionId"").Emit/EmitMessage...
To(""anyCustomRoom"").Emit/EmitMessage...

// Send to all opened connections/clients
To(websocket.All).Emit/EmitMessage...

// Send to all opened connections/clients EXCEPT this client(c)
To(websocket.NotMe).Emit/EmitMessage...

// Rooms, group of connections/clients
Join(""anyCustomRoom"")
Leave(""anyCustomRoom"")


// Fired when the connection is closed
OnDisconnect(func(){})

```
- [Example](https://github.com/iris-contrib/examples/tree/master/websocket)
- [E-book section](https://kataras.gitbooks.io/iris/content/package-websocket.html)

We have some base-config's changed, these configs which are defaulted to true renamed to 'Disable+$oldName'

``` go

        // DisablePathCorrection corrects and redirects the requested path to the registed path
        // for example, if /home/ path is requested but no handler for this Route found,
        // then the Router checks if /home handler exists, if yes,
        // (permant)redirects the client to the correct path /home
        //
        // Default is false
        DisablePathCorrection bool

        // DisablePathEscape when is false then its escapes the path, the named parameters (if any).
        // Change to true it if you want something like this https://github.com/kataras/iris/issues/135 to work
        //
        // When do you need to Disable(true) it:
        // accepts parameters with slash '/'
        // Request: http://localhost:8080/details/Project%2FDelta
        // ctx.Param(""project"") returns the raw named parameter: Project%2FDelta
        // which you can escape it manually with net/url:
        // projectName, _ := url.QueryUnescape(c.Param(""project"").
        // Look here: https://github.com/kataras/iris/issues/135 for more
        //
        // Default is false
        DisablePathEscape bool

        // DisableLog turn it to true if you want to disable logger,
        // Iris prints/logs ONLY errors, so be careful when you enable it
        DisableLog bool

        // DisableBanner outputs the iris banner at startup
        //
        // Default is false
        DisableBanner bool

```

## 3.0.0-alpha.5 -> 3.0.0-alpha.6

Changes:
    - config/iris.Config().Render.Template.HTMLTemplate.Funcs typeof `[]template.FuncMap` -> `template.FuncMap`

Added:
    - iris.AmberEngine [Amber](https://github.com/eknkc/amber). [View an example](https://github.com/iris-contrib/examples/tree/master/templates_7_html_amber)
    - iris.JadeEngine [Jade](https://github.com/Joker/jade). [View an example](https://github.com/iris-contrib/examples/tree/master/templates_6_html_jade)

Book section [Render/Templates updated](https://kataras.gitbooks.io/iris/content/render_templates.html)

## 3.0.0-alpha.4 -> 3.0.0-alpha.5
- [NoLayout support for particular templates](https://github.com/kataras/iris/issues/130#issuecomment-219754335)
- [Raw Markdown Template Engine](https://kataras.gitbooks.io/iris/content/render_templates.html)
- [Markdown to HTML](https://kataras.gitbooks.io/iris/content/render_rest.html) > `context.Markdown(statusCode int, markdown string)` , `context.MarkdownString(markdown string) (htmlReturn string)`
- [Simplify the plugin registration](https://github.com/kataras/iris/issues/126#issuecomment-219622481)

## 3.0.0-alpha.3 -> 3.0.0-alpha.4

Community suggestions implemented:
- [Request: Rendering html template to string](https://github.com/kataras/iris/issues/130)
  > New RenderString(name string, binding interface{}, layout ...string) added to the Context & the Iris' station (iris.Templates().RenderString)
- [Minify Templates](https://github.com/kataras/iris/issues/129)
  > New config field for minify, defaulted to true: iris.Config().Render.Template.Minify  = true
  > 3.0.0-alpha5+ this has been removed because the minify package has bugs, one of them is this: https://github.com/tdewolff/minify/issues/35.

Bugfixes and enhancements:
- [Static not allowing configuration of `IndexNames`](https://github.com/kataras/iris/issues/128)
- [Processing access error](https://github.com/kataras/iris/issues/125)
- [Invalid header](https://github.com/kataras/iris/issues/123)

## 3.0.0-alpha.2 -> 3.0.0-alpha.3

The only change here is a panic-fix on form bindings. Now **no need to make([]string,0)** before form binding, new example:

``` go
 //./main.go

package main

import (
    ""fmt""

    ""github.com/kataras/iris""
)

type Visitor struct {
    Username string
    Mail     string
    Data     []string `form:""mydata""`
}

func main() {

    iris.Get(""/"", func(ctx *iris.Context) {
        ctx.Render(""form.html"", nil)
    })

    iris.Post(""/form_action"", func(ctx *iris.Context) {
        visitor := Visitor{}
        err := ctx.ReadForm(&visitor)
        if err != nil {
            fmt.Println(""Error when reading form: "" + err.Error())
        }
        fmt.Printf(""\n Visitor: %v"", visitor)
    })

    fmt.Println(""Server is running at :8080"")
    iris.Listen("":8080"")
}

```

``` html

<!-- ./templates/form.html -->
<!DOCTYPE html>
<head>
<meta charset=""utf-8"">
</head>
<body>
<form action=""/form_action"" method=""post"">
<input type=""text"" name=""Username"" />
<br/>
<input type=""text"" name=""Mail"" /><br/>
<select multiple=""multiple"" name=""mydata"">
<option value='one'>One</option>
<option value='two'>Two</option>
<option value='three'>Three</option>
<option value='four'>Four</option>
</select>
<hr/>
<input type=""submit"" value=""Send data"" />

</form>
</body>
</html>

```

## 3.0.0-alpha.1 -> 3.0.0-alpha.2

_The e-book was updated, take a closer look [here](https://www.gitbook.com/book/kataras/iris/details)_

**Breaking changes**

**First**. Configuration owns a package now `github.com/kataras/iris/config` . I took this decision after a lot of thought and I ensure you that this is the best
architecture to easy:
- change the configs without need to re-write all of their fields.
  
  ``` go
  irisConfig := config.Iris { Profile: true, PathCorrection: false }
  api := iris.New(irisConfig)
  ```
- easy to remember: `iris` type takes config.Iris, sessions takes config.Sessions`,`iris.Config().Render`is`config.Render`,`iris.Config().Render.Template`is`config.Template`,`Logger`takes`config.Logger` and so on...
- easy to find what features are exists and what you can change: just navigate to the config folder and open the type you want to learn about, for example `/iris.go` Iris' type configuration is on `/config/iris.go`
- default setted fields which you can use. They are already setted by iris, so don't worry too much, but if you ever need them you can find their default configs by this pattern: for example `config.Template` has `config.DefaultTemplate()`, `config.Rest` has `config.DefaultRest()`, `config.Typescript()` has `config.DefaultTypescript()`, note that only `config.Iris` has `config.Default()`. I wrote that all structs even the plugins have their default configs now, to make it easier for you, so you can do this without set a config by yourself: `iris.Config().Render.Template.Engine = config.PongoEngine` or `iris.Config().Render.Template.Pongo.Extensions = []string{"".xhtml"", "".html""}`.

**Second**. Template & rest package moved to the `render`, so

```
    *  a new config field named `render` of type `config.Render` which nests the `config.Template` & `config.Rest`
    -  `iris.Config().Templates` -> `iris.Config().Render.Template` of type `config.Template`
    - `iris.Config().Rest` -> `iris.Config().Render.Rest` of type `config.Rest`
```

**Third, sessions**.

Configuration instead of parameters. Before `sessions.New(""memory"",""sessionid"",time.Duration(42) * time.Minute)` -> Now:  `sessions.New(config.DefaultSessions())` of type `config.Sessions`
- Before this change the cookie's life was the same as the manager's Gc duration. Now added an Expires option for the cookie's life time which defaults to infinitive, as you (correctly) suggests me in the chat community.-
- Default Cookie's expiration date: from 42 minutes -> to  `infinitive/forever`
- Manager's Gc duration: from 42 minutes -> to '2 hours'
- Redis store's MaxAgeSeconds: from 42 minutes -> to '1 year`

**Four**. Typescript, Editor & IrisControl plugins now accept a config.Typescript/ config.Editor/ config.IrisControl as parameter

Bugfixes
- [can't open /xxx/ path when PathCorrection = false ](https://github.com/kataras/iris/issues/120)
- [Invalid content on links on debug page when custom ProfilePath is set](https://github.com/kataras/iris/issues/118)
- [Example with custom config not working ](https://github.com/kataras/iris/issues/115)
- [Debug Profiler writing escaped HTML?](https://github.com/kataras/iris/issues/107)
- [CORS middleware doesn't work](https://github.com/kataras/iris/issues/108)

## 2.3.2 -> 3.0.0-alpha.1

**Changed**
- `&render.Config` -> `&iris.RestConfig` . All related to the html/template are removed from there.
- `ctx.Render(""index"",...)` -> `ctx.Render(""index.html"",...)` or any extension you have defined in iris.Config().Templates.Extensions
- `iris.Config().Render.Layout = ""layouts/layout""` -> `iris.Config().Templates.Layout = ""layouts/layout.html""`
- `License BSD-3 Clause Open source` -> `MIT License`
  **Added**
- Switch template engines via `IrisConfig`. Currently, HTMLTemplate is 'html/template'. Pongo is 'flosch/pongo2`. Refer to the Book, which is updated too, [read here](https://kataras.gitbooks.io/iris/content/render.html).
",,,,https://api.github.com/repos/kataras/iris/releases/4523635/assets,https://api.github.com/repos/kataras/iris/releases/4523635,4.0.0,https://api.github.com/repos/kataras/iris/tarball/v4,https://github.com/kataras/iris/releases/tag/v4,https://api.github.com/repos/kataras/iris/zipball/v4,v4,False,False
